\subsubsection{ARM: \OptimizingKeil + \ThumbMode}

\lstinputlisting{04_scanf/checking_retval_ARM_Keil_thumb_O3.asm}

\IFRU{Новые инструкции здесь для нас: \CMP и \TT{BEQ}.}
{New instructions here are \CMP and \TT{BEQ}.}

\CMP \IFRU{аналогична той что в x86, она отнимает один аргумент от второго и сохраняет флаги.}
{is similar to the x86 instruction, it subtracts one argument from another and save flags.}
% TODO: в мануале ARM $op1 + NOT(op2) + 1$ вместо вычитания

\TT{BEQ} (\IT{Branch Equal}) \IFRU{совершает переход по другому адресу, 
если операнды при сравнении были равны, 
либо если результат последнего вычисления был ноль, либо если флаг Z равен $1$.}
{is jumping to another address if operands while comparing were equal to each other, or,
if result of last computation was zero, or if Z flag is $1$.}
\IFRU{То же что и \JZ в}{Same thing as \JZ in} x86.

\IFRU{Всё остальное просто: исполнение разветвляется на две ветки, затем они сходятся там, 
где в \Rzero записывается $0$ как возвращаемое из функции значение и происходит выход из функции.}
{Everything else is simple: execution flow is forking into two branches, then the branches are 
converging at the place
where $0$ is written into \Rzero, as a value returned from the function, and then function finishing.}

