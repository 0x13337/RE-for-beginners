\subsection{ARM}

\subsubsection{\OptimizingKeil + \ThumbMode}

\begin{lstlisting}
.text:00000042             scanf_main
.text:00000042
.text:00000042             var_8           = -8
.text:00000042
.text:00000042 08 B5                       PUSH    {R3,LR}
.text:00000044 A9 A0                       ADR     R0, aEnterX     ; "Enter X:\n"
.text:00000046 06 F0 D3 F8                 BL      __2printf
.text:0000004A 69 46                       MOV     R1, SP
.text:0000004C AA A0                       ADR     R0, aD          ; "%d"
.text:0000004E 06 F0 CD F8                 BL      __0scanf
.text:00000052 00 99                       LDR     R1, [SP,#8+var_8]
.text:00000054 A9 A0                       ADR     R0, aYouEnteredD___ ; "You entered %d...\n"
.text:00000056 06 F0 CB F8                 BL      __2printf
.text:0000005A 00 20                       MOVS    R0, #0
.text:0000005C 08 BD                       POP     {R3,PC}
\end{lstlisting}

Чтобы \scanf мог вернуть значение, нужно передать ему указатель на переменную типа \Tint. \Tint ~--- 32-битное 
значение, для его хранения нужно только 4 байта и оно помещается в регистр.
Локальная переменная \TT{x} выделяется в стеке, \IDA наименовала её \IT{var\_8}, место для нее выделять
не обязательно, т.к., указатель стека \SP уже указывает на место, свободное для использования.
Так что указатель \SP копируется в регистр \TT{R1} и вместе с format-строкой, передается в \scanf.
Позже, при помощи инструкции \TT{LDR}, это значение перемещается из стека в регистр R1, чтобы быть переданным
в \printf.

Варианты скомпилированные для ARM-режима процессора, а также варианты скомпилированные при помощи Xcode,
не очень отличаются от этого, так что, мы можем пропустить их здесь.

