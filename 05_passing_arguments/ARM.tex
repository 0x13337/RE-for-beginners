\subsection{ARM}

\subsubsection{\NonOptimizingKeil + \ARMMode}

\begin{lstlisting}
.text:000000A4             f                              ; CODE XREF: main+10
.text:000000A4 00 30 A0 E1                 MOV     R3, R0
.text:000000A8 93 21 20 E0                 MLA     R0, R3, R1, R2
.text:000000AC 1E FF 2F E1                 BX      LR
...
.text:000000B0             main
.text:000000B0 10 40 2D E9                 STMFD   SP!, {R4,LR}
.text:000000B4 03 20 A0 E3                 MOV     R2, #3
.text:000000B8 02 10 A0 E3                 MOV     R1, #2
.text:000000BC 01 00 A0 E3                 MOV     R0, #1
.text:000000C0 F7 FF FF EB                 BL      f
.text:000000C4 00 40 A0 E1                 MOV     R4, R0
.text:000000C8 04 10 A0 E1                 MOV     R1, R4
.text:000000CC 5A 0F 8F E2                 ADR     R0, aD_0        ; "%d\n"
.text:000000D0 E3 18 00 EB                 BL      __2printf
.text:000000D4 00 00 A0 E3                 MOV     R0, #0
.text:000000D8 10 80 BD E8                 LDMFD   SP!, {R4,PC}
\end{lstlisting}

В функции \main просто вызываются две функции, в первую передается три значения.

Как я уже упоминал, первые 4 значения, в ARM обычно передаются в первых 4-х регистрах (R0-R3).

Функция \TT{f}, как видно, использует три первых регистра (R0-R2).

Инструкция \TT{MLA} (\IT{Multiply Accumulate}) перемножает два первых операнда (R3 и R1), прибавляет к произведению
третий операнд (R2) и помещает результат в нулевой операнд (R0), через который, по стандарту, возвращаются
значения функций.

Умножение и сложение одновременно\footnote{\href{https://ru.wikipedia.org/wiki/\%D0\%A3\%D0\%BC\%D0\%BD\%D0\%BE\%D0\%B6\%D0\%B5\%D0\%BD\%D0\%B8\%D0\%B5-\%D1\%81\%D0\%BB\%D0\%BE\%D0\%B6\%D0\%B5\%D0\%BD\%D0\%B8\%D0\%B5}{wikipedia: Умножение-сложение}} (\IT{Fused multiply–add}) это много где применяемая операция, кстати, аналогичной
инструкции в x86 нет, если не считать новых 
FMA-инструкций\footnote{\url{https://en.wikipedia.org/wiki/FMA_instruction_set}} в SIMD.

Самая первая инструкция \TT{MOV R3, R0}, по видимому, избыточна (можно было бы обойтись только одной инструкцией 
\TT{MLA}), компилятор не оптимизировал её, ведь, это компиляция без оптимизации.

Инструкция \TT{BX} возвращает управление по адресу записанному в \LR и, если нужно, переключает режимы процессора
с thumb на ARM или наоборот. Это для того нужно, что, как мы видим, функции \TT{f} неизвестно, из какого кода
она будет вызываться, из ARM или thumb. Поэтому, если она будет вызываться из thumb, \TT{BX} не только вернет
управление в вызывающую функцию, но также переключит процессор в режим thumb. Либо не переключит, если функция
вызывалась из кода для режима ARM.

\subsubsection{\OptimizingKeil + \ARMMode}

\begin{lstlisting}
.text:00000098             f
.text:00000098 91 20 20 E0                 MLA     R0, R1, R0, R2
.text:0000009C 1E FF 2F E1                 BX      LR
\end{lstlisting}

А вот и функция \TT{f} скомпилированная компилятором Keil в режиме полной оптимизации (\Othree). Инструкция \MOV была
соптимизирована и теперь \TT{MLA} использует все входящие регистры и помещает результат в R0, как раз, где
вызываемая функция будет его читать и использовать.

\subsubsection{\OptimizingKeil + \ThumbMode}

\begin{lstlisting}
.text:0000005E             f
.text:0000005E 48 43                       MULS    R0, R1
.text:00000060 80 18                       ADDS    R0, R0, R2
.text:00000062 70 47                       BX      LR
\end{lstlisting}

В режиме thumb, инструкция \TT{MLA} недоступна, так что компилятору пришлось сгенерировать код, делающий
обе операции по отдельности. Первая инструкция \TT{MULS} умножает R0 на R1 оставляя результат в R0. 
Вторая (\TT{ADDS}) складывает результат и R2, оставляя результат в R0.

