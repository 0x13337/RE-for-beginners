\subsection{ARM}

\subsubsection{\OptimizingKeil + \ARMMode}

\lstinputlisting{07_jcc/ARM_O3_signed.asm}

\IFRU{Многие инструкции в режиме ARM могут быть исполнены только при некоторых выставленных флагах.}
{A lot of instructions in ARM mode can be executed only when specific flags are set.}
\IFRU{Это нередко используется для сравнения чисел, например.}
{This is often used while numbers comparing, for example.}

\IFRU{К примеру, инструкция \ADD на самом деле может быть представлена как \TT{ADDAL}, \TT{AL} означает 
\IT{Always}, то есть, исполнять всегда.}
{For instance, \ADD instruction is \TT{ADDAL} internally in fact, where \TT{AL} meaning
\IT{Always}, i.e., execute always.}
\IFRU{Предикаты кодируются в 4-х старших битах инструкции 32-битных ARM-инструкций}
{Predicates are encoded in 4 high bits of 32-bit ARM instructions} (\IT{condition field}).
\IFRU{Инструкция безусловного перехода \TT{B}, на самом деле условная и кодируется так же 
как и прочие инструкции условных переходов, но имеет \TT{AL} в \IT{condition field}, 
то есть, исполняется всегда, игнорируя флаги.}
{\TT{B} instruction of unconditional jump is in fact conditional and encoded just like any other
conditional jumps, but has \TT{AL} in \IT{condition field}, and what it means, executing always, ignoring flags.}

\IFRU{Инструкция \TT{ADRGT} работает так же как и \TT{ADR}, но исполнится только в случае 
если предыдущая инструкция \CMP,
сравнивая два числа, обнаружила что одно из них больше второго}
{\TT{ADRGT} instructions works just like \TT{ADR}, but will execute only in the case when previous \CMP
instruction, while comparing two numbers, found one number greater than another}
(\IT{Greater Than}).

\IFRU{Следующая инструкция \TT{BLGT} ведет себя так же как и \TT{BL} и сработает только если 
результат сравнения был такой же}{The next \TT{BLGT} instruction behaves exactly as \TT{BL} and will be
triggered only if result of comparison was the same} (\IT{Greater Than}). 
\TT{ADRGT} \IFRU{записывает в \Rzero указатель на строку}{writes a pointer to the string} 
\TT{``a>b\textbackslash{}n''}, 
\IFRU{а \TT{BLGT} вызывает}{into \Rzero and \TT{BLGT} calls} \printf.
\IFRU{Следовательно, эти инструкции с суффиксом \TT{-GT}, исполнятся только в том случае, если значение
в \Rzero (там $a$) было больше чем значение в \TT{R4} (там $b$).}
{Consequently, these instructions with \TT{-GT} suffix, will be executed only in the case when
value in \Rzero ($a$ is there) was bigger than value in \TT{R4} ($b$ is there).}

\IFRU{Далее мы увидим инструкции \TT{ADREQ} и \TT{BLEQ}.}
{Then we see \TT{ADREQ} and \TT{BLEQ} instructions.}
\IFRU{Они работают так же как и \TT{ADR} и \TT{BL}, но исполнятся только в случае если значения при сравнении были равны.}
{They behave just like \TT{ADR} and \TT{BL}, but will be executed only in the case when operands were equal to each
other while comparison.}
\IFRU{Перед ними еще один \CMP (ведь вызов \printf мог испортить состояние флагов).}
{Another \CMP is before them (because \printf call may tamper state of flags).}

\IFRU{Далее мы увидим \TT{LDMGEFD}, эта инструкция работает так же как и \TT{LDMFD}\footnote{\LDMFDDESC}, 
но сработает только в случае если в результате сравнения одно из значений было больше 
или равно второму}
{Then we see \TT{LDMGEFD}, this instruction works just like \TT{LDMFD}\footnote{\LDMFDDESC},
but will be triggered only in the case when one value was greater or equal to another while comparision}
(\IT{Greater or Equal}).

\IFRU{Смысл инструкции}{The sense of} \TT{``LDMGEFD SP!, \{R4-R6,PC\}''} 
\IFRU{в том, что это как бы эпилог функции, но он сработает только если $a>=b$, только тогда работа 
функции закончится.}
{instruction is that is like function epilogue, but it will be triggered only if $a>=b$, only then function 
execution will be finished.}
\IFRU{Но если это не так, то есть $a<b$, то исполнение дойдет до следующей инструкции 
\TT{``LDMFD SP!, \{R4-R6,LR\}''}, это еще один эпилог функции, эта инструкция восстанавливает состояние регистров
\TT{R4-R6}, но и \LR вместо \PC, таким образом, пока что не делая возврата из функции.}
{But if it's not true, i.e., $a<b$, then control flow come to next \TT{``LDMFD SP!, \{R4-R6,LR\}''} instruction,
this is one more function epilogue, this instruction restores \TT{R4-R6} registers state, 
but also \LR instead of \PC, thus, it doesn't returns from function.}
\IFRU{Последние две инструкции вызывают}{Last two instructions calls} \printf 
\IFRU{со строкой}{with the string} <<a<b\textbackslash{}n>> \IFRU{в качестве единственного аргумента}{as 
sole argument}.
\IFRU{Безусловный переход на \printf вместо возврата из функции, это то что мы уже рассматривали в 
секции}{Unconditional jump to \printf instead of function return, is what we already examined in} <<\PrintfSeveralArgumentsSectionName>>\IFRU{, здесь}{ section, here}~\ref{ARM_B_to_printf}.

\IFRU{Функция }{}\TT{f\_unsigned} \IFRU{точно такая же, но там используются инструкции}{is similar,
but } \TT{ADRHI}, \TT{BLHI}, \IFRU{и}{and} \TT{LDMCSFD} \IFRU{эти предикаты}{instructions are
used there, these predicates}
(\IT{HI = Unsigned higher, CS = Carry Set (greater than or equal)}) 
\IFRU{аналогичны рассмотренным, но служат для работы с беззнаковыми значениями.}
{are analogical to those examined before, but serving for unsigned values.}

\IFRU{В функции \main ничего для нас нового нет:}{There are not much new in \main for us:}

\lstinputlisting{07_jcc/ARM_O3_main.asm}

Так, в режиме ARM можно обойтись без условных переходов.

Почему это хорошо? Потому что ARM это RISC-процессор имеющий конвеер (pipeline) для исполнения инструкций. 
Если говорить 
коротко, то процессору с конвеером тяжело даются переходы вообще, поэтому есть спрос на возможность 
предсказывания переходов.
Очень хорошо если программа имеют как можно меньшее переходов, как условных, так и безусловных, поэтому, 
инструкции с добавленными предикатами, указывающими,
исполнять инструкцию или нет, могут избавить от некоторого количества условных переходов.

В x86 нет аналогичной возможности, если не считать инструкцию \TT{CMOVcc}, это то же что и \MOV, но она срабатывает
только при определенных выставленных флагах, обычно, выставленных при помощи \CMP.

\subsubsection{\OptimizingKeil + режим thumb}

\lstinputlisting{07_jcc/ARM_thumb_signed.asm}

В режиме thumb далеко не все инструкции могут быть дополнены условием исполнения (\IT{condition code}), 
так что, код для режима thumb выглядит привычнее.

\TT{BLE} это обычный переход с условием \IT{Less than or Equal}, \TT{BNE} ~--- \IT{Not Equal}, 
\TT{BGE} ~--- \IT{Greater than or Equal}.

Функция \TT{f\_unsigned} точно такая же, но для работы с беззнаковыми величинами, там используются 
инструкции \TT{BLS} (\IT{Unsigned lower or same}) и \TT{BCS} (\IT{Carry Set (Greater than ir equal)}).

