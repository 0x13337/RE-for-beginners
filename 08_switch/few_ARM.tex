%NOTTRANSLATED
\subsubsection{ARM: \OptimizingKeil + режим ARM}

\lstinputlisting{08_switch/few_ARM_ARM_O3.asm}

Мы снова не сможем сказать, глядя на этот код, был ли в оригинальном исходном коде switch() либо же несколько
if()-в.

Так или иначе, мы снова видим здесь инструкции с предикатами, например \TT{ADREQ} (\IT{(Equal)}), 
которая будет исполняться только
если $R0=0$, в таком случае, в R0 будет загружен адрес строки \IT{<<zero\textbackslash{}n>>}. 
Следующая инструкция \TT{BEQ} (\IT{(Branch Equal)}) перенаправит
исполнение на \TT{loc\_170}, если $R0=0$. 
Кстати, наблюдательный читатель может спросить, сработает ли \TT{BEQ} нормально,
ведь \TT{ADREQ} перед ним уже заполнила регистр \TT{R0} чем-то другим. 
Сработает, потому что \TT{BEQ} проверяет флаги установленные
инструкцией \CMP, а \TT{ADREQ} флаги никак не модифицирует.

Кстати, в ARM имеется также для некоторых инструкций суффикс \IT{-S}, указывающий, что флаги модифицировать не нужно.
Например, инструкция \TT{ADDS} сложит два числа, но флаги не изменит. Такие инструкции удобно использовать
между \CMP где выставляются флаги и, например, инструкциями перехода, где флаги используются.

Далее всё просто и знакомо. Вызов \printf один и в конце, мы уже рассматривали подобный трюк 
здесь~\ref{ARM_B_to_printf}. К \printf{}-у в конце ведут три пути. 

Обратите внимание на то что происходит
если $a=2$ и если $a$ не попадает под сравниваемые константы. Инструкция \TT{``CMP R0, \#2''} нужна чтобы узнать
$a=2$ или нет. Если это не так, то при помощи \TT{ADRNE} (\IT{Not Equal}) в \TT{R0} будет загружен указатель на 
строку \IT{<<something unknown \textbackslash{}n>>},
ведь $a$ уже было проверено на $0$ и $1$ до этого, и здесь $a$ точно не попадает под эти константы. 
Ну а если $R0=2$,
в R0 будет загружен указатель на строку \IT{<<two\textbackslash{}n>>} при помощи инструкции \TT{ADREQ}.

\subsubsection{ARM: \OptimizingKeil + режим thumb}

\lstinputlisting{08_switch/few_ARM_thumb_O3.asm}

Как я уже писал, в thumb-режиме нет возможности \IT{присоеденять} предикаты к большинству инструкций,
так что код вышел похожим на код x86, вполне понятный.

