%NOTTRANSLATED
\subsubsection{ARM: \OptimizingKeil + \ARMMode}

\lstinputlisting{08_switch/lot_ARM_ARM_O3.asm}

В этом коде используется та особенность режима ARM, что все инструкции в этом режиме имеют длину 4 байта.

Итак, не будем забывать, что максимальное значение для $a$ это $4$, всё что выше, должно вызвать
вывод строки \IT{<<something unknown\textbackslash{}n>>}.

Самая первая инструкция \TT{``CMP R0, \#5''} сравнивает входное значение в $a$ c $5$.

Следующая инструкция \TT{``ADDCC PC, PC, R0,LSL\#2''}\footnote{ADD --- складывание чисел}
сработает только в случае если $R0 < 5$
(\IT{CC=Carry clear / Less than}). Следвательно, если ADDCC не сработает (это случай с $R0 \geq 5$),
выполнится переход на метку \IT{default\_case}.

Но если $R0 < 5$ и \TT{ADDCC} сработает, то произойдет следующее:

Значение в \Rzero умножается на $4$.
Фактически, \TT{LSL\#2} в конце инструкции означает ``сдвиг влево на 2 бита''. Но как будет видно 
позже~\ref{division_by_shifting} в секции ``\ShiftsSectionName'', 
сдвиг влево на 2 бита это как раз эквивалентно его умножению на $4$.

Затем полученное $R0*4$ прибавляется к текущему значению \PC, совершая, таким образом, 
переход на одну из расположенных ниже инструкций B (Branch).

На момент исполнения \TT{ADDCC}, содержимое \PC на 8 байт больше ($0x180$) чем адрес по которому 
расположена сама
инструкция \TT{ADDCC} ($0x178$), либо, говоря иным языком, на 2 инструкции больше. 
Это связано с конвеером ARM,
пока исполняется инструкция \TT{ADDCC}, процессор уже начинает обрабатывать инструкцию после следующей, 
поэтому
\PC указывает туда.

В случае, если $a=0$, тогда к \PC ничего не будет прибавлено, в \PC запишется актуальный на тот момент \PC
(который больше на 8) и произойдет переход на метку \IT{loc\_180}, 
это на 8 байт дальше от места где находится инструкция \TT{ADDCC}. 

В случае, если $a=1$, тогда в \PC запишется $PC+8+a*4 = PC+8+1*4 = PC+16 = 0x184$, это адрес метки
\IT{loc\_184}.

При каждой добавленной к $a$ единице, итоговый \PC увеличивается на 4. 4 это как раз длина инструкции 
в режиме ARM и одновременно с этим, длина каждой инструкции \TT{B}, их здесь следует 5 в ряд.

Каждая из этих пяти инструкций \TT{B}, передает управление дальше, где собственно и происходит то, 
что запрограммировано в switch(). Там происходит загрузка указателя на свою строку, итд.

\subsubsection{ARM: \OptimizingKeil + \ThumbMode}

\lstinputlisting{08_switch/lot_ARM_thumb_O3.asm}

В режиме thumb-2, уже нельзя надеятся на то что все инструкции будут иметь одну длину. 
Можно даже сказать что в режиме thumb-2 инструкции переменной длины, как в x86.

Так что здесь добавляется специальная таблица, содержащая информацию о том, как много вариантов здесь,
не включая default-варианта, и смещения, для каждого варианта, каждое кодирует метку, куда перейти в 
каком случае.

Для того чтобы работать с таблицей и совершить переход, вызывается служебная функция \\
\IT{\_\_ARM\_common\_switch8\_thumb}. Она начинается с инструкции \TT{``BX PC''}, чья функция --- 
переключить процессор в ARM-режим. Далее функция работающая с таблицей. Она слишком сложная для 
рассмотрения в данном месте, так что я пропущу объяснения.
%TODO дописать когда-то

Но можно отметить, что эта функция использует
регистр \LR как указатель на таблицу. Действительно, после вызова этой функции, в \LR был записан
адрес после инструкции \\ 
\TT{``BL \_\_ARM\_common\_switch8\_thumb''}, а там как раз и начинается таблица.

Еще можно отметить что код для этого выделен в отдельную функцию для того, чтобы и в других местах,
в похожих случаях, обрабатывались switch()-и и не нужно было каждый раз генерировать во всех этих
местах такой фрагмент кода.

\IDA распознала эту служебную функцию и таблицу автоматически, 
дописав комментарии к меткам вроде "jumptable 000000FA case 0".
