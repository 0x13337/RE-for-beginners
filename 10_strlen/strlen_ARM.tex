\subsection{ARM}

\subsubsection{\NonOptimizingXcode + \ARMMode}

\lstinputlisting[caption=\NonOptimizingXcode + \ARMMode]{10_strlen/xcode_ARM_O0_en.asm}

\IFRU{Неоптимизирующий LLVM генерирует слишком много кода, зато на этом примере можно посмотреть, 
как функции работают с локальными переменными в стеке.}
{Non-optimizing LLVM generates too much code, however, here we can see how function works with local variables
in stack.}
\IFRU{В нашей функции только локальных переменных две, это два указателя}{There are only two
local variables in our function}, \IT{eos} \IFRU{и}{and} \IT{str}.

\IFRU{В этом листинге}{In this listing}, \IFRU{сгенерированном при помощи}{generated by} \IDA, 
\IFRU{я переименовал}{I renamed} \IT{var\_8} \IFRU{и}{and} \IT{var\_4} \IFRU{в}{into} \IT{eos} 
\IFRU{и}{and} \IT{str} \IFRU{вручную}{manually}.

\IFRU{Итак, первые несколько инструкций просто сохраняют входное значение в переменных}{So, 
first instructions are just saves input value in} \IT{str} \IFRU{и}{and} \IT{eos}.

\IFRU{Начиная с метки}{Loop body is beginning at} \IT{loc\_2CB8}\IFRU{, начинается тело цикла}{ label}.

\IFRU{Первые три инструкции в теле цикла}{First three instruction in loop body} (\TT{LDR}, \ADD, \TT{STR}) 
\IFRU{загружают значение}{loads} \IT{eos} \IFRU{в}{value into} \Rzero, 
\IFRU{затем происходит инкремент значения и оно сохраняется назад в локальной переменной \IT{eos} расположенной 
в стеке.}{then value is incremented and it's saving back into \IT{eos} local variable located in stack.}

\IFRU{Следующая инструкция}{The next} \TT{``LDRSB R0, [R0]''} (\IT{Load Register Signed Byte}) 
\IFRU{загружает байт из памяти по адресу \Rzero, расширяет его до 32-бит считая его знаковым (signed) 
и сохраняет в \Rzero}{instruction loading byte from memory at \Rzero address and sign-extends it to 32-bit}.
\IFRU{Это немного похоже на инструкцию}{This is similar to} \MOVSX \IFRU{в}{instruction in} x86.
\IFRU{Компилятор считает этот байт знаковым (signed), потому что тип \Tchar по стандарту Си ~--- знаковый.}
{The compiler treating this byte as signed because \Tchar type in C standard is signed.}
\IFRU{Об это я уже немного писал}{I already wrote about it}~\ref{MOVSX} \IFRU{в этой же секции, 
но посвященной x86}{in this section, but related to x86}.

\IFRU{Следует также заметить, что, в ARM нет возможности использовать 8-битную или 16-битную часть регистра, 
как это возможно в x86.}
{It's should be noted, there are to way to use 8-bit part or 16-bit part of 32-bit register in ARM, as it's
possible in x86.}
\IFRU{Вероятно, это связано с тем что за x86 тянется длинный шлейф совместимости со своими предками, такими как
16-битный 8086 и даже 8-битный 8080, а ARM разрабатывался с чистого листа как 32-битный RISC-процессор.}
{Apparently, it's because x86 has a huge history of compatibility with its ancestors like 16-bit 8086 
and even 8-bit 8080,
but ARM was developed from scratch as 32-bit RISC-processor.}
\IFRU{Следовательно, чтобы работать с отдельными байтами на ARM, так или иначе, придется использовать 
32-битные регистры.}
{Consequently, in order to process separate bytes in ARM, one have to use 32-bit registers anyway.}

\IFRU{Итак}{So}, \TT{LDRSB} \IFRU{загружает символ из строки в \Rzero, по одному.}{loads symbol from string
into \Rzero, one by one.}
\IFRU{Следующие инструкции}{Next} \CMP \IFRU{и}{and} \TT{BEQ} \IFRU{проверяют, является ли этот символ нулем.}
{instructions checks, if loaded symbol is zero.}
\IFRU{Если не ноль, то происходит переход на начало тела цикла.}{If not zero, control passing to loop body
begin.}
\IFRU{А если ноль, выходим из цикла.}{And if zero, loop is finishing.}

\IFRU{В конце функции вычисляется разница между}{At the end of function, a difference between} 
\IT{eos} \IFRU{и}{and} \IT{str}\IFRU{, вычитается еще единица и вычисленное 
значение возвращается через \Rzero.}{ is calculated, 1 is also subtracting, and resulting value is returned
via \Rzero.}

\IFRU{Кстати, обратите внимание, в этой функции не сохранялись регистры.}{By the way, please note, registers
wasn't saved in this function.}
\IFRU{Это потому что, по стандарту, регистры \Rzero-\Rthree называются также ``scratch registers'',
они предназначены для передачи аргументов, 
их значения не нужно восстанавливать при выходе из функции, потому что они больше не нужны в вызывающей функции.
Таким образом, их можно использовать как захочется}
{That's because by ARM calling convention, \Rzero-\Rthree registers are ``scratch registers'', 
they are intended for arguments passing,
its values may not be restored upon function exit, because calling function will not use them anymore.
Consequently, they may be used for anything we want.}
\IFRU{А так как никакие больше регистры не используются, то и сохранять нечего.}
{Other registers are not used here, so that's why we have nothing to save in stack.}
\IFRU{Поэтому, управление можно вернуть назад вызывающей функции 
простым переходом (\TT{BX}), по адресу в регистре \LR.}
{Thus, control may be returned back to calling function by simple jump (\TT{BX}), to address in \LR register.}

%\subsubsection{\NonOptimizingXcode + режим thumb}
%Практически, точно такой же код.

\subsubsection{\OptimizingXcode + \ThumbMode}

\lstinputlisting[caption=\OptimizingXcode + \ThumbMode]{10_strlen/xcode_thumb_O3.asm}

\IFRU{Оптимизирующий LLVM решил что под переменные \IT{eos} и \IT{str} выделять место в стеке не обязательно}
{As optimizing LLVM concludes, place in stack for \IT{eos} and \IT{str} may not be allocated},
\IFRU{и эти переменные можно хранить прямо в регистрах.}
{and these variables may always be stored right in registers.}
\IFRU{Перед началом тела цикла}{Before loop body beginning}, \IT{str} \IFRU{будет находиться в}{will always be in} 
\Rzero, \IFRU{а}{and} \IT{eos} ~--- \IFRU{в}{in} \Rone.

\IFRU{Инструкция }{}\TT{``LDRB.W R2, [R1],\#1''} \IFRU{загружает в \Rtwo байт из памяти по адресу \Rone, 
расширяя его как знаковый (signed), до 32-битного
значения, но не только это.}
{instruction loads byte from memory at the address \Rone into \Rtwo, sign-extending it to 32-bit value, but not
only that.}
\TT{\#1} \IFRU{в конце инструкции называется}{at the instruction's end calling} ``Post-indexed addressing'', 
\IFRU{это значит что после загрузки байта, к \Rone добавится единица.}{this mean, $1$ is to be added
to \Rone after byte load.}
\IFRU{Это очень удобно для работы с массивами.}{That's handy when accessing arrays.}

\IFRU{Такого режима адресации в x86 нет, но он есть в некоторых других процессорах, даже на PDP-11.}
{There are no such addressing mode in x86, but it's present in some other processors, even on PDP-11.}
\IFRU{Существует байка, что режимы пре-инкремента, пост-инкремента, 
пре-декремента и пост-декремента адреса в PDP-11}
{There is a legend that pre-increment, post-increment, pre-decrement and post-decrement modes in PDP-11},
\IFRU{были ``виновны'' в появлении таких конструктов языка Си (который разрабатывался на PDP-11) как}
{were ``guilty'' in appearance such C language (which developed on PDP-11) constructs as}
*ptr++, *++ptr, *ptr-{}-, *-{}-ptr. 
\IFRU{Кстати, это является труднозапоминаемой особенностью в Си.}
{By the way, this is one of hard to memorize C feature.}
\IFRU{Дела обстоят так:}{This is how it is:}

\begin{center}
\begin{tabular}{ | l | l | l | l | }
\hline                        
\cellcolor{blue!25} \IFRU{термин в Си}{C term} & 
\cellcolor{blue!25} \IFRU{термин в ARM}{ARM term} & 
\cellcolor{blue!25} \IFRU{выражение Си}{C statement} & 
\cellcolor{blue!25}\IFRU{как это работает}{how it works} \\
\hline                        
\IFRU{Пост-инкремент}{Post-increment} & 
post-indexed addressing & 
\TT{*ptr++} & 
\IFRU{использовать значение \TT{*ptr}}{use \TT{*ptr} value}, \\
& & & \IFRU{затем икремент указателя \TT{ptr}}{then increment \TT{ptr} pointer} \\
\hline                        
\IFRU{Пост-декремент}{Post-decrement} & 
post-indexed addressing & 
\TT{*ptr-{}-} & 
\IFRU{использовать значение \TT{*ptr}}{use \TT{*ptr} value}, \\
& & & \IFRU{затем декремент указателя \TT{ptr}}{then decrement \TT{ptr} pointer} \\
\hline                        
\IFRU{Пре-инкремент}{Pre-increment} & 
pre-indexed addressing & 
\TT{*++ptr} & 
\IFRU{инкремент указателя \TT{ptr}}{increment \TT{ptr} pointer}, \\
& & & \IFRU{затем использовать значение \TT{*ptr}}{then use \TT{*ptr} value} \\
\hline                        
\IFRU{Пре-декремент}{Pre-decrement} & 
post-indexed addressing & 
\TT{*-{}-ptr} & 
\IFRU{декремент указателя \TT{ptr}}{decrement \TT{ptr} pointer}, \\
& & & \IFRU{затем использовать значение \TT{*ptr}}{then use \TT{*ptr} value} \\
\hline  
\end{tabular}
\end{center}

\IFRU{Деннис Ритчи (один из создателей ЯП Си) указывал, что, это, вероятно, придумал Кен Томпсон 
(еще один создатель Си),
потому что подобная возможность процессора имелась еще в PDP-7}
{Dennis Ritchie (one of C language creators) mentioned that it's, probably, was invented by Ken Tompson
(another C creator) because this processor feature was present in PDP-7}
\cite{Ritchie:1986}\cite{Ritchie:1993:DCL:155360.155580}.
\IFRU{Таким образом, компиляторы с ЯП Си на тот процессор, где это есть, могут использовать это.}
{Thus, C language compilers may use it, if it's present in targer processor.}

Итак, далее в теле цикла \CMP и \TT{BNE} продолжают работу цикла, до тех пор, пока не будет встречен $0$.

После конца цикла \TT{MVNS}\footnote{MoVe Not} (инвертирование всех бит в значении, аналог \NOT на x86) 
и \ADD вычисляют $eos - str - 1$. 
На самом деле, эти две инструкции вычисляют $R0 = ~str + eos$, что эквивалентно тому, что было в исходном коде, 
а почему это так, я уже описывал чуть раньше, здесь~\ref{strlen_NOT_ADD}. 
Вероятно, LLVM, как и GCC, посчитал что так будет короче, или быстрее.

%\subsubsection{\OptimizingXcode + \ARMMode}
%Практически, точно такой же код.

\subsubsection{\OptimizingKeil{} + \ARMMode}

\lstinputlisting[caption=\OptimizingKeil + \ARMMode]{10_strlen/Keil_ARM_O3.asm}

Практически то же самое что мы уже видели, за тем исключением что выражение $str - eos - 1$ может быть вычислено
не в самом конце функции, а прямо в теле цикла. 
Суффикс \TT{-EQ}, как мы помним, означает что инструкция будет выполнена только
если операнды в исполненной перед этим инструкции \CMP были равны. 
Таким образом, если в \Rzero будет $0$, обе инструкции \TT{SUBEQ} исполнятся и результат останется в \Rzero.

