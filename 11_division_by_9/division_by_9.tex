\section{\DivisionByNineSectionName}
\label{sec:divisionbynine}

\IFRU{Простая функция:}{Very simple function:}

\begin{lstlisting}
int f(int a)
{
	return a/9;
};
\end{lstlisting}

\IFRU{Компилируется вполне предсказуемо:}{Is compiled in a very predictable way:}

\lstinputlisting{\IFRU{11_division_by_9/11_1_msvc_ru.asm}{11_division_by_9/11_1_msvc_en.asm}}

\IFRU{\IDIV делит 64-битное число хранящееся в паре регистров \TT{EDX:EAX} на значение в \ECX. 
В результате, \EAX будет содержать частное\footnote{результат деления}, а \EDX ~--- остаток от деления. 
Результат возвращается из функции через \EAX, так что после операции деления, 
это значение не перекладывается больше никуда, 
оно уже там где надо.}
{\IDIV divides 64-bit number stored in \TT{EDX:EAX} register pair by value in \ECX register. 
As a result, \EAX will contain quotient\footnote{result of division}, and \EDX ~--- remainder.
Result is returning from f() function in \EAX register, so, that value is not moved anymore after division 
operation, it is in right place already.}
\IFRU
{Из-за того что \IDIV требует пару регистров \TT{EDX:EAX}, то перед этим инструкция \TT{CDQ} 
расширяет \EAX до 64-битного значения учитывая знак, также как это делает \MOVSX.}
{Because \IDIV require value in \TT{EDX:EAX} register pair, \TT{CDQ} instruction (before \IDIV) extending 
\EAX value to 64-bit value taking value sign into account, just as \MOVSX does.}
\IFRU{Со включенной оптимизацией (\Ox) получается:}
{If we turn optimization on (\Ox), we got:}

\lstinputlisting{11_division_by_9/11_1_msvc_Ox.asm}

\newcommand{\URLMSDN}{\href{http://blogs.msdn.com/b/devdev/archive/2005/12/12/502980.aspx}
{MSDN: Integer division by constants}}
\newcommand{\URLN}{http://www.nynaeve.net/?p=115}

\IFRU{Это ~--- деление через умножение. Умножение конечно быстрее работает. 
Поэтому можно используя этот трюк
\footnote{Читайте подробнее о делении через умножение в книге 
``Генри Уоррен, мл. ~--- Алгоритмические трюки для программистов'' 
(глава 10 ~--- ``Целое деление на константы''): \URLMSDN, \url{\URLN}} 
создать код эквивалентный тому что мы хотим и работающий быстрее.}
{This is ~--- division using multiplication. Multiplication operation working much faster. 
And it is possible to use that trick
\footnote{Read more about division by multiplication in 
``Henry S. Warren Jr. ~--- Hacker's Delight'' book (chapter 10 ~--- ``Integer Division By Constants'') 
and: \URLMSDN, \url{\URLN}} 
to produce a code which is equivalent and faster.}
\IFRU
{GCC 4.4.1 даже без включенной оптимизации генерит примерно такой же код как и MSVC с оптимизацией:}
{GCC 4.4.1 even without optimization turned on, generate almost the same code as MSVC with optimization turned on:}

\lstinputlisting{11_division_by_9/11_2_gcc.asm}

\subsection{ARM}

\IFRU{В процессоре ARM, как и во многих других ``чистых'' (pure) RISC-процессорах нет инструкции деления,
да и инструкции умножения на 32-битную константу также нет.}{In ARM processor, just like in any other ''pure'' 
RISC-processors, there are no division instruction, instruction for multiplication by 32-bit constant 
is absent too.}
\IFRU{При некотором желании, можно обойтись только тремя действиями: сложением, вычитанием и 
битовыми сдвигами}{With some effort, it's possible to do division using only three instructions: addition,
subtraction and bit shifts}~\ref{sec:bitfields}.

\IFRU{Пример деления 32-битного числа на 10 из книги}{Here is an example of 32-bit number division by 10 from the} 
ARM Cookbook (1994)\footnote{\href{http://yurichev.com/ref/ARM\%20Cookbook\%20(1994)/cook3.txt}{ARM Cookbook (1994)}}. 
\IFRU{На выходе и частное и остаток}{Quotient and remainder on output}.

\begin{lstlisting}
; takes argument in a1
; returns quotient in a1, remainder in a2
; cycles could be saved if only divide or remainder is required
    SUB    a2, a1, #10             ; keep (x-10) for later
    SUB    a1, a1, a1, lsr #2
    ADD    a1, a1, a1, lsr #4
    ADD    a1, a1, a1, lsr #8
    ADD    a1, a1, a1, lsr #16
    MOV    a1, a1, lsr #3
    ADD    a3, a1, a1, asl #2
    SUBS   a2, a2, a3, asl #1      ; calc (x-10) - (x/10)*10
    ADDPL  a1, a1, #1              ; fix-up quotient
    ADDMI  a2, a2, #10             ; fix-up remainder
    MOV    pc, lr
\end{lstlisting}

\subsubsection{\OptimizingXcode + \ARMMode}

\begin{lstlisting}
__text:00002C58                         _f
__text:00002C58 39 1E 08 E3 E3 18 43 E3                 MOV             R1, 0x38E38E39
__text:00002C60 10 F1 50 E7                             SMMUL           R0, R0, R1
__text:00002C64 C0 10 A0 E1                             MOV             R1, R0,ASR#1
__text:00002C68 A0 0F 81 E0                             ADD             R0, R1, R0,LSR#31
__text:00002C6C 1E FF 2F E1                             BX              LR
\end{lstlisting}

Этот код почти тот же, что сгенерирован MSVC и GCC в режиме оптимизации. Должно быть, LLVM использует тот же
алгоритм для поиска констант.

Наблюдательный читатель может спросить, как \MOV записала в регистр сразу 32-битное число, ведь это невозможно.
Действительно невозможно, но как мы видим, здесь на инструкцию 8 байт вместо стандартных 4-х.
Первая инструкция загружает в младшие 16 бит регистра значение $0x8E39$, а вторая инструкция, 
на самом деле \TT{MOVT},
загружающая в старшие 16 бит регистра значение $0x383E$. \IDA распознала эту последовательность и для удобства
выдала только одну инструкцию.

Инструкция \TT{SMMUL} (\IT{Signed Most Significant Word Multiply}) умножает числа считая их знаковыми (signed)
и оставляет в R0 старшие 32 бита результата, не сохраняя младшие 32 бита.

Инструкция \TT{``MOV R1, R0,ASR\#1''} это арифметический сдвиг право на один бит.

\TT{``ADD R0, R1, R0,LSR\#31''} это $R0=R1 + R0>>31$

Дело в том что в режиме ARM нет отдельных инструкций для битовых сдвигов. 
Вместо этого, некоторые инструкции (\MOV, \ADD,
\SUB, \TT{RSB}) могут быть
дополнеты пометкой, сдвигать ли второй операнд и если да, то на сколько и как. 
\TT{ASR} означает \IT{Arithmetic Shift Right}, \TT{LSR} ~--- \IT{Logican Shift Right}.

\subsubsection{\OptimizingXcode + режим thumb}

\begin{lstlisting}
MOV             R1, 0x38E38E39
SMMUL.W         R0, R0, R1
ASRS            R1, R0, #1
ADD.W           R0, R1, R0,LSR#31
BX              LR
\end{lstlisting}

В режиме thumb отдельные инструкции для битовых сдвигов есть, и здесь применяется одна из них ~--- ASRS 
(арифметический сдвиг вправо).

\subsubsection{Неоптимизирующие Xcode (LLVM) и Keil}

Неоптимизирующий LLVM не занимается генерацией подобного кода а вместо этого просто вставляет вызов
библиотечной функции \IT{\_\_\_divsi3}. А Keil во всех случаях вставляет вызов функции \IT{\_\_aeabi\_idivmod}.

