\subsubsection{ARM + \OptimizingXcode + \ARMMode}

\begin{lstlisting}
VMOV            D16, R2, R3 ; b
VMOV            D17, R0, R1 ; a
VCMPE.F64       D17, D16
VMRS            APSR_nzcv, FPSCR
VMOVGT.F64      D16, D17 ; copy b to D16
VMOV            R0, R1, D16
BX              LR
\end{lstlisting}

Очень простой случай. Входные величины кладутся в \TT{D17} и \TT{D16} и сравниваются инструкцией 
\TT{VCMPE}.
Как и в процессорах x86, сопроцессор в ARM имеет свой собственный регистр статуса и флагов (\TT{FPSCR}),
потому что есть необходимость хранить специфичные для его работы флаги.

И так же как и в x86, в ARM нет инструкций условного перехода, 
проверяющих биты в регистре статуса сопроцессора, так что имеется инструкция \TT{VMRS}, копирующая 4 бита
(N, Z, C, V) из статуса сопроцессора в биты \IT{общего} статуса (\TT{APSR}).

\TT{VMOVGT} это аналог \TT{MOVGT}, инструкция, сработающая если при сравнении один операнд 
был больше чем второй
(\IT{Greater Than}). Если она сработает, в \TT{D16} запишется значение $b$, лежащее в тот момент 
в \TT{D17}.
А если не сработает, то в \TT{D16} останется лежать значение $a$.

Предпоследняя инструкция подготовит то что было в \TT{D16} для возврата через пару регистров \TT{R0} 
и \TT{R1}.

\subsubsection{ARM + \OptimizingXcode + \ThumbMode}

\begin{lstlisting}
VMOV            D16, R2, R3 ; b
VMOV            D17, R0, R1 ; a
VCMPE.F64       D17, D16
VMRS            APSR_nzcv, FPSCR
IT GT 
VMOVGT.F64      D16, D17
VMOV            R0, R1, D16
BX              LR
\end{lstlisting}

Почти то же самое что и в предыдущем примере, за парой отличий. Дело в том, многие инструкции в режиме ARM
можно дополнять условием, которое если справедливо, то инструкция выполнится.

Но в режиме thumb такого нет. В 16-битных инструкций просто нет места для лишних 4 битов, при помощи
которых можно было бы закодировать условие выполнения.

Поэтому в thumb-2 добавили возможность дополнять thumb-инструкции условиями.

Здесь, в листинге сгенерированном при помощи \IDA, мы видим инструкцию \TT{VMOVGT}, 
такую же как и в предыдущем
примере. Но в реальности, там закодирована обычная инструкция \TT{VMOV}, просто \IDA добавила 
суффикс \TT{-GT} к ней,
потому что перед этой инструкцией стоит \TT{``IT GT''}.

Инструкция \TT{IT} определяет так называемый \IT{if-then block}. После этой инструкции, можно указывать 
до четырех инструкций, к которым будет добавлен суффикс условия. В нашем примере, \TT{``IT GT''} означает,
что следующая за ней инструкция будет исполнена, если условие \IT{GT} (\IT{Greater Than}) справедливо.

Теперь более сложный пример, кстати, из Angry Birds (для iOS):

\begin{lstlisting}
ITE NE
VMOVNE          R2, R3, D16
VMOVEQ          R2, R3, D17
\end{lstlisting}

\TT{ITE} означает \IT{if-then-else} и кодирует суффиксы для двух следующих за ней инструкций. Первая из них
исполнится, если сработает условие закодированное в \TT{ITE} (\IT{NE, not equal}), а вторая ~--- 
если это условие не сработает. 
Обратное условие от \TT{NE} это \TT{EQ} (\IT{equal}).

Еще чуть сложнее, и снова этот фрагмент из Angry Birds:

\begin{lstlisting}
ITTTT EQ
MOVEQ           R0, R4
ADDEQ           SP, SP, #0x20
POPEQ.W         {R8,R10}
POPEQ           {R4-R7,PC}
\end{lstlisting}

4 символа ``T'' в инструкции означают что 4 следующие инструкции будут исполнены если условие соблюдается. 
Поэтому
\IDA добавила ко всем четырем инструкциям суффикс \TT{-EQ}. 

А если бы здесь было, например, \TT{ITEEE EQ} (\IT{if-then-else-else-else}), 
тогда суффиксы для следующих четырех инструкций были бы расставлены так:

\begin{lstlisting}
-EQ
-NE
-NE
-NE
\end{lstlisting}

Еще фрагмент из Angry Birds:

\begin{lstlisting}
CMP.W           R0, #0xFFFFFFFF
ITTE LE
SUBLE.W         R10, R0, #1
NEGLE           R0, R0
MOVGT           R10, R0
\end{lstlisting}

\TT{ITTE} (\IT{if-then-then-else}) означает что первая и вторая инструкции исполнятся, если 
условие \TT{LE} (\IT{Less or Equal}) справедливо,
а третья - если справедливо обратное условие (\TT{GT} ~--- \IT{Greater Than}).

Компиляторы способны генерировать далеко не все варианты, например, в вышеупомянутой игре Angry Birds
(версия \IT{classic} для iOS) попадаются только такие инструкции: \TT{IT}, \TT{ITE}, \TT{ITT}, \TT{ITTE}, 
\TT{ITTT}, \TT{ITTTT}.
Как я это узнал? В \IDA можно сгенерировать листинг, так я и сделал, только в опциях я установил так 
чтобы показывались 4 байта для каждого опкода. Затем, зная что старшая часть 16-битного опкода \TT{IT} 
это 0xBF, я сделал при помощи grep это:

\begin{lstlisting}
cat AngryBirdsClassic.lst | grep " BF" | grep "IT" > results.lst
\end{lstlisting}

Тем не менее, если писать на ассемблере для режима thumb-2 вручную, и дополнять инструкции суффиксами
условия, то ассемблер автоматически будет добавлять инструкцию \TT{IT} с соответствующими флагами, там
где надо.

\subsubsection{ARM + \NonOptimizingXcode + \ARMMode}

\begin{lstlisting}
b               = -0x20
a               = -0x18
val_to_return   = -0x10
saved_R7        = -4

                STR             R7, [SP,#saved_R7]!
                MOV             R7, SP
                SUB             SP, SP, #0x1C
                BIC             SP, SP, #7
                VMOV            D16, R2, R3
                VMOV            D17, R0, R1
                VSTR            D17, [SP,#0x20+a]
                VSTR            D16, [SP,#0x20+b]
                VLDR            D16, [SP,#0x20+a]
                VLDR            D17, [SP,#0x20+b]
                VCMPE.F64       D16, D17
                VMRS            APSR_nzcv, FPSCR
                BLE             loc_2E08
                VLDR            D16, [SP,#0x20+a]
                VSTR            D16, [SP,#0x20+val_to_return]
                B               loc_2E10

loc_2E08
                VLDR            D16, [SP,#0x20+b]
                VSTR            D16, [SP,#0x20+val_to_return]

loc_2E10
                VLDR            D16, [SP,#0x20+val_to_return]
                VMOV            R0, R1, D16
                MOV             SP, R7
                LDR             R7, [SP+0x20+b],#4
                BX              LR
\end{lstlisting}

Почти то же самое что мы уже видели, но много избыточного кода из-за хранения $a$ и $b$, а также 
выходного значения, в локальном стеке.

\subsubsection{ARM + \OptimizingKeil + \ThumbMode}

\begin{lstlisting}
                PUSH    {R3-R7,LR}
                MOVS    R4, R2
                MOVS    R5, R3
                MOVS    R6, R0
                MOVS    R7, R1
                BL      __aeabi_cdrcmple
                BCS     loc_1C0
                MOVS    R0, R6
                MOVS    R1, R7
                POP     {R3-R7,PC}

loc_1C0
                MOVS    R0, R4
                MOVS    R1, R5
                POP     {R3-R7,PC}
\end{lstlisting}

Keil не генерирует специальную инструкцию для сравнения чисел с плавающей запятой, потому что не 
расчитывает на то что она будет поддерживаться, а простым сравнением побитово, кстати, здесь не обойтись,
ведь равные числа с плавающей точкой могут быть по-разному закодированы в формате IEEE 754. 
Для сравнения вызывается библиотечная функция \TT{\_\_aeabi\_cdrcmple}. Обратите внимание, результат
сравнения эта функция оставляет в флагах, чтобы следующая за вызовом инструкция \TT{BCS} (\IT{Carry set - Greater than or equal}) могла сработать. Или не сработать.

 
