\subsubsection{ARM: \OptimizingXcode + \ARMMode}

Пока в ARM не было поддержки инструкций для работы с плавающей точкой, разные производители процессоров
могли добавлять свои расширения. Позже, был принят стандарт VFP (\IT{Vector Floating Point}).

Важное отличие от x86 в том, что там вы работаете с FPU-стеком, а здесь стека нет, 
здесь вы работаете просто с регистрами.

\lstinputlisting{12_FPU/simple_Xcode_ARM_O3.asm}

Итак, здесь мы видим использование новых регистров, с префиксом D. 
Это 64-битные регистры, их 32, и их можно
использовать и для чисел с плавающей точкой двойной точности (double) и для SIMD (в ARM это называется NEON).

Имеются также 32 32-битных S-регистра, они применяются для работы с числами с плавающей точкой одинарной точности
(float).

Обе константы ($3.14$ и $4.1$) хранятся в памяти в формате IEEE 754.

Инструкции \TT{VLDR} и \TT{VMOV}, как можно догадаться, это аналоги обычных \TT{LDR} и \MOV, 
но работают с новыми регистрами.
Важно отметить, что они предназначены не только для работы с числами с плавающей точкой, но пригодны также и для
работы с SIMD (NEON), это будет видно позже.

Аргументы передаются в функцию обычным путем, через R-регистры, однако, каждое число имеющее двойную точность
занимает 64 бита, так что для передачи каждого нужны два регистра. 
\TT{``VMOV D17, R0, R1''} в самом начале
составляет два 32-битных значения из \Rzero и \Rone в одно 64-битное и сохраняет в \TT{D17}. 
\TT{``VMOV R0, R1, D16''} в конце это обратная процедура, то что было в \TT{D16} 
остается в двух регистрах \Rzero и \Rone,
потому что, число с двойной точностью, занимающее 64 бита, возвращается в паре регистров \Rzero и \Rone.

\TT{VDIV}, \TT{VMUL} и \TT{VADD}, это, собственно, инструкции для работы с числами с плавающей точкой, 
вычисляющие, соответственно, частное\footnote{результат деления}, 
произведение\footnote{результат умножения} и сумму\footnote{результат сложения}.

Код для thumb-2 такой же.

\subsubsection{ARM: \OptimizingKeil + \ThumbMode}

\lstinputlisting{12_FPU/simple_Keil_O3_thumb.asm}

Keil компилировал для процессора, в котором может и не быть поддержки FPU или NEON. 
Так что числа с двойной точностью передаются в парах обычных R-регистров, 
а вместо FPU-инструкций вызываются сервисные
библиотечные функции \TT{\_\_aeabi\_dmul}, \TT{\_\_aeabi\_ddiv}, \TT{\_\_aeabi\_dadd}, эмулирующие 
умножение, деление и сложение чисел с плавающей точкой. 
Конечно, это медленнее чем вычислять на FPU-сопроцессоре, но лучше чем ничего.

Кстати, похожие библиотеки для эмуляции сопроцессорных инструкций были очень распространены в x86, 
когда сопроцессор стоял далеко не на всех компьютерах.

Кстати, эмуляция сопроцессора в ARM называется soft float или armel, а использование инструкций процессора ~--- 
hard float или armhf. Ядро Linux, например, для Raspberry Pi может поставляться в двух вариантах. В случае soft float,
аргументы будут передаваться через R-регистры, а в случае hard float, через D-регистры.
