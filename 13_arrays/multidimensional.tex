\subsection{\IFRU{Многомерные массивы}{Multidimensional arrays}}

\IFRU{Внутри, многомерный массив выглядит так же как и линейный.}
{Internally, multidimensional array is essentially the same thing as linear array.}

Вернее, можно сказать, он и есть линейный, ведь память компьютера линейная, это одномерный массив.
Но для удобства, этот одномерный массив легко представить как многомерный.

К примеру, элементы массива $a[3][4]$ будут так расположены в одномерном массиве из 12-и ячеек:

\begin{center}
\begin{tabular}{ | l | l | l | l | }
\hline                        
0 & 1 & 2 & 3 \\
\hline  
4 & 5 & 6 & 7 \\
\hline  
8 & 9 & 10 & 11 \\
\hline  
\end{tabular}
\end{center}

То есть, чтобы адресовать нужный элемент, в начале умножаем первый индекс на 4 (ширину матрицы), 
затем прибавляем второй индекс. Это называется \IT{row-major order}, и такой способ представления массивов
и матриц используется по крайней мере в \CCpp, Python. Термин \IT{row-major order} означает по-русски
примерно следующее: ``в начале записываем элементы первой строки, затем второй \dots и элементы последней 
строки в самом конце''.

Другой способ представления называется \IT{column-major order} (индексы массива используются в 
обратном порядке) и это
используется по крайней мере в FORTRAN, MATLAB, R. Термин \IT{column-major order} означает по-русски
следующее: ``в начале записываем элементы первого столбца, затем второго \dots и элементы последнего столбца
в самом конце''.

То же самое и для многомерных массивов.

\IFRU{Попробуем}{Let's see}:

\lstinputlisting{13_arrays/multi.c}

\subsubsection{x86}

\IFRU{В итоге}{We got} (MSVC 2010):

\lstinputlisting{13_arrays/multi_msvc.asm}

\IFRU{В принципе, ничего удивительного. В \TT{insert()} для вычисления адреса нужного элемента массива, 
три входных аргумента перемножаются по формуле $address=600 \cdot 4 \cdot x + 30 \cdot 4 \cdot y + 4z$, 
чтобы представить массив трехмерным.
Не забывайте также что тип \Tint 32-битный (4 байта), поэтому все коэффициенты нужно умножить на 4.}
{Nothing special. For index calculation, three input arguments are multiplying 
by formula $address=600 \cdot 4 \cdot x + 30 \cdot 4 \cdot y + 4z$ to represent array as multidimensional.
Do not forget that \Tint type is 32-bit (4 bytes), so all coefficients should be multiplied by 4.}

GCC 4.4.1:

\lstinputlisting{13_arrays/multi_gcc.asm}

Компилятор GCC решил всё сделать немного иначе. 
Для вычисления одной из операций ($30y$), GCC создал код, где нет самой операции умножения. 
Происходит это так: $(y+y) \ll 4 - (y+y) = (2y) \ll 4 - 2y = 2 \cdot 16 \cdot y - 2y = 32y - 2y = 30y$. 
Таким образом, для вычисления $30y$
используется только операция сложения, операция битового сдвига и операция вычитания. Это работает быстрее.

\subsubsection{ARM + \NonOptimizingXcode + режим thumb}

\lstinputlisting{13_arrays/multi_Xcode_thumb_O0_en.asm}

Неоптимизирующий LLVM сохраняет все переменные в локальном стеке, хотя это и не обязательно. 
Адрес элемента массива вычисляется по уже рассмотренной формуле.

\subsubsection{ARM + \OptimizingXcode + режим thumb}

\lstinputlisting{13_arrays/multi_Xcode_thumb_O3_en.asm}

Тут исползуются уже описанные трюки для замены умножения на операции сдвига, сложения и вычитания.

Также мы видим новую для себя инструкцию \TT{RSB} (\IT{Reverse Subtract}). 
Она работает так же как и \SUB, только меняет операнды
местами. Зачем? \SUB, \TT{RSB}, это те инструкции, к второму операнду которых можно применить коэффициент сдвига, как мы видим
и здесь (\TT{LSL\#4}). Но этот коэффициент можно применить только ко второму операнду. 
Для коммутативных операций, таких
как сложение или умножение, операнды можно менять местами и там всё хорошо. Но вычитание ~--- операция некоммутативная,
так что, для этих случаев существует инструкция \TT{RSB}.

Инструкция \TT{``LDR.W R9, [R9]''} работает как \LEA~\ref{sec:LEA} в x86, и здесь она ничего не делает, она избыточна. 
Вероятно, компилятор несоптимизировал её.

