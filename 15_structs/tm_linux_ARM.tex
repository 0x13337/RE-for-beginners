\subsection{struct tm}

\subsubsection{Linux}

\IFRU{В Линуксе, для примера, возьем структуру \TT{tm} из \TT{time.h}:}
{As of Linux, let's take \TT{tm} structure from \TT{time.h} for example:}

\lstinputlisting{15_structs/GCC_tm.c}

\IFRU{Компилируем при помощи}{Let's compile it in} GCC 4.4.1:

\IFRU{\lstinputlisting[caption=GCC 4.4.1]{15_structs/GCC_tm_ru.asm}}{\lstinputlisting{15_structs/GCC_tm_en.asm}}

\IFRU{К сожалению, по какой-то причине, \IDA не сформировала названия локальных переменных в стеке. 
Но так как мы уже опытные реверсеры :-) то можем обойтись и без этого в таком простом примере.}
{Somehow, \IDA didn't created local variables names in local stack.
But since we already experienced reverse engineers :-) we may do it without this information in 
this simple example.}

\index{x86!\Instructions!LEA}
\IFRU{Обратите внимание на \TT{lea edx, [eax+76Ch]} ~--- эта инструкция прибавляет \TT{0x76C} к \EAX, 
но не модифицирует флаги. См. также соответствующий раздел об инструкции \LEA{}~\ref{sec:LEA}.}
{Please also pay attention to \TT{lea edx, [eax+76Ch]} ~--- this instruction just adding \TT{0x76C} to \EAX,
but not modify any flags. See also relevant section about \LEA{}~\ref{sec:LEA}.}

\IFRU{Чтобы проиллюстрировать то что структура это просто набор переменных лежащих в одном месте, переделаем немного
пример, заглянув предварительно в файл}
{In order to illustrate that structure is just variables laying side-by-side in one place, let's rework
example, while looking at the file} \IT{time.h}:

\begin{lstlisting}[caption=time.h]
struct tm
{
  int	tm_sec;
  int	tm_min;
  int	tm_hour;
  int	tm_mday;
  int	tm_mon;
  int	tm_year;
  int	tm_wday;
  int	tm_yday;
  int	tm_isdst;
};
\end{lstlisting}

\lstinputlisting{15_structs/GCC_tm2.c}

\IFRU{Обратите внимание на то что в \TT{localtime\_r} передается указатель именно на \TT{tm\_sec}, 
т.е., на первый элемент ``структуры''.}
{Please note that pointer to exactly \TT{tm\_sec} is passed into \TT{localtime\_r}, i.e., 
to the first ``structure'' element.}

\IFRU{В итоге, и этот компилятор поворчит}{Compiler will warn us}:

\begin{lstlisting}[caption=GCC 4.7.3]
GCC_tm2.c: In function 'main':
GCC_tm2.c:11:5: warning: passing argument 2 of 'localtime_r' from incompatible pointer type [enabled by default]
In file included from GCC_tm2.c:2:0:
/usr/include/time.h:59:12: note: expected 'struct tm *' but argument is of type 'int *'
\end{lstlisting}

\IFRU{Тем не менее, сгенерирует такое}{But nevertheless, will generate this}:

\lstinputlisting[caption=GCC 4.7.3]{15_structs/GCC_tm2.asm}

\IFRU{Этот код почти идентичен уже рассмотренному, и нельзя сказать, была ли структура
в оригинальном исходном коде либо набор переменных.}{This code is identical to what we saw previously and it's
not possible to say, was it structure in original source code or just pack of variables.}

\IFRU{И это работает}{And this works}. 
\IFRU{Однако, в реальности так лучше не делать}{However, it's not recommended to do this in practice}. 
\IFRU{Обычно, компилятор располагает переменные в локальном
стеке в том же порядке, в котором они объявляются в функции}
{Usually, compiler allocate variables in local stack in the same order as they were declared in function}. 
\IFRU{Тем не менее, никакой гарантии нет}{Nevertheless, there are no any guarantee}.

\IFRU{Кстати, какой-нибудь другой компилятор может предупредить, что переменные}
{By the way, some other compiler may warn that} \TT{tm\_year}, \TT{tm\_mon}, \TT{tm\_mday},
\TT{tm\_hour}, \TT{tm\_min}\IFRU{, но не}{ variables, but not} \TT{tm\_sec}\IFRU{, используются без инициализации}
{ are used without being initialized}.
\IFRU{Действительно, ведь компилятор не знает что они будут заполнены при вызове функции}
{Indeed, compiler don't know that these will be filled when calling to} \TT{localtime\_r()}.

\IFRU{Я выбрал именно этот пример для иллюстрации, потому что все члены структуры имеют тип \Tint, а члены структуры
\TT{SYSTEMTIME} ~--- 16-битные \TT{WORD}, и если их объявлять так же, как локальные переменные, 
то они будут выровнены по 32-битной границе 
и ничего не выйдет (потому что \TT{GetSystemTime()} заполнит их неверно).}
{I chose exactly this example for illustration, because all structure fields has \Tint type, 
and \TT{SYSTEMTIME} structure
fields ~--- 16-bit \TT{WORD}, and if to declare them as a local variables, they will be aligned by 32-bit border,
and nothing will work (because \TT{GetSystemTime()} will fill them incorrectly).}
\IFRU{Читайте об этом в следующей секции}{Read more about it in next section}: ``\StructurePackingSectionName''.

\index{\SyntacticSugar}
\IFRU{Так что, структура это просто набор переменных лежащих в одном месте, рядом.}
{So, structure is just variables pack laying on one place, side-by-side.}
\IFRU{Я мог бы сказать что структура это такой синтаксический сахар, 
заставляющий компилятор удерживать их в одном месте.}{I could say that structure is a syntactic sugar, directing
compiler to hold them in one place.}
\IFRU{Впрочем, я не специалист по языкам программирования, так что, скорее всего, ошибаюсь с этим термином.}
{However, I'm not programming languages expert, so, most likely, I'm wrong with this term.}
\IFRU{Кстати, когда-то, в очень ранних версиях Си (перед 1972) структур не было вовсе}
{By the way, there were a times, in very early C versions (before 1972), 
in which there were no structures at all}\cite{Ritchie:1993:DCL:155360.155580}.

\subsubsection{ARM + \OptimizingKeil + \ThumbMode}

\IFRU{Этот же пример}{Same example}:

\lstinputlisting[caption=\OptimizingKeil + \ThumbMode]{15_structs/tm_ARM_keil_thumb.asm}

\subsubsection{ARM + \OptimizingXcode + \ThumbTwoMode}

\IDA ``\IFRU{узнала}{get to know}'' \IFRU{структуру }\TT{tm}\IFRU{}{ structure} 
(\IFRU{потому что}{because} \IDA ``\IFRU{знает}{knows}'' \IFRU{типы аргументов библиотечных функций, 
таких как}{argument types of library functions like} \TT{localtime\_r()}), 
\IFRU{поэтому показала здесь обращения к отдельным элементам структуры и присвоила им имена}
{so it shows here structure elements accesses and also names are assigned to them}.

\lstinputlisting[caption=\OptimizingXcode + \ThumbTwoMode]{15_structs/tm_ARM_xcode_thumb.asm}

