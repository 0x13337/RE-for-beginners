\subsection{\IFRU{Выделяем место для структуры через malloc()}
{Let's allocate space for structure using malloc()}}

\IFRU{Однако, бывает и так, что проще хранить структуры не в стеке а в куче\footnote{heap}:}
{However, sometimes it is simpler to place structures not in local stack, but in heap:}

\lstinputlisting{15_structs/systemtime_malloc.c}

\IFRU{Скомпилируем на этот раз с оптимизацией (\Ox) чтобы было проще увидеть то, что нам нужно.}
{Let's compile it now with optimization (\Ox) so to easily see what we need.}

\lstinputlisting[caption=\Optimizing MSVC]{15_structs/systemtime_malloc.asm}

\index{\CStandardLibrary!malloc()}
\IFRU{Итак, \TT{sizeof(SYSTEMTIME) = 16}, именно столько байт выделяется при помощи \TT{malloc()}. 
Она возвращает указатель на только что выделенный блок памяти в \EAX, который копируется в \ESI. 
Win32 функция \TT{GetSystemTime()} обязуется сохранить состояние \ESI, 
поэтому здесь оно нигде не сохраняется и продолжает использоваться после вызова \TT{GetSystemTime()}.}
{So, \TT{sizeof(SYSTEMTIME) = 16}, that is exact number of bytes to be allocated by \TT{malloc()}.
It returns the pointer to freshly allocated memory block in the \EAX register,
which is then moved into the \ESI register.
\TT{GetSystemTime()} win32 function undertake to save value in the \ESI,
and that is why it is not saved here and continue to be used after \TT{GetSystemTime()} call.}

\index{x86!\Instructions!MOVZX}
\IFRU{
Новая инструкция ~--- \MOVZX (\IT{Move with Zero eXtent}). 
Она нужна почти там же где и \MOVSX, 
только всегда очищает остальные биты в $0$. Дело в том что \printf требует 32-битный тип \Tint, 
а в структуре лежит WORD ~--- это 16-битный беззнаковый тип. Поэтому копируя значение из WORD в \Tint, 
нужно очистить биты от 16 до 31, иначе там будет просто случайный мусор, оставшийся от предыдущих действий 
с регистрами.}
{New instruction ~--- \MOVZX (\IT{Move with Zero eXtent}).
It may be used almost in those cases as \MOVSX, but, it clears other bits to $0$.
That's because \printf requires 32-bit \Tint, but we got WORD in structure ~--- 
that is 16-bit unsigned type.
That's why by copying value from WORD into \Tint{}, bits from 16 to 31 must also be cleared, 
because there will be random noise otherwise, leaved there from previous operations on registers.}

\IFRU{В этом примере я тоже могу представить структуру как массив WORD-ов}{In this example, I can represent
structure as array of WORD-s}:

\lstinputlisting{15_structs/systemtime_malloc2.c}

\IFRU{Получим такое}{We got}:

\lstinputlisting[caption=\Optimizing MSVC]{15_structs/systemtime_malloc2.asm}

\IFRU{И снова мы получаем идетичный код, неотличимый от предыдущего}
{Again, we got the code cannot be distinguished from the previous}.
\IFRU{Но и снова я должен отметить, что в реальности так лучше не делать}
{And again I should note, one should not do this in practice}.

