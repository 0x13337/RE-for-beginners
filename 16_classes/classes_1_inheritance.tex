\subsection{\IFRU{Наследование классов в C++}{Class inheritance in C++}}

\IFRU{О наследованных классах можно сказать что это та же простая структура которую мы уже рассмотрели, 
только расширяемая в наследуемых классах.}
{It can be said about inherited classes that it's simple structure we already considered, but extending 
in inherited classes.}

\IFRU{Возьмем очень простой пример}{Let's take simple example}:

\lstinputlisting{16_classes/classes1_inheritance.cpp}

\IFRU{Исследуя сгенерированный код для функций/методов \TT{dump()}, а также \TT{object::print\_color()},
посмотрим какая будет разметка памяти для структур-объектов (для 32-битного кода).}
{Let's investigate generated code of \TT{dump()} functions/methods and also \TT{object::print\_color()},
let's see memory layout for structures-objects (as of 32-bit code).}

\IFRU{Итак, методы \TT{dump()} разных классов сгенерированные MSVC 2008 с опциями \Ox и \Obzero}
{So, \TT{dump()} methods for several classes, generated by MSVC 2008 with \Ox and \Obzero options}
\footnote{\IFRU{опция \Obzero означает отмену inline expansion, 
ведь вставка компилятором тела функции/метода прямо в код где он вызывается только затруднит наши эксперименты}{
\Obzero options mean inline expansion disabling, because, function inlining right into the code where the function
is called will make our experiment harder}}

\lstinputlisting[caption=\Optimizing MSVC 2008 /Ob0]{16_classes/classes1_1.asm}

\lstinputlisting[caption=\Optimizing MSVC 2008 /Ob0]{16_classes/classes1_2.asm}

\lstinputlisting[caption=\Optimizing MSVC 2008 /Ob0]{16_classes/classes1_3.asm}

\IFRU{Итак, разметка полей получается следующая}{So, here is memory layout}:

\IFRU{(базовый класс \IT{object})}{(base class \IT{object})}

\begin{center}
\begin{tabular}{ | l | l | }
\hline
  \tableheader{} \\
  +0x0 & int color \\
\hline
\end{tabular}
\end{center}

\IFRU{(унаследованные классы)}{(inherited classes)}

\IT{box}:

\begin{center}
\begin{tabular}{ | l | l | }
\hline
  \tableheader{} \\
  +0x0 & int color \\
  +0x4 & int width \\
  +0x8 & int height \\
  +0xC & int depth \\
\hline
\end{tabular}
\end{center}

\IT{sphere}:

\begin{center}
\begin{tabular}{ | l | l | }
\hline
  \tableheader{} \\
  +0x0 & int color \\
  +0x4 & int radius \\
\hline
\end{tabular}
\end{center}

\IFRU{Посмотрим тело \main}{Let's see \main function body}:

\lstinputlisting[caption=\Optimizing MSVC 2008 /Ob0]{16_classes/classes1_4.asm}

\IFRU{Наследованные классы всегда должны добавлять свои поля после полей базового класса для того, чтобы методы
базового класса могли продолжать работать со своими полями.}
{Inherited classes should always add their fields after base classes' fields, so to make possible for base 
class methods to work with their fields.}

\IFRU{Когда метод \TT{object::print\_color()} вызывается, ему в качестве \TT{this} передается указатель и на объект типа \IT{box} 
и на объект типа \IT{sphere}, так как он может легко работать с классами \IT{box} и \IT{sphere}, потому что поле \IT{color} в этих
классах всегда стоит по тому же адресу (по смещению \IT{0x0}).}
{When \TT{object::print\_color()} method is called, a pointers to both \IT{box} object and \IT{sphere} object are passed as \TT{this},
it can work with these objects easily because \IT{color} field in these objects is always at the pinned address (at \IT{+0x0} offset).}

\IFRU{Можно также сказать что методу \TT{object::print\_color()} даже не нужно знать,
с каким классом он работает, до тех пор пока будет соблюдаться условие /IT{закрепления} полей по тем же адресам,
а это условие соблюдается всегда.}
{It can be said, \TT{object::print\_color()} method is agnostic in relation to input object type as long as fields will be \IT{pinned}
at the same addresses, and this condition is always true.}

\IFRU{А если вы создадите класс-наследник класса \IT{box}, например, 
то компилятор будет добавлять новые поля уже за полем \IT{depth}, оставляя уже имеющиеся поля класса \IT{box} по тем же адресам.}
{And if you create inherited class of \IT{box} class, for example, compiler will add new fields after \IT{depth} field,
leaving \IT{box} class fields at the pinned addresses.}

\IFRU{Так, метод \TT{box::dump()} будет нормально работать обращаясь к полям \IT{color}/\IT{width}/\IT{height}/\IT{depth} всегда находящимся по известным адресам.}
{Thus, \TT{box::dump()} method will work fine accessing \IT{color}/\IT{width}/\IT{height}/\IT{depths} fields always pinned on known addresses.}

\IFRU{Код на GCC практически точно такой же, за исключением способа передачи \TT{this} (он, как уже было указано, 
передается в первом аргументе, вместо регистра \ECX).}
{GCC-generated code is almost the same, with the sole exception of \TT{this} pointer passing (as it was described above,
it passing as first argument instead of \ECX registers.}

