\section{C99 restrict}

А вот причина из-за которой программы на FORTRAN, в некоторых случаях, работают быстрее чем на Си.

\begin{lstlisting}
void f1 (int* x, int* y, int* sum, int* product, int* sum_product, int* update_me, size_t s)
{
	for (int i=0; i<s; i++)
	{
		sum[i]=x[i]+y[i];
		product[i]=x[i]*y[i];
		update_me[i]=i*123; // some dummy value
		sum_product[i]=sum[i]+product[i];	
	};
};
\end{lstlisting}

Это очень простой пример, в котором есть одна особенность: указатель на массив \TT{update\_me} может быть указателем 
на массив
\TT{sum}, \TT{product}, или даже \TT{sum\_product} ~--- 
ведь нет ничего криминального в том чтобы аргументам функции быть такими.

Компилятор знает об этом, поэтому генерирует код, где в теле цикла будет 4 основных стадии:
\begin{itemize}
\item вычислить следующий \TT{sum[i]}
\item вычислить следующий \TT{product[i]}
\item вычислить следующий \TT{update\_me[i]}
\item вычислить следующий \TT{sum\_product[i]} ~--- на этой стадии придется снова загружать из 
      памяти подсчитанные \TT{sum[i]} и \TT{product[i]}
\end{itemize}

Возможно ли соптимизировать последнюю стадию? Ведь подсчитанные \TT{sum[i]} и \TT{product[i]} не обязательно 
снова загружать из памяти,
ведь мы их только что подсчитали. Можно, но компилятор не уверен, что на третьей стадии ничего не затерлось! Это называется
``pointer aliasing'', ситуация, когда компилятор не может быть уверен что память на которую указывает какой-то указатель, 
не изменилась.

\IT{restrict} в стандарте Си C99\cite[6.7.3.1]{C99TC3} это обещание, даваемое компилятору программистом, 
что аргументы функции отмеченные этим 
ключевым словом,
всегда будут указывать на разные места в памяти и пересекаться не будут.

Если быть более точным, и описывать это формально, \IT{restrict} показывает, что только данный указатель будет
использоваться для доступа к этому объекту, с которым мы работаем через этот указатель, больше никакой указатель для
этого использоваться не будет. Можно даже сказать, что к всякому объекту, доступ будет осуществляться только через
один единственный указатель, если он отмечен как \IT{restrict}.

Добавим это ключевое слово к каждому аргументу-указателю:

\begin{lstlisting}
void f2 (int* restrict x, int* restrict y, int* restrict sum, int* restrict product, int* restrict sum_product, 
	int* restrict update_me, size_t s)
{
	for (int i=0; i<s; i++)
	{
		sum[i]=x[i]+y[i];
		product[i]=x[i]*y[i];
		update_me[i]=i*123; // some dummy value
		sum_product[i]=sum[i]+product[i];	
	};
};
\end{lstlisting}

Посмотрим результат:

\lstinputlisting[caption=GCC x64: f1()]{21_C99_restrict/f1.asm}

\lstinputlisting[caption=GCC x64: f2()]{21_C99_restrict/f2.asm}

Разница между скомпилированной функцией \TT{f1()} и \TT{f2()} такая: 
в \TT{f1()} \TT{sum[i]} и \TT{product[i]} загружаются снова посреди тела цикла,
а в \TT{f2()} этого нет, используются уже подсчитанные значения, ведь мы ``пообещали'' компилятору, 
что никто и ничто не изменит
значения в \TT{sum[i]} и \TT{product[i]} во время исполнения тела цикла, поэтому он ``уверен'', что так можно делать. 
Очевидно, второй вариант будет работать быстрее.

Но что будет если указатели в аргументах функций все же будут пересекаться? Это останется на совести программиста, 
а результаты вычислений будут неверными.

Вернемся к FORTRAN. Компиляторы с этого ЯП, по умолчанию, все указатели считают таковыми, поэтому, когда в Си не было
возможности указать \IT{restrict}, FORTRAN в этих случаях мог генерировать более быстрый код.

Насколько это практично? Там где функция работает с несколькими большими блоками в памяти. 
Такого очень много в линейной алгебре, например. Очень много линейной алгебры используется на суперкомпьютерах/HPC,
возможно, поэтому, традиционно, там часто используется FORTRAN, до сих пор\cite{Loh:2010:IHP:1810226.1820518}.

Ну а когда итераций цикла не очень много, конечно, тогда прирост скорости не будет ощутимым.

