\subsubsection{ARM: \OptimizingXcode + режим ARM}

Пока в ARM не было поддержки инструкций для работы с плавающей точкой, разные производители процессоров
могли добавлять свои расширения. Позже, был принят стандарт VFP (\IT{Vector Floating Point}).

Важное отличие от x86 в том, что там вы работаете с FPU-стеком, а здесь стека нет, 
здесь вы работаете просто с регистрами.

\lstinputlisting{FPU/simple_Xcode_ARM_O3.asm}

Итак, здесь мы видим использование новых регистров, с префиксом D. 
Это 64-битные регистры, их 32, и их можно
использовать и для чисел с плавающей точкой двойной точности (double) и для SIMD (в ARM это называется NEON).

Имеются также 32 32-битных S-регистра, они применяются для работы с числами с плавающей точкой одинарной точности
(float).

Обе константы ($3.14$ и $4.1$) хранятся в памяти в формате IEEE 754.

Инструкции \TT{VLDR} и \TT{VMOV}, как можно догадаться, это аналоги обычных \TT{LDR} и \MOV, 
но работают с новыми регистрами.
Важно отметить, что они предназначены не только для работы с числами с плавающей точкой, но пригодны также и для
работы с SIMD (NEON), это будет видно позже.

Аргументы передаются в функцию обычным путем, через R-регистры, однако, каждое число имеющее двойную точность
занимает 64 бита, так что для передачи каждого нужны два регистра. 
\TT{``VMOV D17, R0, R1''} в самом начале
составляет два 32-битных значения из \TT{R0} и \TT{R1} в одно 64-битное и сохраняет в \TT{D17}. 
\TT{``VMOV R0, R1, D16''} в конце это обратная процедура, то что было в \TT{D16} 
остается в двух регистрах \TT{R0} и \TT{R1},
потому что, число с двойной точностью, занимающее 64 бита, возвращается в паре регистров \TT{R0} и \TT{R1}.

\TT{VDIV}, \TT{VMUL} и \TT{VADD}, это, собственно, инструкции для работы с числами с плавающей точкой, 
вычисляющие, соответственно, частное\footnote{результат деления}, 
произведение\footnote{результат умножения} и сумму\footnote{результат сложения}.

Код для thumb-2 такой же.

\subsubsection{ARM: \OptimizingKeil + режим thumb}

\lstinputlisting{FPU/simple_Keil_O3_thumb.asm}

Keil компилировал для процессора, в котором может и не быть поддержки FPU или NEON. 
Так что числа с двойной точностью передаются в парах обычных R-регистров, 
а вместо FPU-инструкций вызываются сервисные
библиотечные функции \TT{\_\_aeabi\_dmul}, \TT{\_\_aeabi\_ddiv}, \TT{\_\_aeabi\_dadd}, эмулирующие 
умножение, деление и сложение чисел с плавающей точкой. 
Конечно, это медленнее чем вычислять на FPU-сопроцессоре, но лучше чем ничего.

Кстати, похожие библиотеки для эмуляции сопроцессорных инструкций были очень распространены в x86, 
когда сопроцессор стоял далеко не на всех компьютерах.

