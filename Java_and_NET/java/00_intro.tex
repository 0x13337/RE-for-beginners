% TODO translation
% TODO proof-reading
\section{Introduction}

There are some well-known decompilers for Java (or \ac{JVM} bytecode in general).

The reason of this is because Java decompiling is somewhat easier 
than for lower level x86 code:

\begin{itemize}
\item There are much more information about data types.
\item \ac{JVM} memory model is much more rigorous and outlined.
\item Java compiler don't do any optimization job (\ac{JVM} \ac{JIT} does at runtime),
  so bytecode in class files is usually pretty readable.
\end{itemize}

When JVM bytecode may be useful?

\begin{itemize}
\item Quick-and-dirty patching tasks without need to recompile decompiler's results.
\item Analysing obfuscated code.
\item Build your own obfuscator.
\item Build compiler back-end targetting JVM.
\end{itemize}

Let's start with simple pieces of code.
JDK 1.7 is used everywhere.

This command to decompile .class file was used everywhere: \TT{javap -c -verbose}

This book was used by me while preparing all examples: \cite{JavaSE7}.
