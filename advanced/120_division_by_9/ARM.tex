\section{ARM}

\RU{В процессоре ARM, как и во многих других ``чистых'' (pure) RISC-процессорах нет инструкции деления.
Нет также возможности умножения на 32-битную константу одной инструкцией (вспомните что 32-битная
константа просто не поместится в 32-битных опкод).}
\EN{ARM processor, just like in any other ''pure'' RISC-processors, lacks division instruction.
It also lacks a single instruction for multiplication by 32-bit constant (recall that 32-bit
constant cannot fit into 32-bit opcode).}
\RU{При помощи этого любопытного трюка (или \IT{хака})\footnote{hack}, можно обойтись только тремя действиями: 
сложением, вычитанием и битовыми сдвигами}
\EN{By taking advantage of this clever trick (or \IT{hack}), it is possible to do division using only three instructions: addition,
subtraction and bit shifts}~(\ref{sec:bitfields}).

\RU{Пример деления 32-битного числа на 10 из}\EN{Here is an example of 32-bit number division by 10 from}
\cite[3.3 Division by a Constant]{ARM:1994}.
\RU{На выходе и частное и остаток}\EN{Quotient and remainder on output}.

\begin{lstlisting}
; takes argument in a1
; returns quotient in a1, remainder in a2
; cycles could be saved if only divide or remainder is required
    SUB    a2, a1, #10             ; keep (x-10) for later
    SUB    a1, a1, a1, lsr #2
    ADD    a1, a1, a1, lsr #4
    ADD    a1, a1, a1, lsr #8
    ADD    a1, a1, a1, lsr #16
    MOV    a1, a1, lsr #3
    ADD    a3, a1, a1, asl #2
    SUBS   a2, a2, a3, asl #1      ; calc (x-10) - (x/10)*10
    ADDPL  a1, a1, #1              ; fix-up quotient
    ADDMI  a2, a2, #10             ; fix-up remainder
    MOV    pc, lr
\end{lstlisting}

\subsection{\OptimizingXcodeIV (\ARMMode)}

\begin{lstlisting}
__text:00002C58 39 1E 08 E3 E3 18 43 E3  MOV    R1, 0x38E38E39
__text:00002C60 10 F1 50 E7              SMMUL  R0, R0, R1
__text:00002C64 C0 10 A0 E1              MOV    R1, R0,ASR#1
__text:00002C68 A0 0F 81 E0              ADD    R0, R1, R0,LSR#31
__text:00002C6C 1E FF 2F E1              BX     LR
\end{lstlisting}

\RU{Этот код почти тот же, что сгенерирован MSVC и GCC в режиме оптимизации.}
\EN{This code is mostly the same to what was generated by optimizing MSVC and GCC.}
\RU{Должно быть, LLVM использует тот же алгоритм для поиска констант.}
\EN{Apparently, LLVM use the same algorithm for constants generating.}

\index{ARM!\Instructions!MOV}
\index{ARM!\Instructions!MOVT}
\RU{Наблюдательный читатель может спросить, как \MOV записала в регистр сразу 32-битное число, 
ведь это невозможно в режиме ARM.}
\EN{Observant reader may ask, how \MOV writes 32-bit value in register, while this is not possible in ARM mode.}
\RU{Действительно невозможно, но как мы видим, здесь на инструкцию 8 байт вместо стандартных 4-х,
на самом деле, здесь 2 инструкции.}
\EN{it is impossible indeed, but, as we see,
there are 8 bytes per instruction instead of standard 4,
in fact, there are two instructions.}
\RU{Первая инструкция загружает в младшие 16 бит регистра значение \TT{0x8E39}, а вторая инструкция, 
на самом деле \TT{MOVT}, загружающая в старшие 16 бит регистра значение \TT{0x383E}.}
\EN{First instruction loading \TT{0x8E39} value into low 16 bit of register and second instruction is in fact
\TT{MOVT}, it loading \TT{0x383E} into high 16-bit of register.}
\IDA \RU{легко распознала эту последовательность и для краткости, сократила всё это до одной ``псевдо-инструкции''.}
\EN{is fully aware of such sequences, and for the sake of compactness, reduced it to one single ``pseudo-instruction''.}

\index{ARM!\Instructions!SMMUL}
\RU{Инструкция }\TT{SMMUL} (\IT{Signed Most Significant Word Multiply}) 
\RU{умножает числа считая их знаковыми (signed) и оставляет в \Reg{0} старшие 32 бита результата, 
не сохраняя младшие 32 бита.}
\EN{instruction multiply numbers treating them as signed numbers,
and leaving high 32-bit part of result in the \Reg{0} register,
dropping low 32-bit part of result.}

\index{ARM!Optional operators!ASR}
\RU{Инструкция }\TT{``MOV R1, R0,ASR\#1''} \RU{это арифметический сдвиг право на один бит.}
\EN{instruction is arithmetic shift right by one bit.}

\index{ARM!\Instructions!ADD}
\index{ARM!Data processing instructions}
\index{ARM!Optional operators!LSR}
\TT{``ADD R0, R1, R0,LSR\#31''} \RU{это}\EN{is} $R0=R1 + R0>>31$

% FIXME какие именно инструкции? \ref{} ->
\label{shifts_in_ARM_mode}
\RU{Дело в том, что в режиме ARM нет отдельных инструкций для битовых сдвигов.}
\EN{As a matter of fact, there is no separate shifting instruction in ARM mode.}
\RU{Вместо этого, некоторые инструкции}\EN{Instead, an instructions like} 
(\MOV, \ADD, \SUB, \TT{RSB})\footnote{\DataProcessingInstructionsFootNote}
\RU{могут быть дополнены суффиксом, сдвигать ли второй операнд и если да, то на сколько и как.}
\EN{may be supplied by suffix, is the second operand must be shifted, if yes, by what value and how.}
\TT{ASR} \RU{означает}\EN{meaning} \IT{Arithmetic Shift Right}, \TT{LSR}\EMDASH\IT{Logical Shift Right}.

\subsection{\OptimizingXcodeIV (\ThumbTwoMode)}

\begin{lstlisting}
MOV             R1, 0x38E38E39
SMMUL.W         R0, R0, R1
ASRS            R1, R0, #1
ADD.W           R0, R1, R0,LSR#31
BX              LR
\end{lstlisting}

\index{ARM!\Instructions!ASRS}
\RU{В режиме thumb отдельные инструкции для битовых сдвигов есть}
\EN{There are separate instructions for shifting in thumb mode}, \RU{и здесь применяется одна из них}
\EN{and one of them is used here}\EMDASH\TT{ASRS} (\RU{арифметический сдвиг вправо}\EN{arithmetic shift right}).

\subsection{\NonOptimizing Xcode 4.6.3 (LLVM) \AndENRU Keil 6/2013}

\NonOptimizing LLVM 
\RU{не занимается генерацией подобного кода, а вместо этого просто вставляет вызов
библиотечной функции \IT{\_\_\_divsi3}}
\EN{does not generate code we saw before in this section, but inserts a call to library function 
\IT{\_\_\_divsi3} instead}.

\RU{А Keil во всех случаях вставляет вызов функции}
\EN{What about Keil: it inserts call to library function} \IT{\_\_aeabi\_idivmod}\EN{ in all cases}.
