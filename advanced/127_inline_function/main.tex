\chapter{\RU{Inline-функции}\EN{Inline functions}}
\index{Inline code}
\label{inline_code}

\RU{Inline-код это когда компилятор, вместо того чтобы генерировать инструкцию вызова небольшой функции,
просто вставляет её тело прямо в это место.}
\EN{Inlined code is when the compiler, instead of placing a call instruction to a small or tiny function,
just places its body right in-place.}

\lstinputlisting[caption=\RU{Простой пример}\EN{A simple example}]{\CURPATH/1.c}

\dots 
\RU{это компилируется вполне предсказуемо, хотя, если включить оптимизации GCC (\Othree), мы увидим:}
\EN{is compiled in very predictable way, however, if we turn on GCC optimizations (\Othree), we'll see:}

\lstinputlisting[caption=\Optimizing GCC 4.8.1]{\CURPATH/1.s}

(\RU{Здесь деление заменено умножением}\EN{Here the division is done by multiplication}(\ref{sec:divisionbynine}).)

\RU{Да, наша маленькая ф-ция \TT{celsius\_to\_fahrenheit()} была помещена прямо перед вызовом \printf.}
\EN{Yes, our small function \TT{celsius\_to\_fahrenheit()} was just placed before the \printf call.}
\RU{Почему? Это может быть быстрее чем исполнять код самой ф-ции плюс затраты на вызов и возврат.}
\EN{Why? It can be faster than executing this function's code plus the overhead of calling/returning.}

\RU{В прошлом, такие ф-ции нужно было маркировать ключевым словом ``inline'' в определении ф-ции, хотя,
в наше время, такие ф-ции выбираются компилятором автоматически.}
\EN{In the past, such functions had to be marked with the ``inline'' keyword in the declaration, however,
in modern times these functions are automatically chosen by the compiler.}
% it's still possible to mark functions as inline in modern compilers,
% from the text it looks like that it's not possible any more.

% sections
\input{\CURPATH/str_mem/main}
