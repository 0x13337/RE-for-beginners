\chapter{Отрицательные индексы массивов}
\label{negative_array_indices}

Возможно
адресовать место в памяти \IT{перед} массивом задавая отрицательный индекс, например, $array[-1]$.

\myindex{FORTRAN}
Трудно сказать, зачем это вообще может понадобиться, известно только одно практическое
применение этому.
% TODO: разобраться:
% another use (which seems to be used more often) can be found in "Transaction processing" by Jim Gray, p. 755
% basically, it's used in structures that describe pages, and the entries are indexed from the beginning,
% and the directory entries - from the end with negative indices.

Элементы массивов в \CCpp индексируются, начиная с 0, но в некоторых \ac{PL}, первый элемент 
индексируется через 1 (как минимум FORTRAN).
Привычка у программистов может остаться, так что все еще возможно адресовать
первый элемент через 1 в \CCpp используя этот трюк:

\lstinputlisting{\CURPATH/neg_array.c}

\lstinputlisting[caption=\NonOptimizing MSVC 2010,label=neg_array_c,numbers=left]{\CURPATH/neg_array_RU.asm}

Так что у нас тут массив \TT{array[]} из десяти элементов, заполненный байтами $0 \ldots 9$.

Затем у нас указатель \TT{fakearray[]} указывающий на один байт перед \TT{array[]}.
\TT{fakearray[1]} указывает точно на \TT{array[0]}.
Но нам все еще любопытно, что же находится перед \TT{array[]}?
Мы добавляем \TT{random\_value} перед \TT{array[]} и установим её в \TT{0x11223344}.
Неоптимизирующий компилятор выделяет переменные в том же порядке, в котором они 
объявлены, так что да, 32-битная \TT{random\_value} находится точно перед массивом.

Запускаем, и:

\begin{lstlisting}
first element 0
second element 1
last element 9
array[-1]=11, array[-2]=22, array[-3]=33, array[-4]=44
\end{lstlisting}

Фрагмент стека, который мы скопипастим из окна стека в \olly (включая комментарии автора):

\lstinputlisting[caption=\NonOptimizing MSVC 2010]{\CURPATH/stack_RU.txt}

Указатель на \TT{fakearray[]} (\TT{0x001DFBD3}) это действительно адрес \TT{array[]} в стеке (\TT{0x001DFBD4}), 
но минус 1 байт.

Трюк этот все-таки слишком хакерский и сомнительный. Вряд ли кто-то будет его использовать в своем коде,
но для демонстрации, он здесь очень уместен.

