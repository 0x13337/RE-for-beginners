\ifx\RUSSIAN\undefined
\chapter{MIPS}

\section{Registers}
\label{MIPS_registers_ref}

\index{MIPS!O32}
( O32 Calling Convention )

\subsection{General purpose registers}

\begin{center}
\begin{tabular}{ | l | l | l | }
\hline
\cellcolor{blue!25} Name & \cellcolor{blue!25} Pseudoname & \cellcolor{blue!25} Description \\
\hline
\$0             & \$ZERO          & Always zero. Writing to this register is effectively idle instruction (\ac{NOP}). \\
\hline
\$1             & \$AT            & Used as a temporary register for assembly macros. \\
\hline
\$2 \dots \$3   & \$V0 \dots \$V1 & Function result returned here. \\
\hline
\$4 \dots \$7   & \$A0 \dots \$A3 & Function arguments. \\
\hline
\$8 \dots \$15  & \$T0 \dots \$T7 & Used for temporary data. \\
\hline
\$16 \dots \$23 & \$S0 \dots \$S7 & Used for temporary data\AsteriskOne{}. \\
\hline
\$24 \dots \$25 & \$T8 \dots \$T9 & Used for temporary data. \\
\hline
\$26 \dots \$27 & \$K0 \dots \$K1 & reserved for OS kernel. \\
\hline
\$28            & \$GP            & Global Pointer\AsteriskTwo{}. \\
\hline
\$29            & \$SP            & Stack Pointer\AsteriskOne{}. \\
\hline
\$30            & \$FP            & Frame Pointer\AsteriskOne{}. \\
\hline
\$31            & \$RA            & Return Address. \\
\hline
n/a             & PC              & \ac{PC}. \\
\hline
n/a             & HI              & high 32 bit of multiplication and division result\AsteriskThree{}. \\
\hline
n/a             & LO              & low 32 bit of multiplication and division result\AsteriskThree{}. \\
\hline
\end{tabular}
\end{center}

\subsection{Floating-point registers}
\label{MIPS_FPU_registers}

\begin{center}
\begin{tabular}{ | l | l | l | }
\hline
\cellcolor{blue!25} Name & \cellcolor{blue!25} Description \\
\hline
\$F0..\$F1   & Function result returned here. \\
\hline
\$F2..\$F3   & Not used. \\
\hline
\$F4..\$F11  & Used for temporary data. \\
\hline
\$F12..\$F15 & First two function arguments. \\
\hline
\$F16..\$F19 & Used for temporary data. \\
\hline
\$F20..\$F31 & Used for temporary data\AsteriskOne{}. \\
\hline
%fcr31 & Control/status register. \\
%\hline
\end{tabular}
\end{center}

\AsteriskOne{} --- \Gls{callee} must preserve.\\
\AsteriskTwo{} --- \Gls{callee} must preserve (except \ac{PIC} code).\\
\index{MIPS!\Instructions!MFLO}
\index{MIPS!\Instructions!MFHI}
\AsteriskThree{} --- accessible using \TT{MFHI} and \TT{MFLO} instructions.\\

\section{Instructions}

There are 3 kinds of instructions:

\begin{itemize}

\item R-type: those which has 3 registers.
R-instruction are often has the following form:

\begin{lstlisting}
instruction destination, source1, source2
\end{lstlisting}

One important thing to remember is that when first and second register is the same, 
IDA may show it in shorter form:

\begin{lstlisting}
instruction destination/source1, source2
\end{lstlisting}

That somewhat reminds us Intel-syntax of x86 assembly language.

\item I-type: those which has 2 registers and 16-bit immediate value.
\item J-type: jump/branch instructions, has 26 bits for offset encoding.

\end{itemize}

\subsection{Jump instructions}

What is the difference between B- instructions and J- ones?

B-instructions are I-type, hence, B-instructions offset is encoded as 16-bit immediate.
JR and JALR are R-type, which jumps to absolute address specified in register.
J and JAL are J-type, hence, offset is encoded as 26-bit immediate.

In short, B-instructions can encode condition (B is in fact pseudoinstruction for BEQ), 
while J-instructions can't.

\fi
