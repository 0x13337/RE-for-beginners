\subsubsection{ARM + \NonOptimizingKeil + режим ARM}

\lstinputlisting{arrays/simple_Keil_ARM_O0_en.asm}

Тип \Tint требует 32 бита для хранения, или 4 байта, так что для хранения 20 переменных, нужно 80 (0x50) байт,
поэтому инструкция \TT{``SUB SP, SP, \#0x50''} в эпилоге функции выделяет в локальном стеке место под массив.

И в первом и во втором цикле, итератор цикла $i$ будет постоянно находится в регистре R4.

Число, которое нужно записать в массив, вычисляется так $i*2$, но это эквивалентно сдвигу на 1 бит влево, 
инструкция \TT{``MOV R0, R4,LSL\#1''} делает это.

\TT{``STR R0, [SP,R4,LSL\#2]''} записывает R0 в массив. Указатель на элемент массива вычисляется так: \SP указывает
на начало массива, R4 это $i$. Так что сдвигаем $i$ на 2 бита влево, что эквивалентно умножению на 4 (ведь каждый
элемент массива занимает 4 байта) и прибавляем к адресу начала массива.

Во втором цикле используется обратная инструкция \TT{``LDR R2, [SP,R4,LSL\#2]''}, она загружает из массива нужное
значение, и указатель на него вычисляется точно так же.

\subsubsection{ARM + \OptimizingKeil + режим thumb}

\lstinputlisting{arrays/simple_Keil_thumb_O3_en.asm}

Код для thumb очень похожий. В thumb имеются отдельные инструкции для битовых сдвигов (\TT{LSLS}), вычисляющие и
число для записи в массив и адрес каждого элемента массива.

Компилятор почему-то выделил в локальном стеке немного больше места, однако последние 4 байта не используются.

