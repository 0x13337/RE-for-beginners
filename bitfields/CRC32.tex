\subsection{\IFRU{Пример вычисления CRC32}{CRC32 calculation example}}

\newcommand{\URLCRCSRC}{\url{http://burtleburtle.net/bob/c/crc.c}}

\IFRU{Это распространенный табличный способ вычисления хеша алгоритмом 
CRC32\footnote{Исходник взят тут: \URLCRCSRC}.}
{This is very popular table-based CRC32 hash calculation 
method\footnote{Source code was taken here: \URLCRCSRC}.}

\lstinputlisting{bitfields/14_CRC.c}

\IFRU{Нас интересует функция \TT{crc()}. 
Кстати, обратите внимание, автор указал два инициализатора в выражении \TT{for()}: \TT{hash=len, i=0}. 
Стандарт \CCpp, конечно, допускает это. А в итоговом коде, вместо одной операции инициализации цикла, будет две.}
{We are interesting in \TT{crc()} function only.
By the way, please note: programmer used two loop initializers in \TT{for()} statement: \TT{hash=len, i=0}.
\CCpp standard allows this, of course. Emited code will contain two operations in loop initialization part
instead of usual one.}

\IFRU{Компилируем в MSVC с оптимизацией (\Ox). 
Для краткости, я приведу только функцию \TT{crc()}, с некоторыми комментариями.}
{Let's compile it in MSVC with optimization (\Ox).
For the sake of brevity, only \TT{crc()} function is listed here, with my comments.}

\lstinputlisting{\IFRU{bitfields/14_CRC_2_ru.asm}{bitfields/14_CRC_2_en.asm}}

\IFRU{Попробуем то же самое в GCC 4.4.1 с опцией \Othree:}
{Let's try the same in GCC 4.4.1 with \Othree option:}

\lstinputlisting{\IFRU{bitfields/14_CRC_gcc_O3_ru.asm}{bitfields/14_CRC_gcc_O3_en.asm}}

\IFRU{GCC немного выровнял начало тела цикла по 8-байтной границе, для этого добавил 
\NOP и \TT{lea esi, [esi+0]} (что тоже \IT{холостая операция}). 
Подробнее об этом смотрите в разделе о npad~\ref{sec:npad}.}
{GCC aligned loop start by 8-byte border by adding \NOP and \TT{lea esi, [esi+0]} (that's \IT{idle operation} too).
Read more about it in npad section~\ref{sec:npad}.}
