\section{ostream}
\index{\Cpp!ostream}

\IFRU{Начнем снова с примера типа ``hello world'', на этот раз используя ostream:}
{Let's start again with a ``hello world'' example, but now will use ostream:}

\lstinputlisting{cpp/ostream/1.cpp}

\IFRU{Из практически любого учебника Си++, известно что операцию << можно заменить для других типов.}
{Almost any C++ textbook tells that \TT{<<} operation can be replaced (overloaded) for other types.}
\IFRU{Что и делается в}{That is what is done in} ostream.
\IFRU{Видно что в реальности вызывается \TT{operator<<} для ostream}{We see that \TT{operator<<} is called for ostream}:

\lstinputlisting[caption=MSVC 2012 (reduced listing)]{cpp/ostream/1.asm}

\IFRU{Немного переделаем пример}{Let's modify the example}:

\lstinputlisting{cpp/ostream/2.cpp}

\IFRU{И снова, из многих учебников по Си++, известно что результат каждого \TT{operator<<} 
в ostream передается в следующий.}
{And again, from many C++ textbooks we know that the result of each \TT{operator<<} in ostream is forwarded to the
next one.}
\IFRU{Действительно}{Indeed}:

\lstinputlisting[caption=MSVC 2012]{cpp/ostream/2.asm}

\IFRU{Если заменить \TT{operator<<} на f(), то этот код можно было бы переписать примерно так:}
{If to replace \TT{operator<<} by f(), that code can be rewritten as:}

\begin{lstlisting}
f(f(std::cout, "Hello, "), "world!")
\end{lstlisting}

GCC \IFRU{генерирует практически такой же код как и}{generates almost the same code as} MSVC.

