\section{\RU{Сравнение ``снимков'' памяти}\EN{Memory ``snapshots'' comparing}}

\RU{Метод простого сравнения двух снимков памяти для поиска изменений часто применялся для взлома игр 
на 8-битных компьютерах и взлома файлов с записанными рекордными очками.}
\EN{The technique of straightforward two memory snapshots comparing in order to see changes, was often used to hack
8-bit computer games and hacking ``high score'' files.}

\RU{К примеру, если вы имеете загруженную игру на 8-битном компьютере (где самой памяти не очень много, но игра
занимает еще меньше), и вы знаете что сейчас у вас, условно, 100 пуль, вы можете сделать ``снимок'' всей
памяти и сохранить где-то. Затем просто стреляете куда угодно, у вас станет 99 пуль, сделать второй ``снимок'',
и затем сравнить эти два снимка: где-то наверняка должен быть байт, который в начале был 100, а затем стал 99.}
\EN{For example, if you got a loaded game on 8-bit computer (it is not much memory on these, but game is usually
consumes even less memory) and you know that you have now, let's say, 100 bullets, you can do a ``snapshot''
of all memory and back it up to some place. Then shoot somewhere, bullet count now 99, do second ``snapshot''
and then compare both: somewhere must be a byte which was 100 in the beginning and now it is 99.}
\RU{Если учесть, что игры на тех маломощных домашних компьютерах обычно были написаны на ассемблере и подобные
переменные там были глобальные, то можно с уверенностью сказать, какой адрес в памяти всегда отвечает за количество
пуль. Если поискать в дизассемблированном коде игры все обращения по этому адресу, несложно найти код,
отвечающий за уменьшение пуль и записать туда инструкцию \gls{NOP}
или несколько \gls{NOP}-в, так мы получим игру в которой у игрока всегда будет 100 пуль, например.}
\EN{Considering a fact these 8-bit games were often written in assembly language and such variables were global,
it can be said for sure, which address in memory holding bullets count. If to search all references to the
address in disassembled game code, it is not very hard to find a piece of code \glslink{decrement}{decrementing} bullets count,
write \gls{NOP} instruction there, or couple of \gls{NOP}-s, 
we'll have a game with e.g 100 bullets forever.}
\index{BASIC!POKE}
\RU{А так как игры на тех домашних 8-битных 
компьютерах всегда загружались по одним и тем же адресам, и версий одной игры редко когда было больше одной продолжительное время,
то геймеры-энтузиасты знали, по какому адресу (используя инструкцию языка BASIC \gls{POKE}) что записать после загрузки
игры, чтобы хакнуть её. Это привело к появлению списков ``читов'' состоящих из инструкций \gls{POKE}, публикуемых
в журналах посвященным 8-битным играм. См. также:}\EN{Games on these 8-bit computers was commonly loaded on the same
address, also, there were no much different versions of each game (commonly just one version was popular for a long span of time),
enthusiastic gamers knew, which byte must be written (using BASIC instruction \gls{POKE}) to which address in
order to hack it. This led to ``cheat'' lists containing of \gls{POKE} instructions published in magazines related to
8-bit games. See also:} \url{http://en.wikipedia.org/wiki/PEEK\_and\_POKE}.

\index{MS-DOS}
\RU{Точно так же легко модифицировать файлы с сохраненными рекордами (кто сколько очков набрал), впрочем, это может
сработать не только с 8-битными играми. Нужно заметить, какой у вас сейчас рекорд и где-то сохранить файл
с очками. Затем, когда очков станет другое количество, просто сравнить два файла, можно даже
DOS-утилитой FC\footnote{утилита MS-DOS для сравнения двух файлов побайтово} (файлы рекордов, часто, бинарные).}
\EN{Likewise, it is easy to modify ``high score'' files, this may work not only with 8-bit games. Let's notice 
your score count and back the file up somewhere. When ``high score'' count will be different, just compare two files,
it can be even done with DOS-utility FC\footnote{MS-DOS utility for binary files comparing} (``high score'' files
are often in binary form).}
\RU{Где-то будут отличаться несколько байт, и легко будет увидеть, какие именно отвечают за количество очков. 
Впрочем, разработчики игр осведомлены о таких хитростях и могут защититься от этого.}
\EN{There will be a point where couple of bytes will be different and it will be easy to see which ones are
holding score number.
However, game developers are aware of such tricks and may protect against it.}

\RU{В каком-то смысле похожий пример в этой книге здесь}
\EN{Somewhat similar example here in the book is}: \ref{Millenium_DOS_game}.

% TODO: пример с какой-то простой игрушкой?

\subsection{\RU{Реестр Windows}\EN{Windows registry}}

\RU{А еще можно вспомнить сравнение реестра Windows до инсталляции программы и после}
\EN{It is also possible to compare Windows registry before and after a program installation}.
\RU{Это также популярный метод поиска, какие элементы реестра программа будет использовать}
\EN{It is very popular method of finding, which registry elements a program will use}.
\EN{Probably, this is a reason why ``windows registy cleaner'' shareware is so popluar.}
\RU{Наверное это причина, почему так популярны shareware-программы для очистки реестра в Windows.}
