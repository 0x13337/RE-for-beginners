\chapter{CPU}

\section{\RU{Предсказатели переходов}\EN{Branch predictors}}
\label{branch_predictors}

\RU{Некоторые современные компиляторы пытаются избавиться от инструкций условных переходов}\EN{Some modern 
compilers try to get rid of conditional jump instructions}.
\RU{Примеры в этой книге}\EN{Examples in this book are}: 
\ref{subsec:jcc_ARM}, \ref{chap:cond}, \ref{subsec:popcnt}. % FIXME

\RU{Это потому что предсказатель переходов далеко не всегда работает идеально, поэтому, компиляторы и стараются
реже использовать переходы, если возможно.}
\EN{This is because because branch predictor is not always perfect, so compilers try to do 
without conditional jumps, if possible.}

\index{x86!\Instructions!CMOVcc}
\index{ARM!\Instructions!ADRcc}
\RU{Одна из возможностей это условные инструкции в ARM (как ADRcc), а еще инструкция CMOVcc в x86.}
\EN{Conditional instructions in ARM (like ADRcc) is one way, another is CMOVcc x86 instruction.}

\section{\RU{Зависимости между данными}\EN{Data dependencies}}

\EN{Modern CPUs are able to execute instructions simultaneously (\ac{OOE}), but in order to do so,
results of one instructions in group must not influence execution of others.}
\RU{Современные процессоры способны исполнять инструкции одновременно (\ac{OOE}), но для этого,
внутри такой группы, результат одних не должен влиять на работу других.}
\EN{Hence, compiler endeavor to use instructions with minimal influence to the CPU state.}
\RU{Следовательно, компилятор старается использовать инструкции с наименьшим влиянием на
состояние процессора.}

\EN{That's why \LEA instruction is so popular, because it do not modify CPU flags, while
other arithmetic instructions do this.}
\RU{Вот почему инструкция \LEA в x86 такая популярная --- 
потому что она не модифицирует флаги процессора,
а прочие арифметические инструкции --- модифицируют.}
