\section{
	\RU{Память}%
	\EN{Memory}%
	\ES{Memoria}%
	\PTBRph{}%
	\DEph{}\PLph{}%
	\ITAph{}%
}

\RU{Есть три основных типа памяти:}
\EN{There are 3 main types of memory:}
\ES{Existen 3 tipos principales de memoria:}%
\PTBRph{}%
\DEph{}\PLph{}%
\ITAph{}

\begin{itemize}
\item
\RU{Глобальная память \ac{AKA} \q{static memory allocation}.}%
\EN{Global memory \ac{AKA} \q{static memory allocation}.}%
\ES{Memoria global \ac{AKA} \q{asignaci\'on est\'atica de memoria}.}%
\PTBRph{}%
\DEph{}\PLph{}%
\ITAph{}
\RU{Нет нужды явно выделять, выделение происходит просто при объявлении переменных/массивов 
глобально.}%
\EN{No need to allocate explicitly, the allocation is done just by declaring variables/arrays 
globally.}%
\ES{No hay necesidad de asignarla expl\'icitamente, la asignaci\'on es realizada al declarar
variables/arreglos globales.}%
\PTBRph{}%
\DEph{}\PLph{}%
\ITAph{}
\RU{Это глобальные переменные расположенные в сегменте данных или констант.}%
\EN{These are global variables, residing in the data or constant segments.}%
\ES{Estas variables globales residen en los segmentos de datos o de constantes.}%
\PTBRph{}%
\DEph{}\PLph{}%
\ITAph{}
\RU{Доступны глобально (поэтому считаются \glslink{anti-pattern}{анти-паттерном}).}%
\EN{They are available globally (hence, considered as an \gls{anti-pattern}).}%
\ES{Est\'an disponibles globalmente (por lo tanto, se consideran un anti-patr\'on).}%
\PTBRph{}%
\DEph{}\PLph{}%
\ITAph{}
\RU{Не удобны для буферов/массивов, потому что должны иметь фиксированный размер.}%
\EN{Not convenient for buffers/arrays, because they must have a fixed size.}%
\ES{No son convenientes para buffers/arreglos porque deben tener un tama\~no fijo.}%
\PTBRph{}%
\DEph{}\PLph{}%
\ITAph{}
\RU{Переполнения буфера, случающиеся здесь, обычно перезаписывают переменные или буферы
расположенные рядом в памяти.}%
\EN{Buffer overflows that occur here usually overwrite variables or buffers residing next to them in memory.}%
\ES{Los desbordamientos de buffer que occurren aqu\'i usualmente sobreescriben variables o buffers que residen
junto a ellos en memoria.}%
\PTBRph{}%
\DEph{}\PLph{}%
\ITAph{}
\RU{Пример в этой книге: \myref{scanf_global_variable}.}%
\EN{There's an example in this book: \myref{scanf_global_variable}.}%
\ES{En este libro hay un ejemplo: \myref{scanf_global_variable}.}%
\PTBRph{}%
\DEph{}\PLph{}%
\ITAph{}

\item
\RU{Стек \ac{AKA} \q{allocate on stack}, \q{выделить память в/на стеке}.}%
\EN{Stack \ac{AKA} \q{allocate on stack}.}%
\ES{Pila \ac{AKA} \q{asignaci\'on en pila}.}%
\PTBRph{}%
\DEph{}\PLph{}%
\ITAph{}
\RU{Выделение происходит просто при объявлении переменных/массивов локально в функции.}%
\EN{The allocation is done just by declaring variables/arrays locally in the function.}%
\ES{La asignaci\'on se realiza al declarar variables/arreglos dentro de una funci\'on.}%
\PTBRph{}%
\DEph{}\PLph{}%
\ITAph{}
\RU{Обычно это локальные для функции переменные.}%
\EN{These are usually local variables for the function.}%
\ES{Son usualmente variables locales a la funci\'on.}%
\PTBRph{}%
\DEph{}\PLph{}%
\ITAph{}
\RU{Иногда эти локальные переменные также доступны и для нисходящих функций (\gls{callee}-функциям, если функция-\gls{caller} передает
указатель на переменную в функцию-\gls{callee}).}%
\EN{Sometimes these local variable are also available to descending functions 
(to \gls{callee} functions, if caller passes a pointer to a variable to the \gls{callee} to be executed).}%
\ES{Algunas veces estas variables locales tambi\'en estan disponibles para funciones descendientes
(funciones llamadas, si aquel que la llama le pasa un apuntador a una de sus variables).}%
\PTBRph{}%
\DEph{}\PLph{}%
\ITAph{}
\RU{Выделение и освобождение очень быстрое, достаточно просто сдвига \ac{SP}.}
\EN{Allocation and deallocation are very fast, it just \ac{SP} needs to be shifted.}
\ES{La asignaci\'on y desasignaci\'on son muy r\'apidas, s\'olo necesita que \ac{SP} sea ajustado.}%
\PTBRph{}%
\DEph{}\PLph{}%
\ITAph{}
\myindex{\CStandardLibrary!alloca()}
\RU{Но также не удобно для буферов/массивов, потому что размер буфера фиксирован,
если только не используется \TT{alloca()} (\myref{alloca}) (или массив с переменной длиной).}
\EN{But they're also not convenient for buffers/arrays, because the buffer size has to be fixed,
unless \TT{alloca()} (\myref{alloca}) (or a variable-length array) is used.}
\ES{}%
\PTBRph{}%
\DEph{}\PLph{}%
\ITAph{}
\RU{Переполнение буфера обычно перезаписывает важные структуры стека: \myref{subsec:bufferoverflow}.}%
\EN{Buffer overflows usually overwrite important stack structures: \myref{subsec:bufferoverflow}.}%
\ES{Los desbordamientos de buffer suelen reescribir estructuras importantes en la pila: \myref{subsec:bufferoverflow}.}%
\PTBRph{}%
\DEph{}\PLph{}%
\ITAph{}

\myindex{\CStandardLibrary!malloc()}
\myindex{\CStandardLibrary!free()}
\item
\RU{Куча (\IT{heap}) \ac{AKA} \q{dynamic memory allocation}, \q{выделить память в куче}.}%
\EN{Heap \ac{AKA} \q{dynamic memory allocation}.}%
\ES{Heap \ac{AKA} \q{asignaci\'on din\'amica de memoria}.}%
\PTBRph{}%
\DEph{}\PLph{}%
\ITAph{}
\RU{Выделение происходит при помощи вызова \\
\TT{malloc()/free()} или \TT{new/delete} в \Cpp.}%
\EN{Allocation/deallocation is done by calling \\
\TT{malloc()/free()} or \TT{new/delete} in \Cpp.}
\ES{La asignaci\'on/desasignaci\'on es realizada llamando a \\
\TT{malloc()/free()} \ESph{} \TT{new/delete} \ESph{} \Cpp.}%
\PTBRph{}%
\DEph{}\PLph{}%
\ITAph{}
\RU{Самый удобный метод: размер блока может быть задан во время исполнения.}%
\EN{This is the most convenient method: the block size may be set at runtime.}%
\ES{\'Este es el m\'etodo m\'as conveniente: el tama\~no del bloque puede establecerse en tiempo de ejecuci\'on.}%
\PTBRph{}%
\DEph{}\PLph{}%
\ITAph{}
\myindex{\CStandardLibrary!realloc()}
\RU{Изменение размера возможно (при помощи \TT{realloc()}), но может быть медленным.}
\EN{Resizing is possible (using \TT{realloc()}), but can be slow.}
\ES{Cambiar el tama\~no es posible (usando \TT{realloc()}), pero puede ser lento.}%
\PTBRph{}%
\DEph{}\PLph{}%
\ITAph{}
\RU{Это самый медленный метод выделения памяти: аллокатор памяти должен поддерживать и обновлять
все управляющие структуры во время выделения и освобождения.}%
\EN{This is the slowest way to allocate memory: 
the memory allocator must support and update all control structures while
allocating and deallocating.}%
\ES{\'Esta es la forma m\'as lenta de asignar memoria:
el asignador de memoria debe suportar y actualizar todas las estructuras de control
mientras se asigna y desasigna.}%
\PTBRph{}%
\DEph{}\PLph{}%
\ITAph{}
\RU{Переполнение буфера обычно перезаписывает все эти структуры.}%
\EN{Buffer overflows usually overwrite these structures.}%
\ES{Los desbordamientos de buffer suelen sobreescribir estas estructuras.}%
\PTBRph{}%
\DEph{}\PLph{}%
\ITAph{}
\RU{Выделения в куче также ведут к проблеме утечек памяти: каждый выделенный блок должен быть
явно освобожден, но кто-то может забыть об этом, или делать это неправильно.}%
\EN{Heap allocations are also source of memory leak problems: each memory block has to be deallocated
explicitly, but one may forget about it, or do it incorrectly.}%
\ES{Las asiganciones en el heap tambi\'en son el origen de problemas de fuga de memoria: cada bloque de memoria tiene
que ser desasgnado expl\'icitamente, pero uno puede olvidarse de ello, o hacerlo de manera incorrecta.}%
\PTBRph{}%
\DEph{}\PLph{}%
\ITAph{}
\myindex{\CStandardLibrary!free()}
\RU{Еще одна проблема --- это \q{использовать после освобождения} --- использовать блок памяти после
того как \TT{free()} был вызван на нем, это тоже очень опасно.}%
\EN{Another problem is the \q{use after free}---using a memory block after \TT{free()} was called on it,
which is very dangerous.}%
\ES{Otro problema es el \q{uso despu\'es de la liberaci\'on}---usar un bloque de memoria despu\'es
de que \TT{free()} ha sido llamado en \'el, lo cual es muy peligroso.}%
\PTBRph{}%
\DEph{}\PLph{}%
\ITAph{}
\RU{Пример в этой книге:}%
\EN{Example in this book:}%
\ES{Un ejemplo en este libro:}%
\PTBRph{}%
\DEph{}\PLph{}%
\ITAph{}
\myref{struct_malloc_example}.

\end{itemize}
