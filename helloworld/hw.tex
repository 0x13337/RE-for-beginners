\section{Hello, world!}
\label{sec:helloworld}

\IFRU{Начнем с знаменитого примера из книги}{Let's start with famous example from the book} ``The C programming Language''\footnote{\url{http://en.wikipedia.org/wiki/The_C_Programming_Language}}:

\lstinputlisting{helloworld/1_1.c}

\subsection{x86 + MSVC}

\IFRU{Компилируем в}{Let's compile it in} MSVC 2010: \TT{cl 1.cpp /Fa1.asm}

\IFRU
{(Ключ /Fa означает сгенерировать листинг на ассемблере)}
{(/Fa option mean generate assembly listing file)}

\begin{lstlisting}
CONST	SEGMENT
$SG3830	DB	'hello, world', 00H
CONST	ENDS
PUBLIC	_main
EXTRN	_printf:PROC
; Function compile flags: /Odtp
_TEXT	SEGMENT
_main	PROC
	push	ebp
	mov	ebp, esp
	push	OFFSET $SG3830
	call	_printf
	add	esp, 4
	xor	eax, eax
	pop	ebp
	ret	0
_main	ENDP
_TEXT	ENDS
\end{lstlisting}

\IFRU{Компилятор сгенерировал файл \TT{1.obj}, который впоследствии будет слинкован линкером в \TT{1.exe}.} 
{Compiler generated \TT{1.obj} file which will be linked into \TT{1.exe}.}

\IFRU{В нашем случае, этот файл состоит из двух сегментов: \TT{CONST} (для данных-констант) и \TT{\_TEXT} (для кода).}
{In our case, the file contain two segments: \TT{CONST} (for data constants) and \TT{\_TEXT} (for code).} 

\IFRU{Строка \TT{``hello, world''} в \CCpp имеет тип \TT{const char*}, однако не имеет имени.}
{The string \TT{``hello, world''} in \CCpp has type \TT{const char*}, however hasn't its own name.}

\IFRU{Но компилятору нужно как-то с ней работать, так что он дает ей внутреннее имя \TT{\$SG3830}.}
{But compiler need to work with this string somehow, so it define internal name \TT{\$SG3830} for it.}

\IFRU{Как видно, строка заканчивается нулевым байтом ~--- это требования стандарта \CCpp насчет строк.}
{As we can see, the string is terminated by zero byte ~--- this is \CCpp standard of strings.}

\IFRU{В сегменте кода \TT{\_TEXT} находится пока только одна функция ~--- \TT{\_main}.}
{In the code segment \TT{\_TEXT} there are only one function so far ~--- \TT{\_main}.}

\IFRU{Функция \TT{\_main}, как и практически все функции, начинается с пролога и заканчивается эпилогом.}
{Function \TT{\_main} starting with prologue code and ending with epilogue code, like almost any function.}

\IFRU{Об этом смотрите подробнее в разделе о прологе и эпилоге функции}
{Read more about it in section about function prolog and epilog}
~\ref{sec:prologepilog}.

\IFRU{Далее следует вызов функции \printf}
{After function prologue we see a function \printf call}: \TT{CALL \_printf}. 

\IFRU
{Перед этим вызовом, адрес строки (или указатель на нее) с нашим приветствием при помощи инструкции \PUSH помещается в стек.}
{Before the call, string address (or pointer to it) containing our greeting is placed into stack with help of \PUSH instruction.}

\IFRU{После того как функция \printf возвращает управление в функцию \main, адрес строки (или указатель на нее) все еще лежит в стеке.}
{When \printf function returning control flow to \main function, string address (or pointer to it) is still in stack.}

\IFRU{Так как он больше не нужен, то указатель стека (регистр \ESP) корректируется.} 
{Because we do not need it anymore, stack pointer (\ESP register) is to be corrected.}

\TT{ADD ESP, 4} \IFRU{означает прибавить 4 к значению в регистре \ESP.}
{mean add 4 to the value in \ESP register.}

\IFRU
{Почему 4? Так как, это 32-битный код, для передачи адреса нужно аккурат 4 байта. В x64-коде это 8 байт.}
{Why 4? Since it is 32-bit code, we need exactly 4 bytes for address passing through the stack. 
It's 8 bytes in x64-code}

\TT{``ADD ESP, 4''} \IFRU{эквивалентно \TT{``POP регистр''}, но без использования какого-либо регистра\footnote{Флаги
процессора, впрочем, модифицируются}.}
{is equivalent to \TT{``POP register''} but without any register usage\footnote{CPU flags, however, modified}.}

\IFRU
{Некоторые компиляторы, например Intel C++ Compiler, в этой же ситуации, могут вместо 
\ADD сгенерировать \TT{POP ECX} (это можно встретить например в коде \oracle{}, им скомпилированном), 
что почти то же самое, только портится значение в регистре \ECX.}
{Some compilers like Intel C++ Compiler, at the same point, could emit \TT{POP ECX} 
instead of \ADD (for example, this can be observed in \oracle{} code, compiled by Intel C++ compiler), 
and this instruction has almost the same effect, but \ECX register contents will be rewritten.}

\IFRU
{Возможно, компилятор применяет \TT{POP ECX} потому что эта инструкция короче (1 байт против 3).}
{Probably, Intel C++ compiler using \TT{POP ECX} because this instruction's opcode is shorter then 
\TT{ADD ESP, x} (1 byte against 3).}

\IFRU{О стеке можно прочитать в соответствующем разделе}{Read more about stack in relevant section}~\ref{sec:stack}.

\IFRU{После вызова \printf, в оригинальном коде на \CCpp указано \TT{return 0} ~--- вернуть 0 
в качестве результата функции \main.} 
{After \printf call, in original \CCpp code was \TT{return 0} ~--- return zero as a \main function result.} 

\IFRU{В сгенерированном коде это обеспечивается инструкцией}
{In the generated code this is implemented by instruction} \TT{XOR EAX, EAX} 

\IFRU
{\XOR, на самом деле, как легко догадаться, ``исключающее ИЛИ''}
{\XOR, in fact, just ``eXclusive OR''}
\footnote{\url{http://en.wikipedia.org/wiki/Exclusive_or}}, 
\IFRU
{но компиляторы часто используют его вместо простого}
{but compilers using it often instead of}
\TT{MOV EAX, 0} ~--- 
\IFRU
{потому что снова опкод короче (2 байта против 5).}
{slightly shorter opcode again (2 bytes against 5).}

\IFRU{Бывает так, что некоторые компиляторы генерируют}{Some compilers emitting} 
\TT{SUB EAX, EAX}, 
\IFRU
{что значит, \IT{отнять значение \EAX от \EAX}, в любом случае это даст 0 в результате.}
{which mean \IT{SUBtract \EAX value from \EAX}, which is in any case will result zero.}

\IFRU{Самая последняя инструкция \RET возвращает управление в вызывающую функцию.
Обычно, это код \CCpp CRT\footnote{C Run-Time Code}, который, в свою очередь, 
вернет управление операционной системе.}
{Last instruction \RET returning control flow to calling function.
Usually, it's \CCpp CRT\footnote{C Run-Time Code} code, which, in turn, 
return control to operation system.}

\subsection{x86 + GCC}

\IFRU{Теперь скомпилируем то же самое компилятором GCC 4.4.1 в Linux}
{Now let's try to compile the same \CCpp code in GCC 4.4.1 compiler in Linux}: \TT{gcc 1.c -o 1}

\IFRU{Затем при помощи \IDA. посмотрим как создалась функция \main.}
{After, with the \IDA disassembler assistance, let's see how \main function was created.} 

\IFRU{С другой стороны, мы можем посмотреть результат работы GCC при помощи ключа}
{Note: we could also see GCC assembler result applying option} \TT{-S -masm=intel}

\begin{lstlisting}
main            proc near

var_10          = dword ptr -10h

                push    ebp
                mov     ebp, esp
                and     esp, 0FFFFFFF0h
                sub     esp, 10h
                mov     eax, offset aHelloWorld ; "hello, world"
                mov     [esp+10h+var_10], eax
                call    _printf
                mov     eax, 0
                leave
                retn
main            endp
\end{lstlisting}

\IFRU{Почти то же самое. 
Адрес строки ``hello, world'' лежащей в сегменте данных, в начале сохраняется в \EAX, затем записывается в стек.
А еще в прологе функции мы видим \TT{AND ESP, 0FFFFFFF0h} ~--- 
эта инструкция выравнивает значение в \ESP по 16-байтной границе, делая все значения 
в стеке также выровненными по этой границе (процессор более эффективно работает с переменными расположенными
в памяти по адресам кратным 4 или 16)\footnote{\URLWPDA}.}
{Almost the same.
Address of ``hello world'' string (stored in data segment) is saved in \EAX register first, then it stored into stack.
Also, in function prologue we see \TT{AND ESP, 0FFFFFFF0h} ~--- 
this instruction aligning \ESP value on 16-byte border, resulting all values in stack aligned too
(CPU performing better if values it working with are located in memory at addresses aligned by 
4 or 16 byte border)\footnote{\URLWPDA}.}

\TT{SUB ESP, 10h} \IFRU{выделяет в стеке 16 байт, хотя, как будет видно далее, здесь достаточно только 4.}
{allocate 16 bytes in stack, although, as we could see below, only 4 need here.} 

\IFRU{Это происходит потому что количество выделяемого места в локальном стеке тоже выровнено по 
16-байтной границе.}{This is because the size of allocated stack is also aligned on 16-byte border.}

% TODO: rewrite.
\IFRU{Адрес строки (или указатель на строку) затем записывается прямо в стек без помощи инструкции \PUSH.
\IT{var\_10} по совместительству ~--- и локальная переменная и одновременно аргумент для \printf{}. Подробнее об этом будет ниже.}
{String address (or pointer to string) is then writing directly into stack space without \PUSH instruction use.
\IT{var\_10} ~--- is local variable, but also argument for \printf{}. Read below about it.}

\IFRU{Затем вызывается \printf.}{Then \printf function is called.}

\IFRU{В отличие от MSVC, GCC в компиляции без включенной оптимизации генерирует \TT{MOV EAX, 0} вместо 
более короткого опкода.}{Unlike MSVC, GCC while compiling without optimization turned on, 
emitting \TT{MOV EAX, 0} instead of shorter opcode.}

\IFRU{Последняя инструкция \LEAVE ~--- это аналог команд \TT{MOV ESP, EBP} и \TT{POP EBP} ~--- 
то есть возврат указателя стека и регистра \EBP в первоначальное состояние.} 
{The last instruction \LEAVE ~--- is \TT{MOV ESP, EBP} and \TT{POP EBP} instructions pair equivalent ~--- 
in other words, this instruction setting back stack pointer (\ESP) and \EBP register to its initial state.} 

\IFRU{Это необходимо, т.к., в начале функции мы модифицировали регистры \ESP и \EBP (при помощи}
{This is necessary because we modified these register values (\ESP and \EBP) at the function start (executing}
\TT{\MOV EBP, ESP} / \TT{AND ESP, ...}).

\subsection{ARM + optimizing Keil}

Для экспериментов с процессором ARM, я выбрал два компилятора: популярный в embedded-среде Keil Release 6/2013 и среду разработки Apple Xcode 4.6.3 (с компилятором LLVM 4.2), генерирующую код для ARM-совместимых процессоров в iPhone, iPod и iPad.

Для начала, скомпилируем наш пример в Keil:

\begin{lstlisting}
armcc.exe --arm --c90 -O3 -S 1.c 
\end{lstlisting}

\begin{lstlisting}
main PROC
        PUSH     {r4,lr}
        ADR      r0,|L0.20|
        BL       __2printf
        MOV      r0,#0
        POP      {r4,pc}
        ENDP

|L0.20|
        DCB      "hello, world",0
\end{lstlisting}

\IFRU{Вот чуть-чуть фактов о процессоре ARM, которые желательно знать}{... couple facts should know in order to proceed}.
ARM имеет по крайней мере два основных режима: ARM state и thumb. 
В первом режиме доступны все инструкции и каждая имеет размер 32 бита (или 4 байта). 
Во втором режиме (thumb) каждая инструкция имеет размер 16 бит (или 2 байта). Режим thumb выгоднее тем что программа
на нем может быть 1) компактнее; 2) эффективнее исполняться на микроконтроллере с 16-битной шиной данных. Но за всё
нужно платить: в режиме thumb куда меньше возможностей процессора, например, возможен доступ только к 8-и регистрам
процессора, и чтобы совершить некоторые действия, нужны несколько thumb-инструкций.
Программа для ARM может представлять смесь процедур скомпилированных для обоих режимов.

Инструкции для работы со стеком \PUSH/\POP доступны только в thumb-режиме, так что перед нами код содержащий thumb-инструкции.

Итак, в самом начале инструкция \TT{''PUSH \{r4,lr\}''} сохраняет в стеке значения двух регистров: R4 и LR.

Вторая инструкция \TT{''ADR r0,|L0.20|''} записывает в регистр R0 сумму смещения во втором операнде 
и значения регистра PC.
Регистр PC это адрес текущей инструкции, аналог \EIP в x86.
Итак, в R0 записывается \TT{PC + L0.20}. Зачем здесь нужен еще и PC? Затем что это так называемый "адресно-независимый код"\footnote{больше об этом читайте в соответствующей секции~\ref{sec:PIC}}, он предназначен для исполнения будучи расположенным по любым адресам в памяти.
L0.20 это, можно сказать, разница между адресом где исполняется инструкция \TT{ADR} и адресом где расположена строка \IT{"hello, world"}. Очевидно, разница между этими двумя адресами постоянная и не изменится, куда бы этот код не загрузился.

Инструкция \TT{''BL \_\_2printf''} совершает две операции: записывает адрес сразу после инструкции BL в регистр LR (\IT{link register}), затем передает управление по адресу, где расположена функция \TT{\_\_2printf}, 
просто записав её адрес в PC.
\TT{printf()}, закончив свою работу, вернет управление используя адрес из регистра LR. Таким образом, можно сказать,
LR обычно содержит адрес в вызывающей функции, куда нужно вернуть управление в конце работы.

Инструкция \TT{''MOV r0, \#0''} просто зписывает ноль в регистр R0 ~--- ведь наша функция должна вернуть 0, а в ARM результат возвращается в R0.

Самая последняя инструкция \TT{''POP \{r4,pc\}''} выполняет сразу две операции: восстанавливает регистр R4, а еще возвращает управление. Помните: первая инструкция PUSH сохранила в стеке два значения: R4 и LR (\IT{link register}).
Так как наша функция самая главная (\IT{main()}) и вызывается скорее всего из какого-нибудь загрузчика, 
в LR хранится адрес где-то там, куда нужно в итоге вернуть управление.
Так что последняя инструкция \POP записывает эти два значения в регистры R4 и PC, делая ненужным здесь отдельную 
инструкцию вроде \RET в x86. Кстати, в x86 нельзя напрямую модифицировать регистр содержащий адрес текущей инструкции (\EIP или \RIP) а в ARM ~--- можно.

\subsection{ARM + non-optimizing Xcode}

Посмотрим в \IDA, какой код можно генерируется для ARM в iPhone/iPad/iPod, в режиме компиляции -O0 
(без оптимизации).

\begin{lstlisting}
_hello_world
var_C           = -0xC
                PUSH            {R7,LR}
                MOV             R7, SP
                SUB             SP, SP, #4
                MOV             R0, 0x12E1
                ADD             R0, PC
                BLX             _printf
                MOVS            R1, 0
                STR             R0, [SP,#0xC+var_C]
                MOV             R0, R1
                ADD             SP, SP, #4
                POP             {R7,PC}

...

aHelloWorld     DCB "Hello world!",0xA,0
\end{lstlisting}

Это также thumb-код.
Разница между этим и тем что мы уже рассмотрели в том, что здесь выделяется место в локальном стеке под переменную,
которую \IDA наименовала \IT{var\_C}. Происходит это так: от текущего адреса вершины стека SP\footnote{stack pointer}, при помощи инструкции SUB\footnote{SUBtract} отнимается 4 байта. 4 байта это как раз столько, сколько нужно для хранения любого 32-битного значения. 

Затем, как и в предыдущем примере, указатель на строку \IT{"Hello world!"}
корректируется при помощи адреса исполняемой сейчас инструкции (PC\footnote{program counter}), потому что это также "адресно-независимый код"~\ref{sec:PIC}. 

Инструкция при помощи которой вызывается функция \IT{printf()} на этот раз BLX а не BL, как в предыдущем примере.
Разница между ними в том, что BLX помимо перехода на другой адрес и сохранения адреса после себя в LR\footnote{link register} еще и меняет режим процессора с ARM на Thumb или наоборот. Так как в данный момент времени процессор в режиме Thumb, после инструкции BLX режим сменится на ARM. Там мы увидим (в \IDA) следующее:

\begin{lstlisting}
__symbolstub1:00003FF4              ; int printf(const char *, ...)
__symbolstub1:00003FF4              _printf                                 ; CODE XREF: _hello_world+10
__symbolstub1:00003FF4 3C F0 9F E5  LDR             PC, =__imp__printf
__symbolstub1:00003FF4              ; End of function _printf
\end{lstlisting}

LDR здесь обычная 32-битная ARM-инструкция (обратите внимание на то что она занимает здесь 4 байта). Инструкция
просто загружает адрес printf() из динамической библиотеки прямо в регистр PC. Это называется thunk, функция-переходник, просто передающая управления дальше. Такой код много где распространен.

Итак, внимательный читатель может задать справделивый вопрос: почему бы не вызывать printf() сразу в том же коде,
где он нужен? Это не очень выгодно (в плане экономия места) и вот почему. Практически любая программа использует внешние динамические библиотеки, будь то DLL в Windows, .so в *NIX либо .dylib в Mac OS X. В динамических библиотеках
находятся часто используемые библиотечные вызовы, в том числе стандартная функция Си printf(). В бинарном файле (Windows PE .exe, ELF либо Mach-O) имеется секция импортов, список символов (функций либо глобальных переменных) импортируемых из внешних модулей, а также названия самих модулей. Загрузчик операционной системы загружает необходимые
модули и, перебирая импортируемые символы в основном модуле, проставляет правильные адреса каждого символа.
В нашем случае, \IT{\_\_imp\_\_printf} это 32-битная переменная, куда загрузчик ОС запишет правильный адрес этой же функции во внешней библиотеке. Так что инструкция LDR просто берет 32-битное значение из этой переменной и, записывая его в регистр PC, просто передает туда управление. 
Чтобы уменьшить время работы загрузчика ОС, нужно чтобы ему пришлось записать адрес каждого символа только один раз,в соответствующее для них место.
К тому же, в thumb-режиме процессора, нельзя закодировать инструкцию, загружающую в регистр значение по некоторому адресу. Так что, наиболее оптимально, выделить отдельную функцию, работающую в режиме ARM, чья цель - передавать
управление дальше, в динамическую библиотеку, и ссылаться на нее из thumb-кода.

Следующая инструкция MOVS просто обнуляет регистр R1. Позже, он будет возвращен как результат функции main(), ведь она у нас имеет тип int и мы явно возвращаем 0 при помощи "return 0" в конце функции main().

Следующая инструкция STR записывает значение R0 в локальную переменную расположенную в стеке, \IT{var\_C}. В R0 хранится результат работы printf(). По стандарту, printf() возвращает количество успешно выведенных символов.
Вероятно, компилятор LLVM используемый в Xcode решил что это значение еще может для чего-то пригодится, поэтому не оптимизировал этот код (не забывайте, я компилировал в режиме -O0, то есть, без оптимизации). Поэтому и выделил
для этой переменной место в стеке. \IT{var\_C}, как видно, более не используется.

Следующая инструкция MOV записывает значение из регистра R1 в R0. В R1, как мы помним, ноль, это то число, которое будет возвращаться через регистр R0. Конечно, можно было бы написать \TT{''MOV R0, \#0''}, но, как я уже указывал, оптимизация отключена, здесь слишком много лишнего кода.

Далее, при помощи ADD, указатель на вершину стека SP корректируется, чтобы ''выбросить'' выделенное для 32-битного 
значения место. Так, SP возвращается на то же место, где он был в начале работы функции.

Самая последняя инструкция \TT{''POP \{R7, PC\}''} возвращает значение в R7 (сохраненное при помощи самой первой 
инструкции PUSH и записывает в PC значение которое было в LR (link register) таким образом, передавая управление
в вызывающую функцию ~--- так же как и в предыдущем примере.

