\subsection{ARM}

Для экспериментов с процессором ARM, я выбрал два компилятора: популярный в embedded-среде Keil Release 6/2013 и среду разработки Apple Xcode 4.6.3 (с компилятором LLVM-GCC 4.2), генерирующую код для ARM-совместимых процессоров в \idevices.

\subsubsection{Non-optimizing Keil: режим ARM}

Для начала, скомпилируем наш пример в Keil:

\begin{lstlisting}
armcc.exe --arm --c90 -O0 1.c 
\end{lstlisting}

Компилятор armcc генерирует листинг на ассемблере, но он содержит некоторые высокоуровневые макросы связанные с ARM\footnote{например, он показывает инструкции PUSH/POP отсутствующие в режиме ARM},
а нам важнее увидеть инструкции ``как есть'', так что посмотрим результат в \IDA.

\begin{lstlisting}
.text:00000000             main
.text:00000000 10 40 2D E9                 STMFD   SP!, {R4,LR}
.text:00000004 1E 0E 8F E2                 ADR     R0, aHelloWorld ; "hello, world"
.text:00000008 15 19 00 EB                 BL      __2printf
.text:0000000C 00 00 A0 E3                 MOV     R0, #0
.text:00000010 10 80 BD E8                 LDMFD   SP!, {R4,PC}

.text:000001EC 68 65 6C 6C+aHelloWorld     DCB "hello, world",0    ; DATA XREF: main+4
\end{lstlisting}

\IFRU{Вот чуть-чуть фактов о процессоре ARM, которые желательно знать}{... couple facts should know in order to proceed}.
ARM имеет по крайней мере два основных режима: режим ARM и thumb. 
В первом режиме доступны все инструкции и каждая имеет размер 32 бита (или 4 байта). 
Во втором режиме (thumb) каждая инструкция имеет размер 16 бит (или 2 байта). Режим thumb выгоднее тем что программа
на нем может быть 1) компактнее; 2) эффективнее исполняться на микроконтроллере с 16-битной шиной данных. Но за всё
нужно платить: в режиме thumb куда меньше возможностей процессора, например, возможен доступ только к 8-и регистрам
процессора, и чтобы совершить некоторые действия, нужны несколько thumb-инструкций.
Начиная с ARMv7, имеется также поддержка инструкций thumb-2, это thumb расширенный до поддержки куда большего числа инструкций.
Программа для процессора ARM может представлять смесь процедур скомпилированных для обоих режимов.
Основное количество приложений для \idevices скомпилировано для набора инструкций thumb-2, потому что Xcode
компилирует так по умолчанию.

В вышеприведененном примере можно легко увидеть что каждая инструкция имеет размер 4 байта. Действительно, ведь
мы же компилировали для режима ARM а не thumb.

Самая первая инструкция \TT{''STMFD SP!, \{R4,LR\}''}\footnote{Store Multiple Full Descending} работает как инструкция \PUSH, записывает значения двух регистров (R4 и LR) в стек. Действительно, в выдаваемом листинге на ассемблере, компилятор armcc, для упрощения, указывает здесь команду \TT{''PUSH \{r4,lr\}''}. Но это не совсем точно, инструкция \PUSH доступна только в режиме thumb, поэтому, во избежания путанницы, я предложил работать в \IDA.

Итак, эта инструкция записывает значения регистров \TT{R4} и \TT{LR} по адресу, на который указывает регистр \TT{SP} (stack pointer), затем уменьшает \TT{SP}, чтобы он указывал на место в стеке, доступное для новых записей.

Эта инструкция, как и инструкция \PUSH в режиме thumb, может сохранить в стеке одновременно несколько значений регистров, что может быть очень удобно. Кстати, такого в x86 нет. Так же следует заметить, что \TT{STMFD} ~--- генерализация инструкции \PUSH (то есть, расширяет её возможности), потому что может работать с любым регистром а не только с \TT{SP}, это тоже может быть очень удобно.

Инструкция \TT{''ADR R0, aHelloWorld''} прибавляет значение регистра \TT{PC} к смещению, где хранится строка \IT{``hello, world''}. Причем здесь \TT{PC}, можно спросить? Притом, что это так называемый ``адресно-независимый код''\footnote{Читайте больше об этом в соответствующем разделе~\ref{sec:PIC}}, он предназначен для исполнения будучи не привязанным к каким-либо адресам в памяти. В опкоде этой инструкции указывается разница
между адресом этой инструкции и местом, где хранится строка. Эта разница всегда будет постоянной, вне зависимости
от того, куда был загружен операционной системой наш код. Поэтому всё что нужно это прибавить адрес текущей инструкции (из PC) чтобы получить текущий абсолютный адрес начала нашей Си-строки.

Инструкция \TT{''BL \_\_2printf''}\footnote{Branch with Link} вызывает функцию \TT{printf()}. Работа этой инструкции состоит из двух фаз: 1) записать адрес после инструкции \TT{BL} (0xC) в регистр \TT{LR}\footnote{link register}, затем собственно передать управление в \TT{printf()}, записав адрес этой функции в регистр \TT{PC}\footnote{program counter}. Ведь, когда функция \TT{printf()} закончит работу, нужно знать, куда вернуть управление, поэтому закончив работу, всякая функция передает управление по адресу записанному в регистре \TT{LR}. В этом разница между ''чистыми'' RISC-процессорами вроде ARM и x86, где адрес возврата записывается в стек\footnote{Подробнее об этом будет описано в следующей главе~\ref{sec:stack}}.

Кстати, 32-битный абсолютный адрес, либо же смещение, невозможно закодировать в 32-битной инструкции \TT{BL}, в ней есть место только для 24-х бит, которые можно использовать для этого. А из-за того что все инструкции в режиме ARM имеют длину 4 байта (32 бита), и инструкции могут находится только по адресам кратным 4, то последние 2 бита (всегда нулевых) можно не кодировать. Остаются 26 бит, при помощи которых можно закодировать смещение примерно $\pm{}\approx{}32M$.

Следующая инструкция \TT{''MOV R0, \#0''}\footnote{MOVe} просто записывает 0 в регистр R0. Ведь наша Си-функция
возвращает 0 а возвращаемое значение всякая функция оставляет в R0.

Последняя инструкция \TT{''LDMFD SP!, {R4,PC}''}\footnote{Load Multiple Full Descending} это инструкция обратная
от \TT{STMFD}, она загружает из стека значения для сохранения их в \TT{R4} и \TT{PC}, увеличивая указатель стека \TT{SP}. Это, в каком-то смысле, аналог \POP. Обратите внимание: самая первая инструкция \TT{STMFD} сохранила в стеке \TT{R4} и \TT{LR}, а \IT{восстанавливаются} \TT{R4} и \TT{PC}. Как я уже описывал, в регистре \TT{LR}\footnote{link register} обычно сохраняется адрес места, куда нужно всякой функции вернуть управление. Самая первая инструкция сохраняет это значение в стеке, потому что наша функция позже будет сама пользоваться этим регистром, в момент вызова \TT{printf()}. А затем, это значение можно сразу записать в \TT{PC}, таким образом, передав управление туда, откуда была вызвана наша функция. Так как функция \TT{main()} обычно самая главная в \CCpp, вероятно, управление будет возвращено в загрузчик операционной системы, либо куда-то в runtime функции Си, или что-то в этом роде.

\TT{DCB} ~--- директива ассемблера, описывающая массивы байт или ASCII-строк, аналог директивы DB в 
Intel-ассемблере.

\subsubsection{Non-optimizing Keil: режим thumb}

Скомпилируем тот же пример в Keil для режима thumb:

\begin{lstlisting}
armcc.exe --thumb --c90 -O0 1.c 
\end{lstlisting}

Получим (в \IDA):

\begin{lstlisting}
.text:00000000             main
.text:00000000 10 B5                       PUSH    {R4,LR}
.text:00000002 C0 A0                       ADR     R0, aHelloWorld ; "hello, world"
.text:00000004 06 F0 2E F9                 BL      __2printf
.text:00000008 00 20                       MOVS    R0, #0
.text:0000000A 10 BD                       POP     {R4,PC}

.text:00000304 68 65 6C 6C+aHelloWorld     DCB "hello, world",0    ; DATA XREF: main+2
\end{lstlisting}

Сразу бросаются в глаза двухбайтные (16-битные) опкоды, это, как я уже упоминал, thumb. Кроме инструкции BL.
Но на самом деле, она состоит из двух 16-битных инструкций. 
Это потому что загрузить в PC смещение, по которому
находится функция \TT{printf()}, используя так мало места в одном 16-битном опкоде, очевидно, нельзя.
Поэтому первая 16-битная инструкция загружает старшие 10 бит смещения, а вторая ~--- 11 бит смещения.
Как я уже упоминал, все инструкции в thumb-режиме имеют длину 2 байта или 16 бит. Поэтому невозможна такая
ситуация, когда thumb-инструкция начинается по нечетному адресу. 
Следовательно, последний бит адреса можно не кодировать.
Таким образом, в итоге, в thumb-инструкции BL кодируется смещение примерно $\pm{}\approx{}2M$ от текущего адреса.

Остальные инструкции в функции: \PUSH и \POP работают почти так же как и описанные \TT{STMFD}/\TT{LDMFD}, только регистр \TT{SP} здесь не указывается явно. \TT{ADR} работает также как и в предыдущем примере. \TT{MOVS} записывает 0 в регистр R0 для возврата нуля.

\subsubsection{Optimizing Xcode: режим ARM}

Xcode 4.6.3 без включенной оптимизации выдает слишком много лишнего кода, поэтому остановимся на той версии, где как можно меньше инструкций.

\begin{lstlisting}
__text:000028C4             _hello_world
__text:000028C4 80 40 2D E9                 STMFD           SP!, {R7,LR}
__text:000028C8 86 06 01 E3                 MOV             R0, #0x1686
__text:000028CC 0D 70 A0 E1                 MOV             R7, SP
__text:000028D0 00 00 40 E3                 MOVT            R0, #0
__text:000028D4 00 00 8F E0                 ADD             R0, PC, R0
__text:000028D8 C3 05 00 EB                 BL              _puts
__text:000028DC 00 00 A0 E3                 MOV             R0, #0
__text:000028E0 80 80 BD E8                 LDMFD           SP!, {R7,PC}

__cstring:00003F62 48 65 6C 6C+aHelloWorld_0   DCB "Hello world!",0
\end{lstlisting}

Инструкции \TT{STMFD} и \TT{LDMFD} нам уже знакомы.

Инструкция \TT{MOV} просто записывает число 0x1686 в регистр R0, это смещение указывающее на строку ``Hello world!''.

Регистр R7, по стандарту принятому в ''iOS ABI Function Call Guide''\footnote{\url{http://developer.apple.com/library/ios/documentation/Xcode/Conceptual/iPhoneOSABIReference/iPhoneOSABIReference.pdf}} это frame pointer, о нем
будет рассказано позже.

Инструкция \TT{MOVT R0, \#0} записывает 0 в старшие 16 бит регистра. 
Дело в том, что обычная инструкция MOV может записывать какое-либо значение только в младшие 16 бит регистра, ведь, больше нельзя закодировать в ней. 
Помните, что в режиме ARM все инструкции ограничены длиной в 32 бита. Конечно, это не касается перемещений между регистрами.
Поэтому для записи в старшие биты (от 16-го по 31-го включительно) существует дополнительная команда MOVT.
Здесь её использование избыточно, потому что инструкция \TT{''MOV R0, \#0x1686''} итак обнулила старшую часть регистра. Возможно, это недочет компилятора.

Инструкция \TT{''ADD R0, PC, R0''} прибавляет PC к R0, для вычисления действительного адреса строки 
``Hello world!'', как нам уже известно, это ``адресно-независимый код'', поэтому такая корректива необходима.

Инструкция BL вызывает \TT{puts()} вместо \printf.

\label{puts}
\IFRU{Компилятор заменил вызов \printf на \TT{puts()}. 
Действительно, \printf с одним агрументом это почти аналог \TT{puts()}.}
{GCC replaced first \printf call to \TT{puts()}. 
Indeed: \printf with only sole argument is almost analogous to \TT{puts()}.} 

\IFRU{\IT{Почти}, если принять условие что в строке не будет управляющих символов \printf 
начинающихся со знака процента. Тогда эффект от работы этих двух функций будет разным.}
{\IT{Almost}, because we need to be sure that this string will not contain printf-control 
statements starting with \IT{\%}: then effect of these two functions will be different.}

\IFRU{Зачем компилятор заменил один вызов на другой? Потому что \TT{puts()} работает быстрее}
{Why compiler replaced \printf to \TT{puts}? Because \TT{puts()} work faster}
\footnote{\url{http://www.ciselant.de/projects/gcc_printf/gcc_printf.html}}. 

\IFRU{Видимо потому, что puts() проталкивает символы в stdout не сравнивая каждый со знаком процента.}
{puts() working faster because it just passes characters to stdout not comparing each with \IT{\%} symbol.}

Далее уже знакомая инструкция \TT{''MOV R0, \#0''}, служащая для установки в 0 возвращаемого значения функции.

\subsubsection{Optimizing Xcode: режим thumb-2}

По умолчанию, Xcode 4.6.3 генерирует код для режима thumb-2, примерно в таком духе:

\begin{lstlisting}
__text:00002B6C                   _hello_world
__text:00002B6C 80 B5                             PUSH            {R7,LR}
__text:00002B6E 41 F2 D8 30                       MOVW            R0, #0x13D8
__text:00002B72 6F 46                             MOV             R7, SP
__text:00002B74 C0 F2 00 00                       MOVT.W          R0, #0
__text:00002B78 78 44                             ADD             R0, PC
__text:00002B7A 01 F0 38 EA                       BLX             _puts
__text:00002B7E 00 20                             MOVS            R0, #0
__text:00002B80 80 BD                             POP             {R7,PC}

...

__cstring:00003E70 48 65 6C 6C 6F 20+aHelloWorld     DCB "Hello world!",0xA,0
\end{lstlisting}

Разница от обычного thumb-кода в том что здесь добавлены новые инструкции, которые кодируются следующим образом:
инструкции \TT{BL}, \TT{BLX}, как мы помним, обычно кодируются как пара 16-битных инструкций, 
а в thumb-2 эти опкоды \IT{суррогатные} опкоды расширены так, что новые инструкции кодируются здесь как 
32-битные инструкции.

Такая инструкция например \TT{''MOVW R0, \#0x13D8''} ~--- она записывает 16-битное число в 
младшую часть регистра \TT{R0}.

Еще \TT{''MOVT.W R0, \#0''} ~--- эта инструкция работает так же как и \TT{MOVT} из предыдущего примера, 
но она работает в thumb-2.

Помимо прочих отличий, здесь используется инструкция BLX вместо BL. Отличие в том, что помимо сохранения адреса
возврата в регистре LR и передаче управления в функцию puts(), происходит смена режима процессора с thumb на ARM,
либо наоборот.
Здесь это нужно потому что инструкция, куда ведет переход, выглядит так:

\begin{lstlisting}
__symbolstub1:00003FEC _puts           ; CODE XREF: _hello_world+E
__symbolstub1:00003FEC 44 F0 9F E5     LDR  PC, =__imp__puts
\end{lstlisting}

Итак, внимательный читатель может задать справделивый вопрос: почему бы не вызывать \TT{puts()} сразу в том же коде,
где он нужен? Это не очень выгодно (в плане экономия места) и вот почему. 

Практически любая программа использует внешние динамические библиотеки, будь то DLL в Windows, .so в *NIX либо .dylib в Mac OS X. В динамических библиотеках
находятся часто используемые библиотечные вызовы, в том числе стандартная функция Си \TT{puts()}. 

В бинарном файле (Windows PE .exe, ELF либо Mach-O) имеется секция импортов, список символов (функций либо глобальных переменных) импортируемых из внешних модулей, а также названия самих модулей. 

Загрузчик операционной системы загружает необходимые модули и, перебирая импортируемые символы в основном модуле, проставляет правильные адреса каждого символа.

В нашем случае, \IT{\_\_imp\_\_puts} это 32-битная переменная, куда загрузчик ОС запишет правильный адрес этой же функции во внешней библиотеке. Так что инструкция \TT{LDR} просто берет 32-битное значение из этой переменной и, записывая его в регистр \TT{PC}, просто передает туда управление. 

Чтобы уменьшить время работы загрузчика ОС, нужно чтобы ему пришлось записать адрес каждого символа только один раз,в соответствующее для них место.

К тому же, как мы уже убедились, нельзя одной инструкцией загрузить в регистр 32-битное число.
Так что, наиболее оптимально, выделить отдельную функцию, работающую в режиме ARM, чья цель ~--- передавать
управление дальше, в динамическую библиотеку, и ссылаться на нее из thumb-кода.

Кстати, в предыдущем примере (скомпилированном для режима ARM), переход при помощи инструкции \TT{BL} ведет 
на такую же thunk-функцию, однако режим процессора не переключается.

