%NOTTRANSLATED
\subsection{ARM}

\subsubsection{\OptimizingKeil + режим ARM}

\lstinputlisting{jcc/ARM_O3_signed.asm}

Многие инструкции в режиме ARM могут быть исполнены только при некоторых выставленных флагах.
Это нередко используется для сравнения чисел, например.

К примеру, инструкция \TT{``ADD''} на самом деле может быть представлена как \TT{``ADDAL''}, \TT{AL} означает 
\IT{Always}, то есть, исполнять всегда. Предикаты кодируются в 4-х старших битах инструкции 32-битных ARM-инструкций
(\IT{condition field}).
Инструкция безусловного перехода \TT{B}, на самом деле условная и кодируется так же как и прочие инструкции условных
переходов, но имеет \TT{AL} в \IT{condition field}, то есть, исполняется всегда, не обращая внимания на флаги.

Инструкция \TT{``ADRGT''} работает так же как и ADR, но только в случае если предыдущая инструкция CMP,
сравнивая два числа, обнаружила что одно из них больше второго (Greater Than).

Следующая инструкция \TT{``BLGT''} ведет себя так же как и \TT{``BL''} и сработает только если 
результат сравнения был такой же (Greater Than). \TT{``ADRGT''} записывает в R0 указатель на строку 
\TT{``a>b\textbackslash{}n''},
а \TT{``BLGT''} вызывает \printf. Следовательно, эти инструкции исполнятся только в том случае, если значение
в R0 (там a) было больше чем R4 (там b). 

Далее мы увидим инструкции \TT{ADREQ} и \TT{BLEQ}. Они работают так же как и \TT{ADR} и \TT{BL}, 
но исполнятся только в случае если
значения при сравнении были равны. Перед ними еще один \CMP (ведь вызов \printf мог испортить состояние флагов).

Далее мы увидим \TT{LDMGEFD}, эта инструкция работает так же как и \TT{LDMFD}, но сработает только в случае если 
в результате сравнения одно из значений было больше или равно второму (\IT{Greater or Equal}).

Смысл инструкции \TT{``LDMGEFD SP!, \{R4-R6,PC\}''} в том, что это как бы эпилог функции, но он сработает только
если $a>=b$, тогда работа функции закончится. 
Но если это не так, то есть $a<b$, то исполнение дойдет до следующей инструкции 
\TT{``LDMFD SP!, \{R4-R6,LR\}''}, это еще один эпилог функции, эта инструкция восстанавливает состояние регистров
\TT{R4-R6}, но и \LR вместо \PC, таким образом, пока что не делая возврата из функции. 
Последние две инструкции вызывают
\printf со строкой <<a<b\textbackslash{}n>> в качестве единственного аргумента. Безусловный переход на \printf вместо возврата
из функции, это то что мы уже рассматривали в секции <<\PrintfSeveralArgumentsSectionName>>, 
здесь~\ref{ARM_B_to_printf}.

Функция \TT{f\_unsigned} точно такая же, но там используются инструкции \TT{ADRHI}, \TT{BLHI}, 
и \TT{LDMCSFD} для сравнения,
эти предикаты (\IT{HI = Unsigned higher, CS = Carry Set (greater than or equal)}) аналогичны рассмотренным,
но служат для работы с беззнаковыми значениями.

В функции \main ничего для нас нового нет:

\lstinputlisting{jcc/ARM_O3_main.asm}

Так, в режиме ARM можно обойтись без условных переходов.

Почему это хорошо? Потому что ARM это RISC-процессор имеющий конвеер (pipeline) для исполнения инструкций. 
Если говорить 
коротко, то процессору с конвеером тяжело даются переходы вообще, поэтому есть спрос на возможность 
предсказывания переходов.
Очень хорошо если программа имеют как можно меньшее переходов, как условных, так и безусловных, поэтому, 
инструкции с добавленными предикатами, указывающими,
исполнять инструкцию или нет, могут избавить от некоторого количества условных переходов.

В x86 нет аналогичной возможности, если не считать инструкцию \TT{CMOVcc}, это то же что и \MOV, но она срабатывает
только при определенных выставленных флагах, обычно, выставленных при помощи \CMP.

\subsubsection{\OptimizingKeil + режим thumb}

\lstinputlisting{jcc/ARM_thumb_signed.asm}

В режиме thumb далеко не все инструкции могут быть дополнены условием исполнения (condition code), так что,
код для режима thumb выглядит привычнее.

BLE это обычный переход с условием \IT{Less than or Equal}, BNE - \IT{Not Equal}, BGE - \IT{Greater than or Equal}.

Функция \TT{f\_unsigned} точно такая же, но для работы с беззнаковыми величинами, там используются 
инструкции \TT{BLS} (\IT{Unsigned lower or same}) и \TT{BCS} (\IT{Carry Set (Greater than ir equal)}).

