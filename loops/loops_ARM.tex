\subsection{ARM}

\subsubsection{\NonOptimizingKeil + режим ARM}

\lstinputlisting{loops/Keil_ARM_O0.asm}

Счетчик итераций \TT{i} будет храниться в регистре \TT{R4}.

Инструкция \TT{``MOV R4, \#2''} просто инициализирует \IT{i}.

Инструкции \TT{``MOV R0, R4''} и \TT{``BL f''} составляют тело цикла, первая инструкция готовит аргумент для
функции f и вторая собственно вызывает её.

Инструкция \TT{``ADD R4, R4, \#1''} прибавляет единицу к \IT{i} при каждой итерации.

\TT{``CMP R4, \#0xA''} сравнивает \TT{i} с $0xA$ ($10$). Следующая за ней инструкция \TT{BLT} 
(\IT{Branch Less Than}) совершит переход, если \IT{i} меньше чем $10$.

В противном случае, в \TT{R0} запишется $0$ (потому что наша функция возвращает 0) и произойдет выход из функции.

\subsubsection{\OptimizingKeil + режим thumb}

\lstinputlisting{loops/Keil_thumb_O3.asm}

Практически, всё то же самое.

\subsubsection{\OptimizingXcode + режим thumb}

\lstinputlisting{loops/xcode_thumb_O3.asm}

На самом деле, в моей функции f было такое:

\begin{lstlisting}
void f(int i)
{
    // do something here
    printf ("%d\n", i);
};
\end{lstlisting}

Так что, LLVM не только \IT{развернул} цикл, но также и представил мою очень простую функцию \TT{f} как inline-вую,
и вставил её тело вместо цикла 8 раз. Это возможно когда функция очень простая, как та что у меня, и когда
она вызывается не очень много раз, как здесь.

