\chapter{\IFRU{Паттерны компиляторов}{Compiler's patterns}}

\IFRU
{Когда я учил Си, а затем Си++, я просто писал небольшие фрагменты кода, компилировал и смотрел что 
получилось на ассемблере. Так намного проще было понять. Я делал это такое количество раз, 
что связь между кодом на \CCpp и тем что генерирует компилятор вбилась мне в подсознание достаточно 
глубоко, поэтому я могу глядя на код на ассемблере сразу понимать, в общих чертах, что там было написано 
на Си. Возможно это поможет кому-то еще, попробую описать некоторые примеры.}
{When I first learned C and then C++ I was just writing small pieces of code, compiling it, 
and seeing what 
was produced in assembly language. That was easy for me. I did it many times and the relation 
between \CCpp code and what the compiler produced was imprinted in my mind so deep that 
I can quickly understand what was in C code when I look at produced x86 code. 
Perhaps this method may be helpful for someone else so I will try to describe some examples here.}

\input{01_helloworld/hw}
\input{02_stack/stack}
\input{03_printf/printf}
\input{04_scanf/scanf}
\input{05_passing_arguments/passing_arguments}
\input{06_return_results/return_results}
\input{061_pointers/ptrs_and_refs}
\input{07_jcc/jcc}
\input{08_switch/switch}
\input{09_loops/loops}
\input{10_strlen/strlen}
\input{11_division_by_9/division_by_9}
\input{12_FPU/FPU}
\input{13_arrays/arrays}
\input{14_bitfields/bitfields}
\input{15_structs/structs}
\input{16_classes/classes}
\input{16_classes/classes_1_inheritance}
\input{16_classes/classes_2_encapsulation}
\input{16_classes/classes_3_mutiple}
\input{16_classes/classes_4_virtual}
\input{17_unions/unions}
\input{18_pointers_to_functions/pointers_to_functions}
\input{19_SIMD/SIMD}
\input{20_x64/x64}
\input{21_C99_restrict/restrict}
\input{22_inline_function/inline}
