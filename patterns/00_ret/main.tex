\chapter{\RU{Простейшая функция}\EN{Simplest possible function}}

\RU{Наверное, простейшая из возможных функций это та что возвращает некоторую константу.}
\EN{Probably the simplest possible function is that one which just returns some constant value.}

\RU{Вот, например}\EN{Here it is}:

\lstinputlisting{patterns/00_ret/1.c}

\section{x86}

\RU{И вот что делает оптимизирующий GCC}\EN{And that's what the optimizing GCC compiler produces}:

\lstinputlisting[caption=\Optimizing GCC]{patterns/00_ret/1.s}

\RU{Результат работы MSVC точно такой же}\EN{MSVC's result is exactly the same}.

\index{x86!\Instructions!RET}
\RU{Здесь только две инструкции: первая помещает значение 123 в регистр \EAX, который используется
для передачи возвращаемых значений и вторая это \RET, которая возвращает управление в вызывающую ф-цию.}
\EN{There are just two instructions: the first places the value 123 into the \EAX register, which is used by convention for storing the return
value and the second one is \RET, which returns execution to the \gls{caller}.}
\RU{Вызывающая ф-ция возьмет результат из регистра \EAX}\EN{The caller will take the result from the \EAX register}.

\ifdefined\IncludeARM
\section{ARM}

\RU{А что насчет}\EN{What about} ARM?

\lstinputlisting[caption=\OptimizingKeilVI (\ARMMode)]{patterns/00_ret/1_Keil_ARM_O3.s}

\RU{ARM использует регистр \Reg{0} для возврата значений, так что здесь 123 помещается в \Reg{0}.}
\EN{ARM uses register \Reg{0} for returning results, so 123 is stored into \Reg{0} here.}

\RU{Адрес возврата (\ac{RA}) в ARM не сохраняется в локальном стеке, а в регистре \ac{LR}.}
\EN{The return address (\ac{RA}) is not saved on the local stack in ARM, but rather in the \ac{LR} register.}
\RU{Так что инструкция \TT{BX LR} делает переход по этому адресу, и это то же самое что и вернуть управление
в вызывающую ф-цию.}
\EN{So the \TT{BX LR} instruction is jumping to that address, effectively, returning execution to the \gls{caller}.}
\fi

\index{ARM!\Instructions!MOV}
\index{x86!\Instructions!MOV}
\RU{Нужно отметить, что название инструкции \MOV в x86 и ARM сбивает с толку.}
\EN{It should be noted that \MOV is a confusing name for the instruction in both x86 and ARM \ac{ISA}s. }
\RU{На самом деле, данные не \IT{перемещаются}, а скорее \IT{копируются}.}
\EN{In fact, data is not \IT{moved}, it's rather \IT{copied}.}

\ifdefined\IncludeMIPS
\section{MIPS}

\label{MIPS_leaf_function_ex1}
\RU{Есть два способа называть регистры в мире MIPS.}
\EN{There are two ways of registers naming that are used in the MIPS world.}
\RU{По номеру (от \$0 до \$31) или по псевдоимени (\$V0, \$A0, и т.д.).}
\EN{By number (from \$0 to \$31) or by pseudoname (\$V0, \$A0, etc).}
\RU{Вывод на ассемблере в GCC показывает регистры по номерам:}
\EN{Assembly output generated by GCC shows registers by number:}

\lstinputlisting[caption=\Optimizing GCC 4.4.5 (\assemblyOutput)]{patterns/00_ret/MIPS.s}

\dots \RU{а IDA --- по псевдоименам}\EN{while IDA --- by pseudoname}:

\lstinputlisting[caption=\Optimizing GCC 4.4.5 (IDA)]{patterns/00_ret/MIPS_IDA.lst}

\RU{Так что регистр \$2 (или \$V0) используется для возврата значений.}
\EN{So the \$2 (or \$V0) register is used to store the function result.}
\index{MIPS!\Pseudoinstructions!LI}
LI \RU{это}\EN{is} ``Load Immediate''.

\index{MIPS!\Instructions!J}
\RU{Другая инструкция это инструкция перехода (J или JR), которая возвращает управление в 
\glslink{caller}{вызывающую ф-цию}, переходя по адресу в регистре \$31 (или \$RA).}
\EN{The other instruction is jump instruction (J or JR) which returns execution flow to the \gls{caller},
jumping to the address in \$31 (or \$RA) register.}
\RU{Это аналог регистра \ac{LR} в ARM.}
\EN{This is the register analogous to \ac{LR} in ARM.}

\RU{Но почему инструкция загрузки (LI) и инструкция перехода (J или JR) поменены местами?}
\EN{But why the load instruction (LI) and the jump instruction (J or JR) are swapped?}
\index{MIPS!Branch delay slot}
\RU{Это артефакт \ac{RISC} и называется он}
\EN{This is merely \ac{RISC} feature called} ``branch delay slot''.
\RU{На самом деле, нам не нужно вникать в эти детали}\EN{We don't need to get into details here.}.
\RU{Нужно просто запомнить: в MIPS инструкция после инструкции перехода исполняется \IT{перед} 
инструкцией перехода.}
\EN{We should just remember that: in MIPS, the instruction following jump or branch instruction
is executed \IT{before} the jump/brunch instruction itslef.}
\RU{Таким образом, инструкция перехода всегда поменена местами с той, которая должна быть исполнена перед ней.}
\EN{Hence, branch instruction always swap place with the instruction, which must be executed beforehand.}
% A footnote/link to http://en.wikipedia.org/wiki/Delay_slot#Branch_delay_slots or
% something similar might be useful for the people more interested in it.

\subsection{\RU{Еще кое-что об именах инструкций и регистров в MIPS}\EN{Note about MIPS instruction/register names}}

\RU{Имена регистров и инструкций в мире MIPS традиционно пишутся в нижнем регистре.}
\EN{Register names and instruction names in MIPS world are traditionally written in lowercase.}
\RU{Но я решил использовать верхний регистр, потому что имена инструкций и регистров других \ac{ISA}
в этой книге так же в верхнем регистре.}
\EN{But I've decided to stick to uppercase, because the instruction and register names of other \ac{ISA}s
are all written in uppercase in this book.}

\fi
