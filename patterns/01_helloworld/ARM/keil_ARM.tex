\subsection{\NonOptimizingKeilVI (\ARMMode)}

\RU{Для начала скомпилируем наш пример в Keil}\EN{Let's start by compiling our example in Keil}\ITA{Iniziamo a compilare il nostro esempio in Keil}:

\begin{lstlisting}
armcc.exe --arm --c90 -O0 1.c 
\end{lstlisting}

\index{\IntelSyntax}
\RU{Компилятор \IT{armcc} генерирует листинг на ассемблере в формате Intel.}
\EN{The \IT{armcc} compiler produces assembly listings in Intel-syntax}
\ITA{Il compilatore \IT{armcc} produce un listato assembly con sintassi Intel} 
\RU{Этот листинг содержит некоторые высокоуровневые макросы, связанные с ARM}%
\EN{but it has high-level ARM-processor related macros}\ITA{e utilizza macro di alto livello legate al processore ARM}\footnote{
\RU{например, он показывает инструкции \PUSH/\POP, отсутствующие в режиме ARM}
\EN{e.g. ARM mode lacks \PUSH/\POP instructions}\ITA{ad esempio, l' ARM mode 'e privo delle istruzioni \PUSH/\POP}}, 
\RU{а нам важнее увидеть инструкции \q{как есть}, так что посмотрим скомпилированный результат в \IDA.}
\EN{but it is more important for us to see the instructions \q{as is} so let's see the compiled result in \IDA.}
\ITA{tuttavia e' piu' importante per noi vedere le istruzioni \q{cosi' come sono}, quindi guardiamo il risultato compilato con \IDA.}

\begin{lstlisting}[caption=\NonOptimizingKeilVI (\ARMMode) \IDA]
.text:00000000             main
.text:00000000 10 40 2D E9    STMFD   SP!, {R4,LR}
.text:00000004 1E 0E 8F E2    ADR     R0, aHelloWorld ; "hello, world"
.text:00000008 15 19 00 EB    BL      __2printf
.text:0000000C 00 00 A0 E3    MOV     R0, #0
.text:00000010 10 80 BD E8    LDMFD   SP!, {R4,PC}

.text:000001EC 68 65 6C 6C+aHelloWorld  DCB "hello, world",0    ; DATA XREF: main+4
\end{lstlisting}

\RU{В вышеприведённом примере можно легко увидеть, что каждая инструкция имеет размер 4 байта.}
\EN{In the example, we can easily see each instruction has a size of 4 bytes.}
\ITA{Nell'esempio possiamo facilmente vedere che ogni istruzione ha lunghezza pari a 4 byte.}
\RU{Действительно, ведь мы же компилировали наш код для режима ARM, а не Thumb.}
\EN{Indeed, we compiled our code for ARM mode, not for Thumb.}
\ITA{Difatti abbiamo compilato il codice per la modalita' ARM e non Thumb.}

\index{ARM!\Instructions!STMFD}
\index{ARM!\Instructions!POP}
\RU{Самая первая инструкция}\EN{The very first instruction}\ITA{La prima istruzione}, \TT{STMFD SP!, \{R4,LR\}}\footnote{\ac{STMFD}}, 
\RU{работает как инструкция}\EN{works as an x86}\ITA{funzione come l' istruzione } \PUSH \RU{в x86}\EN{instruction}\ITA{in x86},
\RU{записывая значения двух регистров}\EN{writing the values of two registers}\ITA{scrivendo i valori di due registri}
(\Reg{4} \AndENRU \ac{LR}) \RU{в стек}\EN{into the stack}\ITA{nello stack}.
\RU{Действительно, в выдаваемом листинге на ассемблере компилятор \IT{armcc} для упрощения указывает здесь инструкцию}
\EN{Indeed, in the output listing from the \IT{armcc} compiler, for the sake of simplification, 
actually shows the}\ITA{Infatti il listato di output prodotto dal compilatore \IT{armcc}, per semplificazione, mostra 
l'istruzione} \TT{PUSH \{r4,lr\}}\EN{ instruction}.
\RU{Но это не совсем точно, инструкция \PUSH доступна только в режиме Thumb, поэтому,
во избежание путаницы, я предложил работать в \IDA}%
\EN{But that is not quite precise. The \PUSH instruction is only available in Thumb mode.
So, to make things less confusing, we're doing this in \IDA}\ITA{Ma cio' non e' del tutto esatto. L'istruzione\PUSH e' disponibile solo in modalita' Thumb. Utilizziamo quindi \IDA per non fare confusione}.

\RU{Итак, эта инструкция уменьшает \ac{SP}, чтобы он указывал на место в стеке, свободное для записи
новых значений, затем записывает значения регистров \Reg{4} и \ac{LR} 
по адресу в памяти, на который указывает измененный регистр \ac{SP}}%
\EN{This instruction first \glspl{decrement} the \ac{SP} so it points to the place in the stack
that is free for new entries, then it saves the values of the \Reg{4} and \ac{LR} registers at the address
stored in the modified \ac{SP}}\ITA{Questa istruzione dapprima \glspl{decrementa} il valore di \ac{SP} cosi' da farlo puntare alla porzione dello stack che' e' libera di ospitare nuovi dati, quindi salva il valore dei registri \Reg{4} e \ac{LR} all'indirizzo memorizzato nel registro \ac{SP} appena modificato}.

\RU{Эта инструкция, как и инструкция \PUSH в режиме Thumb, может сохранить в стеке одновременно несколько значений регистров, что может быть очень удобно}%
\EN{This instruction (like the \PUSH instruction in Thumb mode) is able to save several register values at once which can be very useful}
\ITA{Questa istruzione (esattamente come \PUSH in Thumb mode) e' in grado di salvare il valore di piu' registri contemporaneamente, cosa che e' puo' risultare molto utile}. 
\RU{Кстати, такого в x86 нет}\EN{By the way, this has no equivalent in x86}\ITA{A proposito, non ha un equivalente in x86}.
\RU{Также следует заметить, что \TT{STMFD}~--- генерализация инструкции \PUSH (то есть расширяет её возможности), потому что может работать с любым регистром, а не только с \ac{SP}.}
\EN{It can also be noted that the \TT{STMFD} instruction is a generalization 
of the \PUSH instruction (extending its features), since it can work with any register, not just with \ac{SP}.}
\ITA{Si puo' notare anche che l'istruzione \TT{STMFD} e' una generalizzazione dell'istruzione \PUSH (che estende le sue funzionalita'), poiche' puo' funzionare con qualunque registro, e non solo \ac{SP}.}
\RU{Другими словами, \TT{STMFD} можно использовать для записи набора регистров в указанном месте памяти.}
\EN{In other words, \TT{STMFD} may be used for storing a set of registers at the specified memory address.}
\ITA{In altre parole, \TT{STMFD} puo' essere usata per memorizzare un insieme di registri all'indirizzo di memoria specificato.}

\index{\PICcode}
\index{ARM!\Instructions!ADR}
\RU{Инструкция}\EN{The}\ITA{L'istruzione} \TT{ADR R0, aHelloWorld}
\RU{прибавляет или отнимает значение регистра \ac{PC} к смещению, где хранится строка}
\EN{instruction adds or subtracts the value in the \ac{PC} register to the offset where the}
\ITA{aggiunge o sottrae il valore nel registro \ac{PC} all'offset dove e' memorizzata la stringa }
\TT{hello, world}\EN{ string is located}.
\RU{Причем здесь \ac{PC}, можно спросить}\EN{How is the \TT{PC} register used here, one might ask}\ITA{Ci si potrebbe chiedere, come e' utilizzato qui il registro \TT{PC}}?
\RU{Притом, что это так называемый \q{\PICcode}}\EN{This is called \q{\PICcode}.}\ITA{Cio' e' detto \q{\PICcode}.}
\footnote{
	\RU{Читайте больше об этом в соответствующем разделе}
	\EN{Read more about it in relevant section}~(\myref{sec:PIC})
	\ITA{Maggiori informazioni sono fornite nella sezione}~(\myref{sec:PIC})
	}
\RU{он предназначен для исполнения будучи не привязанным к каким-либо адресам в памяти}%
\EN{Such code can be be executed at a non-fixed address in memory}.
\ITA{Questo tipo di codice puo' essere eseguito a indirizzi non fissi (variabili)in memoria}.
\EN{In other words, this is \ac{PC}-relative addressing.}
\ITA{In altre parole, e' un indirizzamento relativo a \ac{PC} (\ac{PC}-relative addressing).}
\RU{Другими словами, это относительная от \ac{PC} адресация.}
\RU{В опкоде инструкции \TT{ADR} указывается разница между адресом этой инструкции и местом, где хранится строка}%
\EN{The \TT{ADR} instruction takes into account the difference between the address of this instruction and the address where the string is located}
\ITA{L'istruzione \TT{ADR} tiene conto della differenza tra l'indirizzo di questa istruzione e l'indirizzo dove si trova la stringa}.
\RU{Эта разница всегда будет постоянной, вне зависимости от того, куда был загружен \ac{OS} наш код}%
\EN{This difference (offset) is always to be the same, no matter at what address our code is loaded by the \ac{OS}}
\ITA{Questa differenza (offset) sara' sempre la stessa, a prescindere dall'indirizzo in cui nostro codice sara' caricato dall'\ac{OS}}.
\RU{Поэтому всё, что нужно~--- это прибавить адрес текущей инструкции (из \ac{PC}), чтобы получить текущий абсолютный адрес нашей Си-строки}%
\EN{That's why all we need is to add the address of the current instruction (from \ac{PC}) in order to get the absolute memory address of our C-string}
\ITA{Cio' spiega perche' bisogna soltanto aggiungere l'indirizzo dell'istruzione corrente (from \ac{PC}) per ottenere l'indirizzo assoluto in memoria della nostra stringa C}.

\index{ARM!\Registers!Link Register}
\index{ARM!\Instructions!BL}
\RU{Инструкция}\ITA{L'istruzione} \TT{BL \_\_2printf}\footnote{Branch with Link}
\RU{вызывает функцию \printf}\EN{instruction calls the \printf function}\ITA{chiama la funzione \printf}. 
\RU{Работа этой инструкции состоит из двух фаз}%
\EN{Here's how this instruction works}\EN{Questa istruzione funziona cosi'}: 
\begin{itemize}
\item
\RU{записать адрес после инструкции \TT{BL} (\TT{0xC}) в регистр \ac{LR}}%
\EN{store the address following the \TT{BL} instruction (\TT{0xC}) into the \ac{LR}}
\ITA{memorizza l'indirizzo successivo all'istruzione \TT{BL} (\TT{0xC}) nel registro \ac{LR}};
\item
\RU{передать управление в \printf, записав адрес этой функции в регистр \ac{PC}}%
\EN{then pass the control to \printf by writing its address into the \ac{PC} register}
\ITA{quindi passa il controllo a \printf scrivendo il suo indirizzo nel registro \ac{PC}}.
\end{itemize}

\RU{Ведь когда функция \printf закончит работу, нужно знать, куда вернуть управление, поэтому закончив работу, всякая функция передает управление по адресу, записанному в регистре \ac{LR}}%
\EN{When \printf finishes its execution it must have information about where it needs to return the control to.
That's why each function passes control to the address stored in the \ac{LR} register}
\ITA{Quando la funzione \printf termina la sua esecuzione, deve sapere a chi restituire il controllo (dove ritornare). Per questo motivo ogni funzione passa il controllo all'indirizzo memorizzato nel registro \ac{LR}}.

\RU{В этом разница между \q{чистыми} \ac{RISC}-процессорами вроде ARM и \ac{CISC}-процессорами как x86,
где адрес возврата обычно записывается в стек}%
\EN{That is a difference between \q{pure} \ac{RISC}-processors like ARM and \ac{CISC}-processors like x86,
where the return address is usually stored on the stack}\ITA{Questa e' una differenza tra processori \ac{RISC} \q{puri} come ARM e processori simili a \ac{CISC} come x86, nei quali il return address e' solitamente memorizzato nello stack}\footnote{\RU{Подробнее об этом будет описано в следующей главе}\EN{Read more about this in next section}\ITA{Maggiori informazioni si trovano nella prossima sezione}~(\myref{sec:stack})}.

\RU{Кстати, 32-битный абсолютный адрес (либо смещение) невозможно закодировать в 32-битной инструкции \TT{BL}, в ней есть место только для 24-х бит}%
\EN{By the way, an absolute 32-bit address or offset cannot be encoded in the 32-bit \TT{BL} instruction because
it only has space for 24 bits}
\ITA{A proposito, un indirizzo assoluto o un offset a 32-bit non puo' essere codificato nell'istruzione a 32-bit \TT{BL} poiche' ha solo spazio per 24 bit}.
\RU{Поскольку все инструкции в режиме ARM имеют длину 4 байта (32 бита) и инструкции могут находится только по адресам кратным 4, то последние 2 бита (всегда нулевых) можно не кодировать.}
\EN{As we may remember, all ARM-mode instructions have a size of 4 bytes (32 bits).
Hence, they can only be located on 4-byte boundary addresses.
This implies that the last 2 bits of the instruction address (which are always zero bits) may be omitted.}
\ITA{Come potremmo ricordare, tutte le istruzioni in ARM-mode hanno dimensione fissa di 4 byte (32 bit).
Dunque possono essere collocate solo su indirizzi allineati a 4-byte.
Cio' implica che gli ultimi 2 bits dell'indirizzo dell'istruzione (che sono sempre zero) possono essere omessi.}
\RU{В итоге имеем 26 бит, при помощи которых можно закодировать}
\EN{In summary, we have 26 bits for offset encoding. This is enough to encode}\ITA{Abbiamo in definitiva 26 bit per la codifica dell'offset (offset encoding). E cio e' sufficiente per codificare} $current\_PC \pm{} \approx{}32M$.


\index{ARM!\Instructions!MOV}
\RU{Следующая инструкция}\EN{Next, the}\ITA{L'istruzione successiva,} \TT{MOV R0, \#0}\footnote{MOVe}
\RU{просто записывает 0 в регистр \Reg{0}}\EN{instruction just writes 0 into the \Reg{0} register}\ITA{scrive soltanto 0 nel registro \Reg{0}}.
\RU{Ведь наша Си-функция возвращает 0, а возвращаемое значение всякая функция оставляет в \Reg{0}}%
\ITA{Questo succede perche' la nostra funzione C restituisce 0, ed il valore di ritorno deve essere memorizzato nel registro \Reg{0}}
\EN{That's because our C-function returns 0 and the return value is to be placed in the \Reg{0} register}.

\index{ARM!\Registers!Link Register}
\index{ARM!\Instructions!LDMFD}
\index{ARM!\Instructions!POP}
\RU{Последняя инструкция}\EN{The last instruction}\ITA{L'ultima istruzione} \TT{LDMFD SP!, {R4,PC}}\footnote{\ac{LDMFD}}\RU{~--- это инструкция, обратная}\EN{ is an inverse instruction of}\ITA{ e' l'istruzione inversa rispetto a } \TT{STMFD}. 
\RU{Она загружает из стека (или любого другого места в памяти) значения для сохранения их в \Reg{4} и \ac{PC}, увеличивая \glslink{stack pointer}{указатель стека} \ac{SP}.}
\EN{It loads values from the stack (or any other memory place) in order to save them into \Reg{4} and \ac{PC}, and \glslink{increment}{increments} the \gls{stack pointer} \ac{SP}.}
\ITA{Carica i valori dallo stack (o qualunque altra zona di memoria) per salvarli nei registri \Reg{4} e \ac{PC}, e \glslink{incrementa}{incrementa} lo \gls{stack pointer} \ac{SP}.}
\RU{Здесь она работает как аналог \POP}\EN{It works like \POP here}\ITA{In questo caso funziona come \POP}.\\
N.B. \RU{Самая первая инструкция \TT{STMFD} сохранила в стеке \Reg{4} и \ac{LR}, а \IT{восстанавливаются} во время исполнения \TT{LDMFD} регистры \Reg{4} и \ac{PC}}%
\EN{The very first instruction \TT{STMFD} saved the \Reg{4} and \ac{LR} registers pair on the stack, but \Reg{4} and \ac{PC} are \IT{restored} during the \TT{LDMFD} execution}
\ITA{La prima istruzione \TT{STMFD} aveva salvato la coppia di registri \Reg{4} e \ac{LR} sullo stack, ma \Reg{4} e \ac{PC} vengono \IT{ripristinati} durante l'esecuzione di \TT{LDMFD}}.

\RU{Как мы уже знаем, в регистре \ac{LR} обычно сохраняется адрес места, куда нужно всякой функции вернуть управление}%
\EN{As we already know, the address of the place where each function must return control to is usually saved in the \ac{LR} register}
\ITA{Come gia' sappiamo, l'indirizzo del posto a cui ogni funzione devere restituire il controllo e' solitamente salvato nel registro \ac{LR}}.
\RU{Самая первая инструкция сохраняет это значение в стеке, потому что наша функция \main позже будет сама пользоваться этим регистром в момент вызова \printf}%
\EN{The very first instruction saves its value in the stack because the same register will be used by our
\main function when calling \printf}
\ITA{La prima istruzione salva il suo valore nello stack perche' lo stesso registro sara' usato dalla nostra funzione \main per la chiamata a \printf}.
\RU{А затем, в конце функции, это значение можно сразу записать прямо в \ac{PC}, таким образом, передав управление туда, откуда была вызвана наша функция}%
\EN{In the function's end, this value can be written directly to the \ac{PC} register, thus passing control to where our function was called}
\ITA{Al termine della funzione, questo valore puo' essere scritto direttamente nel registro \ac{PC}, passando di fatti il controllo al punto in cui la nostra funzione era stata chiamata}.

\RU{Так как функция \main обычно самая главная в \CCpp, управление будет возвращено в загрузчик \ac{OS}, либо куда-то в \ac{CRT} 
или что-то в этом роде.}
\EN{Since \main is usually the primary function in \CCpp,
the control will be returned to the \ac{OS} loader or to a point in a \ac{CRT},
or something like that.}
\ITA{Dal momento che \main e' solitamente la funzione principale in \CCpp,
il controllo sara' restituito al loader dell' \ac{OS} oppure ad un punto in una \ac{CRT},
o qualcosa del genere.}

\EN{All that allows omitting the \TT{BX LR} instruction at the end of the function.}
\ITA{Tutto cio' consente di omettere l'istruzione \TT{BX LR} alla fine della funzione.}
\RU{Всё это позволяет избавиться от инструкции \TT{BX LR} в самом конце функции.}

\index{ARM!DCB}
\TT{DCB}\RU{~--- директива ассемблера, описывающая массивы байт или ASCII-строк, аналог директивы DB в 
x86-ассемблере}%
\EN{~is an assembly language directive defining an array of bytes or ASCII strings, akin to the DB directive 
in the x86-assembly language}
\ITA{~e' una direttiva assembly che definisce un array di byte o una stringa ASCII, analoga alla direttiva DB in linguaggio assembly x86}.

