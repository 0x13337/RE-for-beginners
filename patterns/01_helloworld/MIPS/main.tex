\ifx\RUSSIAN\undefined
\section{MIPS}

\subsection{Word about ``global pointer''}
\label{MIPS_GP}

\index{MIPS!Global pointer}
One important MIPS concept is ``global pointer''.
As we may already know, each MIPS instruction has size of 32 bits, so it's impossible to embed 32-bit
address into one instruction: pair should be used fo so (like GCC did in our example for the text string address
loading).

It's possible, however, to load data from the address in range of $register-32768...register+32767$ using one
single instruction (because 16 bit of signed offset could be encoded in single instruction).
So we can allocate some register for this purpose and also allocate 64KiB area of most used data.
Allocated register is called ``global pointer'' and it points to the middle of the 64KiB area.
This area usually contains global variables and addresses of imported functions like \printf, 
because GCC developers decided that getting address of some function must be as fast as single instruction
execution instead of two.
In ELF file, this 64KiB area is located partly in .sbss (``small \ac{BSS}'', for not initialized data) and 
.sdata (``small data'', for initialized data) sections.

This means, programmer may choose, what data he/she wants to be accessed fast and place them into .sdata/.sbss.

Some old-school programmers may recall MS-DOS memory model (\ref{8086_memory_model}) 
or MS-DOS memory managers like XMS/EMS where all memory was divided by 64KiB blocks.

\index{PowerPC}
This concept is not unique to MIPS. At least PowerPC uses this technique as well.

\subsection{\Optimizing GCC}

\lstinputlisting[caption=\Optimizing GCC 4.4.5 (\assemblyOutput),numbers=left]{patterns/01_helloworld/MIPS/hw_O3.s}

So the \$GP register is set in function prologue to equal to this area.
\ac{RA} register is also saved in the local stack.
\puts is also used here instead of \printf.
\index{MIPS!\Instructions!LW}
So address of \puts function is loaded into \$25 using LW instruction (``Load Word'').
\index{MIPS!\Instructions!LUI}
\index{MIPS!\Instructions!ADDIU}
Then address of the text string is loaded to \$4 using LUI (``Load Upper Immediate'') and 
ADDIU (``Add Immediate Unsigned Word'') instructions pair.
LUI sets high 16 bits of the register (hence ``upper'' word in instruction name) and ADDIU adds
lower 16 bits of the address.
ADDIU is coming after JALR (remember branch delay slots?).
The register \$4 is also called \$A0, which is used for passing first function argument
\footnote{MIPS registers table is available in the appendix: \ref{MIPS_registers_ref}}.

\index{MIPS!\Instructions!JALR}
JALR (``Jump and Link Register'') jumps to the address in \$25 register (address of \puts is there) while saving
address of the next instruction (LW) in \ac{RA}.
This is very similar to ARM.
Oh, and one important thing is that address saved in \ac{RA} is not address of the next instruction (because,
it's delay slot and is executed before jump instruction),
but address of the instruction after the next one (after delay slot).
Hence, $PC + 8$ is written to \ac{RA} during execution of \TT{JALR}, in our case, this is address of the LW
instruction next to ADDIU.

LW (``Load Word'') at line 19 restores \ac{RA} from the local stack 
(this instruction is rather part of function epilogue).

\index{MIPS!\Pseudoinstructions!MOVE}
MOVE at line 22 copies value from \$0 (\$ZERO) register to \$2 (\$V0). 
The MIPS has a \IT{constant} register which always holds zero.
Apparently, MIPS developers came with idea that zero in fact is busiest constant in computer programming,
so let's use just \$0 register every time zero is needed.
Another interesting fact is that MIPS lacks instruction which transfers data between registers.
In fact, \TT{move dst, src} is \TT{add dst, src, \$zero} ($dst=src+0$), which does the same.
Apparently, MIPS developers wanted to have compact \ac{ISA} opcode table.
This is not mean actual addition happens at each MOVE instruction. 
Most likely, these patterns optimized by \ac{CPU} and \ac{ALU} is never used.

\index{MIPS!\Instructions!J}
J at line 24 jumps to address in \ac{RA}, which is effectively doing return from the function.
ADDIU after J is in fact executed before J (remember branch delay slots?) and is part of function epilogue.

Here is also listing generated by IDA. Each register here has its own pseudoname:

\lstinputlisting[caption=\Optimizing GCC 4.4.5 (IDA),numbers=left]{patterns/01_helloworld/MIPS/hw_O3_IDA.lst}

An instruction at line 15 saves GP value into local stack, and this instruction is mystically missing
from GCC output listing, maybe by error.
GP value should be saved indeed, because each function can use its own 64KiB data window.

The register which contain address of \puts called \$T9, because registers prefixed with T- are called
``temporaries'' and its contents may not be preserved.

\subsection{\NonOptimizing GCC}

\lstinputlisting[caption=\NonOptimizing GCC 4.4.5 (\assemblyOutput),numbers=left]{patterns/01_helloworld/MIPS/hw_O0.s}

\NonOptimizing GCC is more verbose.
We see here that FP register is used for stack frame.
We also see 3 \ac{NOP}s.
The second and third are came after branch instructions.

I guess (not sure, though), GCC compiler always add \ac{NOP}s (because of branch delay slots) after branch
instructions and then, if optimization is turned on, may elimiate them.
So they are left here.

Here is also IDA listing:

\lstinputlisting[caption=\NonOptimizing GCC 4.4.5 (IDA),numbers=left]{patterns/01_helloworld/MIPS/hw_O0_IDA.lst}

\index{MIPS!\Pseudoinstructions!LA}
Interestingly, IDA recognized LUI/ADDIU instructions pair and coalesce them into one 
LA (``Load Address'') pseudoinstruction at line 11.
We may also see that this pseudoinstruction has size of 8 bytes!
This is pseudoinstruction (or \IT{macro}) because it's not a real MIPS instruction, but rather
handy name for instruction pair.

\index{MIPS!\Pseudoinstructions!NOP}
\index{MIPS!\Instructions!OR}
Another thing is that IDA doesn't recognize \ac{NOP} instructions, so here are they at lines 16, 19 and 27.
It is \TT{OR \$AT, \$ZERO}. Essentially, this instruction applies OR operation to contents of \$AT register
with zero, which is, of course, idle instruction. 
MIPS, like many other \ac{ISA}s, doesn't have separate \ac{NOP} instruction.

\subsection{Role of stack frame in this example}

Address of the string is passed in register. 
Why to setup local stack anyway?
The reason of this lies in the fact that \ac{RA} and GP register's values should be saved (because \printf
is called), and local stack is used for it.
If this would be \gls{leaf function}, it's possible to get rid of function prologue and epilogue,
for example: \ref{MIPS_leaf_function_ex1}.

\subsection{\Optimizing GCC: load it into GDB}

\index{GDB}
\lstinputlisting[caption=sample GDB session]{patterns/01_helloworld/MIPS/O3_GDB.txt}

\fi
