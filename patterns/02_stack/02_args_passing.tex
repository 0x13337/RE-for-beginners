\subsubsection{\IFRU{Передача параметров для функции}{Passing function arguments}}

\IFRU{Самый распространенный способ передачи параметров в x86 называется}
{Most popular way to pass parameters in x86 is called} ``cdecl'':

\begin{lstlisting}
push arg3
push arg2
push arg1
call f
add esp, 4*3
\end{lstlisting}

\IFRU{Вызываемая функция получает свои параметры также через указатель стека.}
{\Gls{callee} functions get their arguments via the stack ponter.}

\IFRU{Следовательно, так будут расположены значения в стеке перед исполнением самой первой инструкции
ф-ции f():}
{Consequently, that is how values will be located in the stack before execution
of the very first instruction of f() function:}

\begin{itemize}
\item ESP\EMDASH\IFRU{адрес возврата}{return address}
\item ESP+4\EMDASH{}arg1
\item ESP+8\EMDASH{}arg2
\item ESP+0xC\EMDASH{}arg3
\end{itemize}

\IFRU{См. также в соответствующем разделе о других способах передачи аргументов через стек}
{See also the section about other calling conventions}~(\ref{sec:callingconventions}).

\IFRU{Важно отметить, что, в общем, никто не заставляет программистов передавать параметры именно через стек,
это не является требованием к исполняемому коду.}
{It is worth noting that no one obliges programmers to pass arguments through stack, it is not a requirement.}

\IFRU{Вы можете делать это совершенно иначе, не используя стек вообще.}
{One could implement any other method without using the stack at all.}

\IFRU{К примеру, можно выделять в \glslink{heap}{куче} место для аргументов, 
заполнять их и передавать в функцию указатель на это место через \EAX. И это вполне будет работать}
{For example, it is possible to allocate a space for arguments in the \gls{heap}, fill it and pass it to a function 
via a pointer to this block in the \EAX register. And this will work}
\footnote{\IFRU{Например, в книге Дональда Кнута ``Искусство программирования'', в разделе 1.4.1 
посвященном подпрограммам\cite[раздел 1.4.1]{Knuth:1998:ACP:521463}, 
мы можем прочитать о возможности располагать параметры для вызываемой подпрограммы после инструкции \JMP,
передающей управление подпрограмме. Кнут описывает что это было особенно удобно для компьютеров System/360.}
{For example, in the ``The Art of Computer Programming'' book by Donald Knuth, 
in section 1.4.1 dedicated to subroutines\cite[section 1.4.1]{Knuth:1998:ACP:521463},
we can read about one way to supply arguments to subroutine is simply to list them after the \JMP instruction
passing control to subroutine. Knuth writes this method was particularly convenient on System/360.}}.

\IFRU{Однако, так традиционно сложилось, что в x86 и ARM передача аргументов происходит именно через стек.}
{However, it is convenient tradition in x86 and ARM to use the stack for this.} \\
\\
\IFRU{Кстати, вызываемая ф-ция не имеет информации, сколько аргументов было ей было передано.}
{By the way, \gls{callee} function has not any information, how many arguments were passed.}
\IFRU{Функции Си с переменным количеством аргументов (как \printf) определяют их количество по 
спецификатором строки формата (начинающиеся со знака \%).}
{Functions with variable arguments count (like \printf) determines its count by specifiers
in format string (which begun with \% sign).}
\IFRU{Если написать что-то вроде}{If to write something like} 

\begin{lstlisting}
printf("%d %d %d", 1234);
\end{lstlisting}

\printf \IFRU{выведет 1234, затем еще два случайных числа, которые волею случая оказались в стеке рядом.}
{will dump 1234, and then also two random numbers, which were laying near it in the stack, by chance.}
\\
\IFRU{Вот почему не так уж и важно, как объявлять ф-цию \main}
{That's why it is not very important how to declare \main function}: \IFRU{как}{as} \main, 
\TT{main(int argc, char *argv[])} 
\IFRU{либо}{or} \TT{main(int argc, char *argv[], char *envp[])}.

\IFRU{В реальности, т.н. startup-код вызывает \main примерно так:}
{In fact, so called startup-code is calling \main roughly as:}

\begin{lstlisting}
push envp
push argv
push argc
call main
...
\end{lstlisting}

\IFRU{Если вы объявляете \main как \main без аргументов, они, тем не менее, присутствуют в стеке, но не используются.}
{If you'll declare \main as \main without arguments, they are, nevertheless, are still present in the stack, but
not used.}
\IFRU{Если вы объявите \main как}{If you declare \main as} \TT{main(int argc, char *argv[])}, 
\IFRU{вы будете использовать два аргумента, а третий останется для вашей ф-ции ``невидимым''.}
{you will use two arguments, and third will remain ``invisible'' for your function.}
\IFRU{Более того, можно даже объявить}{Even more than that, it is possible to declare} \TT{main(int argc)}, 
\IFRU{и это будет работать}{and it will work}.

