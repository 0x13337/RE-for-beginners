\subsection{Передача параметров функции}

Самый распространенный способ передачи параметров в x86 называется \q{cdecl}:

\begin{lstlisting}
push arg3
push arg2
push arg1
call f
add esp, 12 ; 4*3=12
\end{lstlisting}

Вызываемая функция получает свои параметры также через указатель стека.

Следовательно, так расположены значения в стеке перед исполнением самой первой инструкции функции \ttf{}:

\begin{center}
\begin{tabular}{ | l | l | }
\hline
ESP & адрес возврата \\
\hline
ESP+4 & \argument \#1, \MarkedInIDAAs{} \TT{arg\_0} \\
\hline
ESP+8 & \argument \#2, \MarkedInIDAAs{} \TT{arg\_4} \\
\hline
ESP+0xC & \argument \#3, \MarkedInIDAAs{} \TT{arg\_8} \\
\hline
\dots & \dots \\
\hline
\end{tabular}
\end{center}

См. также в соответствующем разделе о других способах передачи аргументов через стек~(\myref{sec:callingconventions}).

Важно отметить, что, в общем, никто не заставляет программистов передавать параметры именно через стек, это не является требованием к исполняемому коду.
Вы можете делать это совершенно иначе, не используя стек вообще.

В каком-то смысле, популярный метод среди начинающих использовать язык ассемблера,
это передавать аргументы в глобальных переменных, например:

\lstinputlisting[caption=Код на ассемблере]{patterns/02_stack/global_args.asm}

Но у этого метода есть очевидный недостаток: ф-ция \IT{do\_something()} не сможет вызвать саму себя рекурсивно (либо, через
какую-то стороннюю ф-цию),
потому что тогда придется затереть свои собственные аргументы.
Та же история с локальными переменными: если хранить их в глобальных переменных, ф-ция не сможет вызывать сама себя.
Способ хранения подобной информации в стеке заметно всё упрощает ---
он может хранить столько аргументов ф-ций и/или значений вообще,
сколько в нем есть места.

В [\TAOCPvolI{}, 189] можно прочитать про еще более странные схемы передачи аргументов,
которые были очень удобны на IBM System/360.

Так что, традиционно всё сложилось, что в x86 и ARM передача аргументов происходит именно через стек.

\par Кстати, вызываемая функция не имеет информации о количестве переданных ей аргументов.
Функции Си с переменным количеством аргументов (как \printf) определяют их количество по спецификаторам строки формата (начинающиеся со знака \%).

Если написать что-то вроде:

\begin{lstlisting}
printf("%d %d %d", 1234);
\end{lstlisting}

\printf выведет 1234, затем ещё два случайных числа, которые волею случая оказались в стеке рядом.

\par
Вот почему не так уж и важно, как объявлять функцию \main{}: как \main{}, \TT{main(int argc, char *argv[])} либо \TT{main(int argc, char *argv[], char *envp[])}.

В реальности, \ac{CRT}-код вызывает \main примерно так:
	
\begin{lstlisting}
push envp
push argv
push argc
call main
...
\end{lstlisting}

Если вы объявляете \main без аргументов, они, тем не менее, присутствуют в стеке, но не используются.
Если вы объявите \main как \TT{main(int argc, char *argv[])}, 
вы можете использовать два первых аргумента, а третий останется для вашей функции \q{невидимым}.
Более того, можно даже объявить \TT{main(int argc)}, и это будет работать.

