\section{\Conclusion{}}

\RU{Примерный скелет цикла от 2 до 9 включительно}\EN{Rough skeleton of loop from 2 to 9 inclusive}:

% FIXME: russian version
\begin{lstlisting}[caption=x86]
    mov [counter], 2 ; initialization
    jmp check
body:
    ; loop body
    ; do something here
    ; use counter variable in local stack
    add [counter], 1 ; increment
check:
    cmp [counter], 9
    jle body
\end{lstlisting}    

\RU{Операция инкремента может быть представлена как 3 инструкции в неоптимизированном коде:}
\EN{Increment operation may be represented as 3 instructions in non-optimized code:}

\begin{lstlisting}[caption=x86]
    MOV [counter], 2 ; initialization
    JMP check
body:
    ; loop body
    ; do something here
    ; use counter variable in local stack
    MOV REG, [counter] ; increment
    INC REG 
    MOV [counter], REG
check:
    CMP [counter], 9
    JLE body
\end{lstlisting}    

\RU{Если тело цикла короткое, под переменную счетчика можно выделить целый регистр:}
\EN{If loop body is short, a whole register can be dedicated to the counter variable:}

\begin{lstlisting}[caption=x86]
    MOV EBX, 2 ; initialization
    JMP check
body:
    ; loop body
    ; do something here
    ; use counter in EBX, but do not modify it!
    INC EBX ; increment
check:
    CMP EBX, 9
    JLE body
\end{lstlisting}    

\RU{Некоторые части цикла могут быть сгенерированы компилятором в другом порядке:}
\EN{Some parts of loop may be generated by compiler in different order:}

\begin{lstlisting}[caption=x86]
    MOV [counter], 2 ; initialization
    JMP label_check
label_increment:
    ADD [counter], 1 ; increment
label_check:
    CMP [counter], 10
    JGE exit
    ; loop body
    ; do something here
    ; use counter variable in local stack
    JMP label_increment
exit:
\end{lstlisting}    

\RU{Обычно условие проверяется \IT{перед} телом цикла, но компилятор может перестроить цикл так, что
условие будет проверяться \IT{после} тела цикла.}
\EN{Usually condition is checked \IT{before} loop body, but compiler may rearrange loop in that way so
condition will be checked \IT{after} loop body.}
\RU{Это происходит тогда, когда компилятор уверен что условие всегда будет \IT{истинно} на первой итерации,
так что тело цикла исполнится как минимум один раз:}
\EN{This is when compiler is sure that condition is always \IT{true} on first iteration, so loop body
will be executed at least once:}

\begin{lstlisting}[caption=x86]
    MOV REG, 2 ; initialization
body:
    ; loop body
    ; do something here
    ; use counter in REG, but do not modify it!
    INC REG ; increment
    CMP REG, 10
    JL body
\end{lstlisting}

\index{x86!\Instructions!LOOP}
\RU{Используя инструкцию \TT{LOOP}. Это редкость, компиляторы не используют её.
Так что если вы её видите, это верный знак, что этот фрагмент кода написан вручную:}
\EN{Using \TT{LOOP} instruction. This is rare, compilers are not using it.
So when you see it, it's a right sign this piece of code is hand-written:}

\begin{lstlisting}[caption=x86]
    ; count from 10 to 1
    MOV ECX, 10
body:
    ; loop body
    ; use ECX, bit do not modify it!
    LOOP body
\end{lstlisting}

\ifdefined\IncludeARM
ARM. 
\RU{В этом примере, регистр \Reg{4} выделен для переменной счетчика:}
\EN{A \Reg{4} register is dedicated to counter variable in this example:}

\begin{lstlisting}[caption=ARM]
    MOV R4, 2 ; initialization
    B check
body:
    ; loop body
    ; do something here
    ; use counter in R4, but do not modify it!
    ADD R4,R4, #1 ; increment
check:
    CMP R4, #10
    BLT body
\end{lstlisting}
\fi
