\subsubsection{32-\RU{битный}\EN{bit} ARM}

\myparagraph{\NonOptimizingXcodeIV (\ARMMode)}

\lstinputlisting[caption=\NonOptimizingXcodeIV (\ARMMode),label=ARM_leaf_example7]{patterns/10_strings/1_strlen/ARM/xcode_ARM_O0.asm.\LANG}

\RU{Неоптимизирующий LLVM генерирует слишком много кода, зато на этом примере можно посмотреть, 
как функции работают с локальными переменными в стеке.}
\EN{Non-optimizing LLVM generates too much code, however, here we can see how the function works with 
local variables in the stack.}
\RU{В нашей функции только локальных переменных две, это два указателя}
\EN{There are only two local variables in our function},
\IT{eos} \AndENRU \IT{str}.

\RU{В этом листинге}\EN{In this listing}, \RU{сгенерированном при помощи}\EN{generated by} \IDA, 
\RU{я переименовал}\EN{I have manually renamed} \IT{var\_8} \AndENRU \IT{var\_4} \RU{в}\EN{to} \IT{eos} 
\AndENRU \IT{str} \RU{вручную}.

\RU{Итак, первые несколько инструкций просто сохраняют входное значение в обоих переменных}
\EN{The first instructions just saves the input values into both} \IT{str} \AndENRU \IT{eos}.

\RU{Начиная с метки}\EN{The body of the loop starts at label} \IT{loc\_2CB8}\RU{, начинается тело цикла}.

\RU{Первые три инструкции в теле цикла}\EN{The first three instruction in the loop body} (\TT{LDR}, \ADD, \TT{STR}) 
\RU{загружают значение}\EN{load the value of} \IT{eos} \RU{в}\EN{into} \Reg{0}, 
\RU{затем происходит инкремент значения и оно сохраняется назад в локальной переменной \IT{eos} расположенной 
в стеке.}\EN{then the value is \glslink{increment}{incremented} and saved back into \IT{eos}, which is located in the stack.}

\index{ARM!\Instructions!LDRSB}
\RU{Следующая инструкция}\EN{The next instruction, } \TT{``LDRSB R0, [R0]''} (\IT{Load Register Signed Byte}) 
\RU{загружает байт из памяти по адресу \Reg{0}, расширяет его до 32-бит считая его знаковым (signed) 
и сохраняет в \Reg{0}}\EN{, loads a byte from memory at the address stored in \Reg{0} 
and sign-extends it to 32-bit}
\footnote{\RU{Компилятор Keil считает тип \Tchar знаковым, как и MSVC и GCC}\EN{The Keil compiler 
treats the \Tchar type as signed, just like MSVC and GCC}.}.
\index{x86!\Instructions!MOVSX}
\RU{Это немного похоже на инструкцию}\EN{This is similar to the} \MOVSX \RU{в}\EN{instruction in} x86.
\RU{Компилятор считает этот байт знаковым (signed), потому что тип \Tchar по стандарту Си ~--- знаковый.}
\EN{The compiler treats this byte as signed since the \Tchar type is signed according to the C standard.}
\RU{Об это я уже немного писал}\EN{I already wrote about it}~(\ref{MOVSX}) \RU{в этой же секции, 
но посвященной x86}\EN{in this section, in relation to x86}.

\index{Intel!8086}
\index{Intel!8080}
\index{ARM}
\RU{Следует также заметить, что, в ARM нет возможности использовать 8-битную или 16-битную часть 
регистра, как это возможно в x86.}
\EN{It is should be noted that it is impossible  to use 8- or 16-bit part 
of a 32-bit register in ARM separately of the whole register,
as it is in x86.}
\RU{Вероятно, это связано с тем что за x86 тянется длинный шлейф совместимости со своими предками, 
вплоть до 16-битного 8086 и даже 8-битного 8080, 
а ARM разрабатывался с чистого листа как 32-битный RISC-процессор.}
\EN{Apparently, it is because x86 has a huge history of backwards compatibility with its ancestors 
up to the 16-bit 8086 and even 8-bit 8080,
but ARM was developed from scratch as a 32-bit RISC-processor.}
\RU{Следовательно, чтобы работать с отдельными байтами на ARM, так или иначе, придется использовать 
32-битные регистры.}
\EN{Consequently, in order to process separate bytes in ARM, one has to use 32-bit registers anyway.}

\RU{Итак}\EN{So}, \TT{LDRSB} \RU{загружает символ из строки в \Reg{0}, по одному}
\EN{loads bytes from the string into \Reg{0}, one by one}.
\RU{Следующие инструкции}\EN{The following} \CMP \AndENRU \ac{BEQ} \RU{проверяют, является ли этот символ $0$.}
\EN{instructions check if the loaded byte is $0$.}
\RU{Если не $0$, то происходит переход на начало тела цикла.}\EN{If it's not $0$, control passes to the start
of the body of the loop.}
\RU{А если $0$, выходим из цикла.}\EN{And if it's $0$, the loop ends.}

\RU{В конце функции вычисляется разница между}\EN{At the end of the function, the difference between} 
\IT{eos} \AndENRU \IT{str}\RU{, вычитается еще единица и вычисленное 
значение возвращается через \Reg{0}.}\EN{ is calculated, $1$ is subtracted from it, and resulting value is returned
via \Reg{0}.}

N.B. \RU{В этой функции не сохранялись регистры}\EN{Registers were not saved in this function}.
\index{ARM!\Registers!scratch registers}
\RU{Это потому что, по стандарту, регистры \Reg{0}-\Reg{3} называются также ``scratch registers'',
они предназначены для передачи аргументов, 
их значения не нужно восстанавливать при выходе из функции, потому что они больше не нужны в вызывающей функции.
Таким образом, их можно использовать как захочется}
\EN{That's because in the ARM calling convention registers \Reg{0}-\Reg{3} are ``scratch registers'', 
intended for arguments passing,
and we're not required to restore their value when the function exits, since the calling function will not use them anymore.
Consequently, they may be used for anything we want.}
\RU{А так как никакие больше регистры не используются, то и сохранять нечего.}
\EN{No other registers are used here, so that is why we have nothing to save on the stack.}
\RU{Поэтому, управление можно вернуть назад вызывающей функции 
простым переходом (\TT{BX}), по адресу в регистре \ac{LR}.}
\EN{Thus, control may be returned back to calling function by a simple jump (\TT{BX}),
to the address in the \ac{LR} register.}

%\subsubsection{\NonOptimizingXcodeIV + режим thumb}
%Практически, точно такой же код.

\myparagraph{\OptimizingXcodeIV (\ThumbMode)}

\lstinputlisting[caption=\OptimizingXcodeIV (\ThumbMode)]{patterns/10_strings/1_strlen/ARM/xcode_thumb_O3.asm}

\RU{Оптимизирующий LLVM решил, что под переменные \IT{eos} и \IT{str} выделять место в стеке не обязательно}
\EN{As optimizing LLVM concludes, \IT{eos} and \IT{str} do not need space on the stack},
\RU{и эти переменные можно хранить прямо в регистрах.}
\EN{and can always be stored in registers.}
\RU{Перед началом тела цикла}\EN{Before the start of the loop body}, \IT{str} \RU{будет находиться в}\EN{will always be in} 
\Reg{0}, \RU{а}\EN{and} \IT{eos}\EMDASH\InENRU \Reg{1}.

\index{ARM!\Instructions!LDRB.W}
\EN{The}\RU{Инструкция} \TT{``LDRB.W R2, [R1],\#1''} \RU{загружает в \Reg{2} байт из памяти по адресу \Reg{1}, 
расширяя его как знаковый (signed), до 32-битного
значения, но не только это.}
\EN{instruction loads a byte from the memory at the address stored in \Reg{1}, to \Reg{2}, sign-extending it to a 32-bit value, but not
just that.}
\TT{\#1} \RU{в конце инструкции называется}\EN{at the instruction's end is called} ``Post-indexed addressing'', 
\RU{это значит, что после загрузки байта, к \Reg{1} добавится единица.}\EN{which means that $1$ is to be added
to \Reg{1} after the byte is loaded.}

\RU{Читайте больше об этом}\EN{Read more about it}: \ref{ARM_postindex_vs_preindex}.

\RU{Далее в теле цикла можно увидеть \CMP и \ac{BNE}, они продолжают работу цикла до тех пор, 
пока не будет встречен $0$.}
\EN{Then you can see \CMP and \ac{BNE} in the body of the loop, these instructions continue looping until
$0$ is found in the string.}

\index{ARM!\Instructions!MVNS}
\index{x86!\Instructions!NOT}
\RU{После конца цикла }\TT{MVNS}\footnote{MoVe Not} 
\RU{(инвертирование всех бит, \NOT в x86)}
\EN{(inverts all bits, like \NOT in x86)}
\RU{и \ADD вычисляют}\EN{and \ADD instructions compute} $eos - str - 1$.
\RU{На самом деле, эти две инструкции вычисляют}
\EN{In fact, these two instructions compute}
$R0 = ~str + eos$, 
\RU{что эквивалентно тому, что было в исходном коде, а почему это так, я уже описывал чуть раньше, здесь}
\EN{which is effectively equivalent to what was in the source code, and why it is so, I already explained here}
~(\ref{strlen_NOT_ADD}).

\RU{Вероятно, LLVM, как и GCC, посчитал что такой код будет короче, или быстрее.}
\EN{Apparently, LLVM, just like GCC, concludes that this code will be shorter, or faster.}

%\subsubsection{\OptimizingXcodeIV + \ARMMode}
%Практически, точно такой же код.

\myparagraph{\OptimizingKeilVI (\ARMMode)}

\lstinputlisting[caption=\OptimizingKeilVI (\ARMMode),label=ARM_leaf_example6]{patterns/10_strings/1_strlen/ARM/Keil_ARM_O3.asm}

\index{ARM!\Instructions!SUBEQ}
\RU{Практически то же самое что мы уже видели, за тем исключением что выражение}
\EN{Almost the same as what we saw before, with the exception that the}
$str - eos - 1$ 
\RU{может быть вычислено не в самом конце функции, а прямо в теле цикла.}
\EN{expression can be computed not at the function's end, but right in the body of the loop.}
\EN{The}\RU{Суффикс} \TT{-EQ}\RU{, как мы помним, означает что инструкция будет выполнена только
если операнды в исполненной перед этим инструкции \CMP были равны.}
\EN{suffix, as we may recall, means that the instruction will be executed only if the operands in
the \CMP that was executed before were equal to each other.}
\RU{Таким образом}\EN{Thus}, \RU{если в \Reg{0} будет $0$}\EN{if \Reg{0} contains $0$},
\RU{обе инструкции}\EN{both} \TT{SUBEQ} \RU{исполнятся и результат останется в \Reg{0}.}
\EN{instructions will be executed and result will be left in the \Reg{0} register.}

