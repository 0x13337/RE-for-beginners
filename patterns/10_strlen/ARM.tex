\section{ARM}

\subsection{\NonOptimizingXcode + \ARMMode}

\lstinputlisting[caption=\NonOptimizingXcode + \ARMMode]{patterns/10_strlen/xcode_ARM_O0_en.asm}

\IFRU{Неоптимизирующий LLVM генерирует слишком много кода, зато на этом примере можно посмотреть, 
как функции работают с локальными переменными в стеке.}
{Non-optimizing LLVM generates too much code, however, here we can see how function works with 
local variables in the stack.}
\IFRU{В нашей функции только локальных переменных две, это два указателя}
{There are only two local variables in our function},
\IT{eos} \AndENRU \IT{str}.

\IFRU{В этом листинге}{In this listing}, \IFRU{сгенерированном при помощи}{generated by} \IDA, 
\IFRU{я переименовал}{I renamed} \IT{var\_8} \AndENRU \IT{var\_4} \IFRU{в}{into} \IT{eos} 
\AndENRU \IT{str} \IFRU{вручную}{manually}.

\IFRU{Итак, первые несколько инструкций просто сохраняют входное значение в переменных}{So, 
first instructions are just saves input value in} \IT{str} \AndENRU \IT{eos}.

\IFRU{Начиная с метки}{Loop body is beginning at} \IT{loc\_2CB8}\IFRU{, начинается тело цикла}{ label}.

\IFRU{Первые три инструкции в теле цикла}{First three instruction in loop body} (\TT{LDR}, \ADD, \TT{STR}) 
\IFRU{загружают значение}{loads} \IT{eos} \IFRU{в}{value into} \Reg{0}, 
\IFRU{затем происходит инкремент значения и оно сохраняется назад в локальной переменной \IT{eos} расположенной 
в стеке.}{then value is \glslink{increment}{incremented} and it is saved back into \IT{eos} local variable located in the stack.}

\index{ARM!\Instructions!LDRSB}
\IFRU{Следующая инструкция}{The next} \TT{``LDRSB R0, [R0]''} (\IT{Load Register Signed Byte}) 
\IFRU{загружает байт из памяти по адресу \Reg{0}, расширяет его до 32-бит считая его знаковым (signed) 
и сохраняет в \Reg{0}}{instruction loading byte from memory at \Reg{0} address and sign-extends it to 32-bit}.
\index{x86!\Instructions!MOVSX}
\IFRU{Это немного похоже на инструкцию}{This is similar to} \MOVSX \IFRU{в}{instruction in} x86.
\IFRU{Компилятор считает этот байт знаковым (signed), потому что тип \Tchar по стандарту Си ~--- знаковый.}
{The compiler treating this byte as signed since \Tchar type in C standard is signed.}
\IFRU{Об это я уже немного писал}{I already wrote about it}~(\ref{MOVSX}) \IFRU{в этой же секции, 
но посвященной x86}{in this section, but related to x86}.

\index{x86!8086}
\index{8080}
\index{ARM}
\IFRU{Следует также заметить, что, в ARM нет возможности использовать 8-битную или 16-битную часть 
регистра, как это возможно в x86.}
{It is should be noted, it is impossible in ARM to use 8-bit part or 16-bit part 
of 32-bit register separately of the whole register,
as it is in x86.}
\IFRU{Вероятно, это связано с тем что за x86 тянется длинный шлейф совместимости со своими предками, 
такими как
16-битный 8086 и даже 8-битный 8080, а ARM разрабатывался с чистого листа как 32-битный RISC-процессор.}
{Apparently, it is because x86 has a huge history of compatibility with its ancestors like 16-bit 8086 
and even 8-bit 8080,
but ARM was developed from scratch as 32-bit RISC-processor.}
\IFRU{Следовательно, чтобы работать с отдельными байтами на ARM, так или иначе, придется использовать 
32-битные регистры.}
{Consequently, in order to process separate bytes in ARM, one have to use 32-bit registers anyway.}

\IFRU{Итак}{So}, \TT{LDRSB} \IFRU{загружает символ из строки в \Reg{0}, по одному}
{loads symbol from string into \Reg{0}, one by one}.
\IFRU{Следующие инструкции}{Next} \CMP \AndENRU \ac{BEQ} \IFRU{проверяют, является ли этот символ $0$.}
{instructions checks, if loaded symbol is $0$.}
\IFRU{Если не $0$, то происходит переход на начало тела цикла.}{If not $0$, control passing to loop body
begin.}
\IFRU{А если $0$, выходим из цикла.}{And if $0$, loop is finishing.}

\IFRU{В конце функции вычисляется разница между}{At the end of function, a difference between} 
\IT{eos} \AndENRU \IT{str}\IFRU{, вычитается еще единица и вычисленное 
значение возвращается через \Reg{0}.}{ is calculated, 1 is also subtracting, and resulting value is returned
via \Reg{0}.}

N.B. \IFRU{В этой функции не сохранялись регистры}{Registers was not saved in this function}.
\index{ARM!\Registers!scratch registers}
\IFRU{Это потому что, по стандарту, регистры \Reg{0}-\Reg{3} называются также ``scratch registers'',
они предназначены для передачи аргументов, 
их значения не нужно восстанавливать при выходе из функции, потому что они больше не нужны в вызывающей функции.
Таким образом, их можно использовать как захочется}
{That's because by ARM calling convention, \Reg{0}-\Reg{3} registers are ``scratch registers'', 
they are intended for arguments passing,
its values may not be restored upon function exit since calling function will not use them anymore.
Consequently, they may be used for anything we want.}
\IFRU{А так как никакие больше регистры не используются, то и сохранять нечего.}
{Other registers are not used here, so that is why we have nothing to save on the stack.}
\IFRU{Поэтому, управление можно вернуть назад вызывающей функции 
простым переходом (\TT{BX}), по адресу в регистре \LR.}
{Thus, control may be returned back to calling function by simple jump (\TT{BX}),
to address in the \LR register.}

%\subsection{\NonOptimizingXcode + режим thumb}
%Практически, точно такой же код.

\subsection{\OptimizingXcode + \ThumbMode}

\lstinputlisting[caption=\OptimizingXcode + \ThumbMode]{patterns/10_strlen/xcode_thumb_O3.asm}

\IFRU{Оптимизирующий LLVM решил, что под переменные \IT{eos} и \IT{str} выделять место в стеке не обязательно}
{As optimizing LLVM concludes, space on the stack for \IT{eos} and \IT{str} may not be allocated},
\IFRU{и эти переменные можно хранить прямо в регистрах.}
{and these variables may always be stored right in registers.}
\IFRU{Перед началом тела цикла}{Before loop body beginning}, \IT{str} \IFRU{будет находиться в}{will always be in} 
\Reg{0}, \IFRU{а}{and} \IT{eos}\EMDASH\InENRU \Reg{1}.

\index{ARM!\Instructions!LDRB.W}
\index{ARM!\IFRU{Режимы адресации}{Adressing modes}}
\RU{Инструкция }\TT{``LDRB.W R2, [R1],\#1''} \IFRU{загружает в \Reg{2} байт из памяти по адресу \Reg{1}, 
расширяя его как знаковый (signed), до 32-битного
значения, но не только это.}
{instruction loads byte from memory at the address \Reg{1} into \Reg{2}, sign-extending it to 32-bit value, but not
only that.}
\TT{\#1} \IFRU{в конце инструкции называется}{at the instruction's end calling} ``Post-indexed addressing'', 
\IFRU{это значит, что после загрузки байта, к \Reg{1} добавится единица.}{this means, $1$ is to be added
to the \Reg{1} after byte load.}
\IFRU{Это очень удобно для работы с массивами.}
{That's convenient when accessing arrays.}

\index{PDP-11}
\index{\CLanguageElements!\PostIncrement}
\index{\CLanguageElements!\PostDecrement}
\index{\CLanguageElements!\PreIncrement}
\index{\CLanguageElements!\PreDecrement}
\IFRU{Такого режима адресации в x86 нет, но он есть в некоторых других процессорах, даже на PDP-11.}
{There is no such addressing mode in x86, but it is present in some other processors, even on PDP-11.}
\IFRU{Существует байка, что режимы пре-инкремента, пост-инкремента, 
пре-декремента и пост-декремента адреса в PDP-11}
{There is a legend the pre-increment, post-increment, pre-decrement and post-decrement modes in PDP-11},
\IFRU{были ``виновны'' в появлении таких конструкций языка Си (который разрабатывался на PDP-11) как}
{were ``guilty'' in appearance such C language (which developed on PDP-11) constructs as}
*ptr++, *++ptr, *ptr-{}-, *-{}-ptr. 
\IFRU{Кстати, это является труднозапоминаемой особенностью в Си.}
{By the way, this is one of hard to memorize C feature.}
\IFRU{Дела обстоят так:}{This is how it is:}

\begin{center}
\begin{tabular}{ | l | l | l | l | }
\hline
\headercolor{} \IFRU{термин в Си}{C term} & 
\headercolor{} \IFRU{термин в ARM}{ARM term} & 
\headercolor{} \IFRU{выражение Си}{C statement} & 
\headercolor{} \IFRU{как это работает}{how it works} \\
\hline
\PostIncrement & 
post-indexed addressing & 
\TT{*ptr++} & 
\IFRU{использовать значение \TT{*ptr}}{use \TT{*ptr} value}, \\
& & & \IFRU{затем инкремент указателя \TT{ptr}}{then \gls{increment} \TT{ptr} pointer} \\
\hline
\PostDecrement & 
post-indexed addressing & 
\TT{*ptr-{}-} & 
\IFRU{использовать значение \TT{*ptr}}{use \TT{*ptr} value}, \\
& & & \IFRU{затем \glslink{decrement}{декремент} указателя \TT{ptr}}{then \gls{decrement} \TT{ptr} pointer} \\
\hline
\PreIncrement & 
pre-indexed addressing & 
\TT{*++ptr} & 
\IFRU{инкремент указателя \TT{ptr}}{\gls{increment} \TT{ptr} pointer}, \\
& & & \IFRU{затем использовать значение \TT{*ptr}}{then use \TT{*ptr} value} \\
\hline
\PreDecrement & 
post-indexed addressing & 
\TT{*-{}-ptr} & 
\IFRU{\glslink{decrement}{декремент} указателя \TT{ptr}}{\gls{decrement} \TT{ptr} pointer}, \\
& & & \IFRU{затем использовать значение \TT{*ptr}}{then use \TT{*ptr} value} \\
\hline
\end{tabular}
\end{center}

\IFRU{Деннис Ритчи (один из создателей ЯП Си) указывал, что, это, вероятно, придумал Кен Томпсон 
(еще один создатель Си),
потому что подобная возможность процессора имелась еще в PDP-7}
{Dennis Ritchie (one of C language creators) mentioned that it is, probably, was invented by Ken Thompson
(another C creator) because this processor feature was present in PDP-7}
\cite{Ritchie:1986}\cite{Ritchie:1993:DCL:155360.155580}.
\IFRU{Таким образом, компиляторы с ЯП Си на тот процессор, где это есть, могут использовать это.}
{Thus, C language compilers may use it, if it is present in target processor.}

\IFRU{Далее в теле цикла можно увидеть \CMP и \ac{BNE}, они продолжают работу цикла до тех пор, 
пока не будет встречен $0$.}
{Then one may spot \CMP and \ac{BNE} in loop body, these instructions continue operation until
$0$ will be met in string.}

\index{ARM!\Instructions!MVNS}
\index{x86!\Instructions!NOT}
\RU{После конца цикла }\TT{MVNS}\footnote{MoVe Not} 
\IFRU{(инвертирование всех бит, аналог \NOT на x86)}
{(inverting all bits, \NOT in x86 analogue)}
\IFRU{и \ADD вычисляют}{instructions and \ADD computes} $eos - str - 1$.
\IFRU{На самом деле, эти две инструкции вычисляют}
{In fact, these two instructions computes}
$R0 = ~str + eos$, 
\IFRU{что эквивалентно тому, что было в исходном коде, а почему это так, я уже описывал чуть раньше, здесь}
{which is effectively equivalent to what was in source code, and why it is so, I already described here}
~(\ref{strlen_NOT_ADD}).

\IFRU{Вероятно, LLVM, как и GCC, посчитал что такой код будет короче, или быстрее.}
{Apparently, LLVM, just like GCC, concludes this code will be shorter, or faster.}

%\subsection{\OptimizingXcode + \ARMMode}
%Практически, точно такой же код.

\subsection{\OptimizingKeil{} + \ARMMode}

\lstinputlisting[caption=\OptimizingKeil + \ARMMode]{patterns/10_strlen/Keil_ARM_O3.asm}

\index{ARM!\Instructions!SUBEQ}
\IFRU{Практически то же самое что мы уже видели, за тем исключением что выражение}
{Almost the same what we saw before, with the exception the}
$str - eos - 1$ 
\IFRU{может быть вычислено не в самом конце функции, а прямо в теле цикла.}
{expression may be computed not at the function's end, but right in loop body.}
\RU{Суффикс }\TT{-EQ}\IFRU{, как мы помним, означает что инструкция будет выполнена только
если операнды в исполненной перед этим инструкции \CMP были равны.}
{suffix, as we may recall, means the instruction will be executed only if operands in executed before
\CMP were equal to each other.}
\IFRU{Таким образом}{Thus}, \IFRU{если в \Reg{0} будет $0$}{if $0$ will be in the \Reg{0} register},
\IFRU{обе инструкции}{both} \TT{SUBEQ} \IFRU{исполнятся и результат останется в \Reg{0}.}
{instructions are to be executed and result is leaving in the \Reg{0} register.}

