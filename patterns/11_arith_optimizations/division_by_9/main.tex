\section{\DivisionByNineSectionName}
\label{sec:divisionbynine}

\RU{Простая функция:}\EN{Very simple function:}

\begin{lstlisting}
int f(int a)
{
	return a/9;
};
\end{lstlisting}

\subsection{x86}

\dots \RU{компилируется вполне предсказуемо:}\EN{is compiled in a very predictable way:}

\lstinputlisting[caption=MSVC]{patterns/11_arith_optimizations/division_by_9/11_1_msvc_\LANG.asm}

\index{ARM!\Instructions!IDIV}
\RU{\IDIV делит 64-битное число хранящееся в паре регистров \TT{EDX:EAX} на значение в \ECX. 
В результате, \EAX будет содержать частное\FNQUOTIENT, а \EDX ~--- остаток от деления. 
Результат возвращается из функции через \EAX, так что после операции деления, 
это значение не перекладывается больше никуда, 
оно уже там где надо.}
\EN{\IDIV divides 64-bit number stored in the \TT{EDX:EAX} register pair by value in the \ECX register.
As a result, \EAX will contain quotient\FNQUOTIENT, and \EDX~---remainder.
Result is returning from the \TT{f()} function in the \EAX register, 
so, the value is not moved anymore after division 
operation, it is in right place already.}
\RU{Из-за того, что \IDIV требует пару регистров \TT{EDX:EAX}, то перед этим инструкция \TT{CDQ} 
расширяет \EAX до 64-битного значения учитывая знак, так же, как это делает \MOVSX.}
\EN{Since \IDIV requires value in the \TT{EDX:EAX} register pair, \TT{CDQ} instruction (before \IDIV) extending 
value in the \EAX to 64-bit value taking value sign into account, just as \MOVSX does.}
\RU{Со включенной оптимизацией (\Ox) получается:}
\EN{If we turn optimization on (\Ox), we got:}

\lstinputlisting[caption=\Optimizing MSVC]{patterns/11_arith_optimizations/division_by_9/11_1_msvc_Ox.asm}

\RU{Это ~--- деление через умножение. Умножение конечно быстрее работает. 
Поэтому можно используя этот трюк
\footnote{Читайте подробнее о делении через умножение в \cite[10-3]{Warren:2002:HD:515297}} 
создать код эквивалентный тому что мы хотим и работающий быстрее.}
\EN{This is~---division by multiplication. Multiplication operation works much faster. 
And it is possible to use the trick
\footnote{Read more about division by multiplication in \cite[10-3]{Warren:2002:HD:515297}} 
to produce a code which is effectively equivalent and faster.}

\RU{В оптимизации компиляторов, это также называется}\EN{This is also called} 
``strength reduction''\EN{ in compiler optimization}.

\RU{GCC 4.4.1 даже без включенной оптимизации генерирует примерно такой же код, 
как и MSVC с оптимизацией:}
\EN{GCC 4.4.1 even without optimization turned on, generates almost the same code as MSVC with optimization turned on:}

\lstinputlisting[caption=\NonOptimizing GCC 4.4.1]{patterns/11_arith_optimizations/division_by_9/11_2_gcc.asm}

\subsection{ARM}

\RU{В процессоре ARM, как и во многих других ``чистых'' (pure) RISC-процессорах нет инструкции деления.
Нет также возможности умножения на 32-битную константу одной инструкцией.}
\EN{ARM processor, just like in any other ''pure'' RISC-processors, lacks division instruction
It lacks also a single instruction for multiplication by 32-bit constant.}
\RU{При помощи одного любопытного трюка (или \IT{хака})\footnote{hack}, можно обойтись только тремя действиями: 
сложением, вычитанием и битовыми сдвигами}
\EN{By taking advantage of the one clever trick (or \IT{hack}), it is possible to do division using only three instructions: addition,
subtraction and bit shifts}~(\ref{sec:bitfields}).

\RU{Пример деления 32-битного числа на 10 из}\EN{Here is an example of 32-bit number division by 10 from}
\cite[3.3 Division by a Constant]{ARM:1994}.
\RU{На выходе и частное и остаток}\EN{Quotient and remainder on output}.

\begin{lstlisting}
; takes argument in a1
; returns quotient in a1, remainder in a2
; cycles could be saved if only divide or remainder is required
    SUB    a2, a1, #10             ; keep (x-10) for later
    SUB    a1, a1, a1, lsr #2
    ADD    a1, a1, a1, lsr #4
    ADD    a1, a1, a1, lsr #8
    ADD    a1, a1, a1, lsr #16
    MOV    a1, a1, lsr #3
    ADD    a3, a1, a1, asl #2
    SUBS   a2, a2, a3, asl #1      ; calc (x-10) - (x/10)*10
    ADDPL  a1, a1, #1              ; fix-up quotient
    ADDMI  a2, a2, #10             ; fix-up remainder
    MOV    pc, lr
\end{lstlisting}

\subsubsection{\OptimizingXcodeIV (\ARMMode)}

\begin{lstlisting}
__text:00002C58 39 1E 08 E3 E3 18 43 E3  MOV    R1, 0x38E38E39
__text:00002C60 10 F1 50 E7              SMMUL  R0, R0, R1
__text:00002C64 C0 10 A0 E1              MOV    R1, R0,ASR#1
__text:00002C68 A0 0F 81 E0              ADD    R0, R1, R0,LSR#31
__text:00002C6C 1E FF 2F E1              BX     LR
\end{lstlisting}

\RU{Этот код почти тот же, что сгенерирован MSVC и GCC в режиме оптимизации.}
\EN{This code is mostly the same to what was generated by optimizing MSVC and GCC.}
\RU{Должно быть, LLVM использует тот же алгоритм для поиска констант.}
\EN{Apparently, LLVM use the same algorithm for constants generating.}

\index{ARM!\Instructions!MOV}
\index{ARM!\Instructions!MOVT}
\RU{Наблюдательный читатель может спросить, как \MOV записала в регистр сразу 32-битное число, 
ведь это невозможно в режиме ARM.}
\EN{Observant reader may ask, how \MOV writes 32-bit value in register, while this is not possible in ARM mode.}
\RU{Действительно невозможно, но как мы видим, здесь на инструкцию 8 байт вместо стандартных 4-х,
на самом деле, здесь 2 инструкции.}
\EN{it is impossible indeed, but, as we see,
there are 8 bytes per instruction instead of standard 4,
in fact, there are two instructions.}
\RU{Первая инструкция загружает в младшие 16 бит регистра значение \TT{0x8E39}, а вторая инструкция, 
на самом деле \TT{MOVT}, загружающая в старшие 16 бит регистра значение \TT{0x383E}.}
\EN{First instruction loading \TT{0x8E39} value into low 16 bit of register and second instruction is in fact
\TT{MOVT}, it loading \TT{0x383E} into high 16-bit of register.}
\IDA \RU{распознала эту последовательность и для краткости, сократила всё это до одной ``псевдо-инструкции''.}
\EN{is aware of such sequences, and for the sake of compactness, reduced it to one single ``pseudo-instruction''.}

\index{ARM!\Instructions!SMMUL}
\RU{Инструкция }\TT{SMMUL} (\IT{Signed Most Significant Word Multiply}) 
\RU{умножает числа считая их знаковыми (signed) и оставляет в \Reg{0} старшие 32 бита результата, 
не сохраняя младшие 32 бита.}
\EN{instruction multiply numbers treating them as signed numbers,
and leaving high 32-bit part of result in the \Reg{0} register,
dropping low 32-bit part of result.}

\index{ARM!Optional operators!ASR}
\RU{Инструкция }\TT{``MOV R1, R0,ASR\#1''} \RU{это арифметический сдвиг право на один бит.}
\EN{instruction is arithmetic shift right by one bit.}

\index{ARM!\Instructions!ADD}
\index{ARM!Data processing instructions}
\index{ARM!Optional operators!LSR}
\TT{``ADD R0, R1, R0,LSR\#31''} \RU{это}\EN{is} $R0=R1 + R0>>31$

\label{shifts_in_ARM_mode}
\RU{Дело в том, что в режиме ARM нет отдельных инструкций для битовых сдвигов.}
\EN{As a matter of fact, there is no separate shifting instruction in ARM mode.}
\RU{Вместо этого, некоторые инструкции}\EN{Instead, an instructions like} 
(\MOV, \ADD, \SUB, \TT{RSB})\footnote{\DataProcessingInstructionsFootNote}
\RU{могут быть дополнены пометкой, сдвигать ли второй операнд и если да, то на сколько и как.}
\EN{may be supplied by option, is the second operand must be shifted, if yes, by what value and how.}
\TT{ASR} \RU{означает}\EN{meaning} \IT{Arithmetic Shift Right}, \TT{LSR}\EMDASH\IT{Logican Shift Right}.

\subsubsection{\OptimizingXcodeIV (\ThumbTwoMode)}

\begin{lstlisting}
MOV             R1, 0x38E38E39
SMMUL.W         R0, R0, R1
ASRS            R1, R0, #1
ADD.W           R0, R1, R0,LSR#31
BX              LR
\end{lstlisting}

\index{ARM!\Instructions!ASRS}
\RU{В режиме thumb отдельные инструкции для битовых сдвигов есть}
\EN{There are separate instructions for shifting in thumb mode}, \RU{и здесь применяется одна из них}
\EN{and one of them is used here}\EMDASH\TT{ASRS} (\RU{арифметический сдвиг вправо}\EN{arithmetic shift right}).

\subsubsection{\NonOptimizing Xcode 4.6.3 (LLVM) \AndENRU Keil 6/2013}

\NonOptimizing LLVM 
\RU{не занимается генерацией подобного кода, а вместо этого просто вставляет вызов
библиотечной функции \IT{\_\_\_divsi3}}
\EN{does not generate code we saw before in this section, but inserts a call to library function 
\IT{\_\_\_divsi3} instead}.

\RU{А Keil во всех случаях вставляет вызов функции}
\EN{What about Keil: it inserts call to library function} \IT{\_\_aeabi\_idivmod}\EN{ in all cases}.

\subsection{\RU{Как это работает}\EN{How it works}}

\RU{Вот как деление может быть заменено на умножение и деление на числа $2^{n}$}
\EN{That's how division can be replaced by multiplication and division by $2^{n}$ numbers}:

\[
	result = 
	\frac{input}{divisor} = 
	\frac{input \cdot \frac{2^{n}}{divisor}}{2^{n}} = 
	\frac{input \cdot M}{2^{n}}
\]

\RU{Где}\EN{Where} $M$ \RU{это}\EN{is} \IT{magic}-\RU{коэффициент}\EN{coefficient}.

\RU{Как вычислить $M$}\EN{That's how $M$ can be computed}:

\[
	M = \frac{2^{n}}{divisor}
\]

\RU{Так что эти фрагменты кода обычно имеют форму}
\EN{So these code snippets are usually have this form}:

\[
	result = \frac{input \cdot M}{2^{n}}
\]

\RU{Деление на $2^{n}$ производится обычным битовым сдвигом вправо.}
\EN{Division by $2^{n}$ is usually done by simple right bit shift.}
\RU{Если}\EN{If} $n<32$, 
\RU{то тогда сдвигается младшая часть \glslink{product}{произведения}}
\EN{then low part of \gls{product} is shifted} (\InENRU \EAX \OrENRU \RAX).
\RU{Если}\EN{If} $n\geq32$, 
\RU{то тогда сдвигается старшая часть \glslink{product}{произведения}}
\EN{then the high part of \gls{product} is shifted} (\InENRU \EDX \OrENRU \RDX).

$n$ \RU{выбирается так, чтобы улучшить точность результата}\EN{is choosen in order to minimize
error}.

\RU{Если делать знаковое деление, знак результата умножения также добавляется к результату}
\EN{When doing signed division, sign of multiplication result also added to the output result}.

\RU{Посмотрите на разницу}\EN{Take a look at the difference}:

\begin{lstlisting}
int f3_32_signed(int a)
{
	return a/3;
};

unsigned int f3_32_unsigned(unsigned int a)
{
	return a/3;
};
\end{lstlisting}

\RU{В беззнаковой версии функции}\EN{In the unsigned version of function}, 
\IT{magic}-\RU{коэффициент это}\EN{coefficient is} \TT{0xAAAAAAAB} \RU{и результат умножения делится на}
\EN{and multiplication result is divided by} $2^{33}$.

\RU{В знаковой версии функции}\EN{In the signed version of function}, \IT{magic}-\RU{коэффициент это}
\EN{coefficient is} \TT{0x55555556} \RU{и результат умножения делится на}
\EN{and multiplication result is divided by} $2^{32}$.
\RU{Впрочем здесь нет инструкции деления: результат просто берется из}\EN{There are no 
division instruction though: result is just taken from} \EDX. 

\RU{Знак результата умножения также учитывается: старшие 32 бита результата сдвигаются на 31
(таким образом, оставляя знак в самом младшем бите \EAX).}
\EN{Sign is also taken from multiplication result: high 32 bits of result is shifted by 31
(leaving sign in least significant bit of \EAX).}
$1$ \RU{прибавляется к конечному результату, если знак отрицательный, для коррекции результата}
\EN{is added to the final result if sign is negative, for result correction}.

\lstinputlisting[caption=\Optimizing MSVC 2012]{patterns/11_arith_optimizations/division_by_9/2.asm.\LANG}

\RU{Читайте больше об этом в}\EN{Read more about it in} \cite[10-3]{Warren:2002:HD:515297}.

\subsection{\RU{Определение делителя}\EN{Getting divisor}}

\subsubsection{\RU{Вариант}\EN{Variant} \#1}

\RU{Часто, код имеет вид}\EN{Often, the code has a form of}:

\lstinputlisting{patterns/11_arith_optimizations/division_by_9/form_\LANG.asm}

\RU{Определим 32-битную \IT{magic}-коэффициент через}
\EN{Let's denote 32-bit \IT{magic}-coefficient as} $M$, 
\RU{коэффициент сдвига через}\EN{shifting coefficient by} $C$ \RU{и делитель через}\EN{and divisor by} $D$.

\RU{Делитель, который нам нужен это}\EN{The divisor we need to get is}:

\[
D=\frac{2^{32 + C}}{M}
\]

\RU{Например}\EN{For example}:

\lstinputlisting[caption=\Optimizing MSVC 2012]{patterns/11_arith_optimizations/division_by_9/ex1.asm}

\RU{Это}\EN{This is}:

\[
D=\frac{2^{32 + 3}}{2021161081}
\]

\index{Wolfram Mathematica}
\RU{Числа больше чем 32-битные, так что я использовал}
\EN{Numbers are larger than 32-bit ones, so I use} Wolfram Mathematica \RU{для удобства}\EN{for convenience}:

\begin{lstlisting}[caption=Wolfram Mathematica]
In[1]:=N[2^(32+3)/2021161081]
Out[1]:=17.
\end{lstlisting}

\RU{Так что искомый делитель это}\EN{So the divisor from the code I used for example is} 17.

\RU{При делении в x64, всё то же самое, только нужно использовать}\EN{As of x64 division, things 
are the same, but} $2^{64}$ \RU{вместо}\EN{should be used instead of} $2^{32}$:

\begin{lstlisting}
uint64_t f1234(uint64_t a)
{
	return a/1234;
};
\end{lstlisting}

\begin{lstlisting}[caption=\Optimizing MSVC 2012 x64]
f1234	PROC
	mov	rax, 7653754429286296943		; 6a37991a23aead6fH
	mul	rcx
	shr	rdx, 9
	mov	rax, rdx
	ret	0
f1234	ENDP
\end{lstlisting}

\begin{lstlisting}[caption=Wolfram Mathematica]
In[1]:=N[2^(64+9)/16^^6a37991a23aead6f]
Out[1]:=1234.
\end{lstlisting}

\subsubsection{\RU{Вариант}\EN{Variant} \#2}

\RU{Бывает также вариант с пропущенным арифметическим сдвигом, например}\EN{A variant with 
omitted arithmetic shift is also exist}:

\begin{lstlisting}
		mov     eax, 55555556h ; 1431655766
		imul    ecx
		mov     eax, edx
		shr     eax, 1Fh
\end{lstlisting}

\RU{Метод определения делителя упрощается}\EN{The method of getting divisor is simplified}:

\[
D=\frac{2^{32}}{M}
\]

\RU{Для моего примера, это}\EN{As of my example, this is}:

\[
D=\frac{2^{32}}{1431655766}
\]

\index{Wolfram Mathematica}
\RU{Снова использую}
\EN{And again I use} Wolfram Mathematica:

\begin{lstlisting}[caption=Wolfram Mathematica]
In[1]:=N[2^32/16^^55555556]
Out[1]:=3.
\end{lstlisting}

\RU{Искомый делитель это}\EN{The divisor is} 3.
