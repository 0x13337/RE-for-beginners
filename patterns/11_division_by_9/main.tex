\section{\DivisionByNineSectionName}
\label{sec:divisionbynine}

\IFRU{Простая функция:}{Very simple function:}

\begin{lstlisting}
int f(int a)
{
	return a/9;
};
\end{lstlisting}

\subsection{x86}

\dots \IFRU{компилируется вполне предсказуемо:}{is compiled in a very predictable way:}

\lstinputlisting[caption=MSVC]{patterns/11_division_by_9/11_1_msvc_\LANG.asm}

\index{ARM!\Instructions!IDIV}
\IFRU{\IDIV делит 64-битное число хранящееся в паре регистров \TT{EDX:EAX} на значение в \ECX. 
В результате, \EAX будет содержать частное\FNQUOTIENT, а \EDX ~--- остаток от деления. 
Результат возвращается из функции через \EAX, так что после операции деления, 
это значение не перекладывается больше никуда, 
оно уже там где надо.}
{\IDIV divides 64-bit number stored in the \TT{EDX:EAX} register pair by value in the \ECX register.
As a result, \EAX will contain quotient\FNQUOTIENT, and \EDX~---remainder.
Result is returning from the \TT{f()} function in the \EAX register, 
so, the value is not moved anymore after division 
operation, it is in right place already.}
\IFRU
{Из-за того, что \IDIV требует пару регистров \TT{EDX:EAX}, то перед этим инструкция \TT{CDQ} 
расширяет \EAX до 64-битного значения учитывая знак, также как это делает \MOVSX.}
{Since \IDIV requires value in the \TT{EDX:EAX} register pair, \TT{CDQ} instruction (before \IDIV) extending 
value in the \EAX to 64-bit value taking value sign into account, just as \MOVSX does.}
\IFRU{Со включенной оптимизацией (\Ox) получается:}
{If we turn optimization on (\Ox), we got:}

\lstinputlisting[caption=\Optimizing MSVC]{patterns/11_division_by_9/11_1_msvc_Ox.asm}

\IFRU{Это ~--- деление через умножение. Умножение конечно быстрее работает. 
Поэтому можно используя этот трюк
\footnote{Читайте подробнее о делении через умножение в \cite[10-3]{Warren:2002:HD:515297}} 
создать код эквивалентный тому что мы хотим и работающий быстрее.}
{This is~---division by multiplication. Multiplication operation works much faster. 
And it is possible to use the trick
\footnote{Read more about division by multiplication in \cite[10-3]{Warren:2002:HD:515297}} 
to produce a code which is effectively equivalent and faster.}

\IFRU{В оптимизации компиляторов, это так же называется}{This is also called} 
``strength reduction''\EN{ in compiler optimization}.

\IFRU{GCC 4.4.1 даже без включенной оптимизации генерирует примерно такой же код, 
как и MSVC с оптимизацией:}
{GCC 4.4.1 even without optimization turned on, generates almost the same code as MSVC with optimization turned on:}

\lstinputlisting[caption=\NonOptimizing GCC 4.4.1]{patterns/11_division_by_9/11_2_gcc.asm}

\subsection{ARM}

\IFRU{В процессоре ARM, как и во многих других ``чистых'' (pure) RISC-процессорах нет инструкции деления.
Нет также возможности умножения на 32-битную константу одной инструкцией.}
{ARM processor, just like in any other ''pure'' RISC-processors, lacks division instruction
It lacks also a single instruction for multiplication by 32-bit constant.}
\IFRU{При помощи одного любопытного трюка (или \IT{хака})\footnote{hack}, можно обойтись только тремя действиями: 
сложением, вычитанием и битовыми сдвигами}
{By taking advantage of the one clever trick (or \IT{hack}), it is possible to do division using only three instructions: addition,
subtraction and bit shifts}~(\ref{sec:bitfields}).

\IFRU{Пример деления 32-битного числа на 10 из}{Here is an example of 32-bit number division by 10 from}
\cite[3.3 Division by a Constant]{ARM:1994}.
\IFRU{На выходе и частное и остаток}{Quotient and remainder on output}.

\begin{lstlisting}
; takes argument in a1
; returns quotient in a1, remainder in a2
; cycles could be saved if only divide or remainder is required
    SUB    a2, a1, #10             ; keep (x-10) for later
    SUB    a1, a1, a1, lsr #2
    ADD    a1, a1, a1, lsr #4
    ADD    a1, a1, a1, lsr #8
    ADD    a1, a1, a1, lsr #16
    MOV    a1, a1, lsr #3
    ADD    a3, a1, a1, asl #2
    SUBS   a2, a2, a3, asl #1      ; calc (x-10) - (x/10)*10
    ADDPL  a1, a1, #1              ; fix-up quotient
    ADDMI  a2, a2, #10             ; fix-up remainder
    MOV    pc, lr
\end{lstlisting}

\subsubsection{\OptimizingXcode + \ARMMode}

\begin{lstlisting}
__text:00002C58 39 1E 08 E3 E3 18 43 E3                 MOV             R1, 0x38E38E39
__text:00002C60 10 F1 50 E7                             SMMUL           R0, R0, R1
__text:00002C64 C0 10 A0 E1                             MOV             R1, R0,ASR#1
__text:00002C68 A0 0F 81 E0                             ADD             R0, R1, R0,LSR#31
__text:00002C6C 1E FF 2F E1                             BX              LR
\end{lstlisting}

\IFRU{Этот код почти тот же, что сгенерирован MSVC и GCC в режиме оптимизации.}
{This code is mostly the same to what was generated by optimizing MSVC and GCC.}
\IFRU{Должно быть, LLVM использует тот же алгоритм для поиска констант.}
{Apparently, LLVM use the same algorithm for constants generating.}

\index{ARM!\Instructions!MOV}
\index{ARM!\Instructions!MOVT}
\IFRU{Наблюдательный читатель может спросить, как \MOV записала в регистр сразу 32-битное число, 
ведь это невозможно в режиме ARM.}
{Observant reader may ask, how \MOV writes 32-bit value in register, while this is not possible in ARM mode.}
\IFRU{Действительно невозможно, но как мы видим, здесь на инструкцию 8 байт вместо стандартных 4-х,
на самом деле, здесь 2 инструкции.}
{it is impossible indeed, but, as we see,
there are 8 bytes per instruction instead of standard 4,
in fact, there are two instructions.}
\IFRU{Первая инструкция загружает в младшие 16 бит регистра значение \TT{0x8E39}, а вторая инструкция, 
на самом деле \TT{MOVT}, загружающая в старшие 16 бит регистра значение \TT{0x383E}.}
{First instruction loading \TT{0x8E39} value into low 16 bit of register and second instruction is in fact
\TT{MOVT}, it loading \TT{0x383E} into high 16-bit of register.}
\IDA \IFRU{распознала эту последовательность и для краткости, сократила всё это до одной ``псевдо-инструкции''.}
{is aware of such sequences, and for the sake of compactness, reduced it to one single ``pseudo-instruction''.}

\index{ARM!\Instructions!SMMUL}
\RU{Инструкция }\TT{SMMUL} (\IT{Signed Most Significant Word Multiply}) 
\IFRU{умножает числа считая их знаковыми (signed) и оставляет в \Reg{0} старшие 32 бита результата, 
не сохраняя младшие 32 бита.}
{instruction multiply numbers treating them as signed numbers,
and leaving high 32-bit part of result in the \Reg{0} register,
dropping low 32-bit part of result.}

\index{ARM!Optional operators!ASR}
\RU{Инструкция }\TT{``MOV R1, R0,ASR\#1''} \IFRU{это арифметический сдвиг право на один бит.}
{instruction is arithmetic shift right by one bit.}

\index{ARM!\Instructions!ADD}
\index{ARM!Data processing instructions}
\index{ARM!Optional operators!LSR}
\TT{``ADD R0, R1, R0,LSR\#31''} \IFRU{это}{is} $R0=R1 + R0>>31$

\label{shifts_in_ARM_mode}
\IFRU{Дело в том, что в режиме ARM нет отдельных инструкций для битовых сдвигов.}
{As a matter of fact, there is no separate shifting instruction in ARM mode.}
\IFRU{Вместо этого, некоторые инструкции}{Instead, an instructions like} 
(\MOV, \ADD, \SUB, \TT{RSB})\footnote{\DataProcessingInstructionsFootNote}
\IFRU{могут быть дополнены пометкой, сдвигать ли второй операнд и если да, то на сколько и как.}
{may be supplied by option, is the second operand must be shifted, if yes, by what value and how.}
\TT{ASR} \IFRU{означает}{meaning} \IT{Arithmetic Shift Right}, \TT{LSR}\EMDASH\IT{Logican Shift Right}.

\subsubsection{\OptimizingXcode + \ThumbTwoMode}

\begin{lstlisting}
MOV             R1, 0x38E38E39
SMMUL.W         R0, R0, R1
ASRS            R1, R0, #1
ADD.W           R0, R1, R0,LSR#31
BX              LR
\end{lstlisting}

\index{ARM!\Instructions!ASRS}
\IFRU{В режиме thumb отдельные инструкции для битовых сдвигов есть}
{There are separate instructions for shifting in thumb mode}, \IFRU{и здесь применяется одна из них}
{and one of them is used here}\EMDASH\TT{ASRS} (\IFRU{арифметический сдвиг вправо}{arithmetic shift right}).

\subsubsection{\NonOptimizing Xcode (LLVM) \AndENRU Keil}

\NonOptimizing LLVM 
\IFRU{не занимается генерацией подобного кода, а вместо этого просто вставляет вызов
библиотечной функции \IT{\_\_\_divsi3}}
{does not generate code we saw before in this section, but inserts a call to library function 
\IT{\_\_\_divsi3} instead}.

\IFRU{А Keil во всех случаях вставляет вызов функции}
{What about Keil: it inserts call to library function} \IT{\_\_aeabi\_idivmod}\EN{ in all cases}.

\subsection{\IFRU{Как это работает}{How it works}}

\IFRU{Вот как деление может быть заменено на умножение и деление на числа $2^{n}$}
{That's how division can be replaced by multiplication and division by $2^{n}$ numbers}:

\[
	result = 
	\frac{input}{divisor} = 
	\frac{input \cdot \frac{2^{n}}{divisor}}{2^{n}} = 
	\frac{input \cdot M}{2^{n}}
\]

\IFRU{Где}{Where} $M$ \IFRU{это}{is} \IT{magic}-\IFRU{коэффициент}{coefficient}.

\IFRU{Как вычислить $M$}{That's how $M$ can be computed}:

\[
	M = \frac{2^{n}}{divisor}
\]

\IFRU{Так что эти фрагменты кода обычно имеют форму}
{So these code snippets are usually have this form}:

\[
	result = \frac{input \cdot M}{2^{n}}
\]

\IFRU{$n$ это произвольное число, оно может быть 32 (тогда старшая часть результата умножения берется из
регистра \EDX или \RDX) или 31 (тогда старшая часть результата умножения дополнительно сдвигается)}
{$n$ can be arbitrary number, it may be 32 (then high part of multiplication result is taked from
\EDX or \RDX register), or 31 (then high part of multiplication result is shifted right additionally)}.

$n$ \IFRU{выбирается так, чтобы улучшить точность результата}{is choosen in order to minimize
error}.

\IFRU{Если делать знаковое деление, знак результата умножения также добавляется к результату}
{When doing signed division, sign of multiplication result also added to the output result}.

\IFRU{Посмотрите на разницу}{Take a look at the difference}:

\begin{lstlisting}
int f3_32_signed(int a)
{
	return a/3;
};

unsigned int f3_32_unsigned(unsigned int a)
{
	return a/3;
};
\end{lstlisting}

\IFRU{В беззнаковой версии функции}{In the unsigned version of function}, 
\IT{magic}-\IFRU{коэффициент это}{coefficient is} \TT{0xAAAAAAAB} \IFRU{и результат умножения делится на}
{and multiplication result is divided by} $2^33$.

\IFRU{В знаковой версии функции}{In the signed version of function}, \IT{magic}-\IFRU{коэффициент это}
{coefficient is} \TT{0x55555556} \IFRU{и результат умножения делится на}
{and multiplication result is divided by} $2^{32}$. 
\IFRU{Знак результата умножения также учитывается: старшие 32 бита результата сдвигаются на 32
(таким образом, оставляя знак в самом младшем бите\EAX).}
{Sign also taken from multiplication result: high 32 bits of result is shifted by 31 
(leaving sign in least significant bit of \EAX).}
$1$ \IFRU{прибавляется к конечному результату, если знак отрицательный}
{is added to the final result if sign is negative}.

\lstinputlisting[caption=MSVC 2012 /Ox]{patterns/11_division_by_9/2_\LANG.asm}

\IFRU{Читайте больше об этом в}{Read more about it in} \cite[10-3]{Warren:2002:HD:515297}.

\subsection{\IFRU{Определение делителя}{Getting divisor}}

\subsubsection{\IFRU{Вариант}{Variant} \#1}

\IFRU{Часто, код имеет вид}{Often, the code has a form of}:

\lstinputlisting{patterns/11_division_by_9/form_\LANG.asm}

\IFRU{Определим 32-битную \IT{magic}-коэффициент через}
{Let's denote 32-bit \IT{magic}-coefficient as} $M$, 
\IFRU{коэффициент сдвига через}{shifting coefficient by} $C$ \IFRU{и делитель через}{and divisor by} $D$.

\IFRU{Делитель, который нам нужен это}{The divisor we need to get is}:

\[
D=\frac{2^{32 + C}}{M}
\]

\IFRU{Например}{For example}:

\lstinputlisting[caption=\Optimizing MSVC 2012]{patterns/11_division_by_9/ex1.asm}

\IFRU{Это}{This is}:

\[
D=\frac{2^{32 + 3}}{2021161081}
\]

\index{Wolfram Mathematica}
\IFRU{Числа больше чем 32-битные, так что я использовал}
{Numbers are larger than 32-bit ones, so I use} Wolfram Mathematica \IFRU{для удобства}{for convenience}:

\begin{lstlisting}[caption=Wolfram Mathematica]
In[1]:=N[2^(32+3)/2021161081]
Out[1]:=17.
\end{lstlisting}

\IFRU{Так что искомый делитель это}{So the divisor from the code I used for example is} 17.

\IFRU{При делении в x64, всё то же самое, только нужно использовать}{As of x64 division, things 
are the same, but} $2^{64}$ \IFRU{вместо}{should be used instead of} $2^{32}$:

\begin{lstlisting}
uint64_t f1234(uint64_t a)
{
	return a/1234;
};
\end{lstlisting}

\begin{lstlisting}[caption=MSVC 2012 x64 /Ox]
f1234	PROC
	mov	rax, 7653754429286296943		; 6a37991a23aead6fH
	mul	rcx
	shr	rdx, 9
	mov	rax, rdx
	ret	0
f1234	ENDP
\end{lstlisting}

\begin{lstlisting}[caption=Wolfram Mathematica]
In[1]:=N[2^(64+9)/16^^6a37991a23aead6f]
Out[1]:=1234.
\end{lstlisting}

\subsubsection{\IFRU{Вариант}{Variant} \#2}

\IFRU{Бывает также вариант с пропущенным арифметическим сдвигом, например}{A variant with 
omitted arithmetic shift is also exist}:

\begin{lstlisting}
		mov     eax, 55555556h ; 1431655766
		imul    ecx
		mov     eax, edx
		shr     eax, 1Fh
\end{lstlisting}

\IFRU{Метод определения делителя упрощается}{The method of getting divisor is simplified}:

\[
D=\frac{2^{32}}{M}
\]

\IFRU{Для моего примера, это}{As of my example, this is}:

\[
D=\frac{2^{32}}{1431655766}
\]

\index{Wolfram Mathematica}
\IFRU{Снова использую}
{And again I use} Wolfram Mathematica:

\begin{lstlisting}[caption=Wolfram Mathematica]
In[1]:=N[2^32/16^^55555556]
Out[1]:=3.
\end{lstlisting}

\IFRU{Искомый делитель это}{The divisor is} 3.


