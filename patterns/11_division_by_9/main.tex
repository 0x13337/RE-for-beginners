\section{\DivisionByNineSectionName}
\label{sec:divisionbynine}

\IFRU{Простая функция:}{Very simple function:}

\begin{lstlisting}
int f(int a)
{
	return a/9;
};
\end{lstlisting}

\subsection{x86}

\dots \IFRU{компилируется вполне предсказуемо:}{is compiled in a very predictable way:}

\lstinputlisting[caption=MSVC]{patterns/11_division_by_9/11_1_msvc_\IFRU{ru}{en}.asm}

\index{ARM!\Instructions!IDIV}
\IFRU{\IDIV делит 64-битное число хранящееся в паре регистров \TT{EDX:EAX} на значение в \ECX. 
В результате, \EAX будет содержать частное\FNQUOTIENT, а \EDX ~--- остаток от деления. 
Результат возвращается из функции через \EAX, так что после операции деления, 
это значение не перекладывается больше никуда, 
оно уже там где надо.}
{\IDIV divides 64-bit number stored in the \TT{EDX:EAX} register pair by value in the \ECX register.
As a result, \EAX will contain quotient\FNQUOTIENT, and \EDX~---remainder.
Result is returning from the \TT{f()} function in the \EAX register, 
so, the value is not moved anymore after division 
operation, it is in right place already.}
\IFRU
{Из-за того что \IDIV требует пару регистров \TT{EDX:EAX}, то перед этим инструкция \TT{CDQ} 
расширяет \EAX до 64-битного значения учитывая знак, также как это делает \MOVSX.}
{Since \IDIV requires value in the \TT{EDX:EAX} register pair, \TT{CDQ} instruction (before \IDIV) extending 
value in the \EAX to 64-bit value taking value sign into account, just as \MOVSX does.}
\IFRU{Со включенной оптимизацией (\Ox) получается:}
{If we turn optimization on (\Ox), we got:}

\lstinputlisting[caption=\Optimizing MSVC]{patterns/11_division_by_9/11_1_msvc_Ox.asm}

\newcommand{\URLMSDN}{\href{http://blogs.msdn.com/b/devdev/archive/2005/12/12/502980.aspx}
{MSDN: Integer division by constants}}
\newcommand{\URLN}{http://www.nynaeve.net/?p=115}

\IFRU{Это ~--- деление через умножение. Умножение конечно быстрее работает. 
Поэтому можно используя этот трюк
\footnote{Читайте подробнее о делении через умножение в \cite[10-3]{Warren:2002:HD:515297}
и \URLMSDN, \url{\URLN}} 
создать код эквивалентный тому что мы хотим и работающий быстрее.}
{This is~---division by multiplication. Multiplication operation works much faster. 
And it is possible to use the trick
\footnote{Read more about division by multiplication in \cite[10-3]{Warren:2002:HD:515297}
and: \URLMSDN, \url{\URLN}} 
to produce a code which is effectively equivalent and faster.}
\IFRU
{GCC 4.4.1 даже без включенной оптимизации генерит примерно такой же код как и MSVC с оптимизацией:}
{GCC 4.4.1 even without optimization turned on, generates almost the same code as MSVC with optimization turned on:}

\lstinputlisting[caption=\NonOptimizing GCC 4.4.1]{patterns/11_division_by_9/11_2_gcc.asm}

\subsection{ARM}

\IFRU{В процессоре ARM, как и во многих других ``чистых'' (pure) RISC-процессорах нет инструкции деления.
Нет также возможности умножения на 32-битную константу одной инструкцией.}
{ARM processor, just like in any other ''pure'' RISC-processors, lacks division instruction
It lacks also a single instruction for multiplication by 32-bit constant.}
\IFRU{При помощи одного любопытного трюка (или \IT{хака})\footnote{hack}, можно обойтись только тремя действиями: 
сложением, вычитанием и битовыми сдвигами}
{By taking advantage of the one clever trick (or \IT{hack}), it is possible to do division using only three instructions: addition,
subtraction and bit shifts}~(\ref{sec:bitfields}).

\IFRU{Пример деления 32-битного числа на 10 из}{Here is an example of 32-bit number division by 10 from}
\cite[3.3 Division by a Constant]{ARM:1994}.
\IFRU{На выходе и частное и остаток}{Quotient and remainder on output}.

\begin{lstlisting}
; takes argument in a1
; returns quotient in a1, remainder in a2
; cycles could be saved if only divide or remainder is required
    SUB    a2, a1, #10             ; keep (x-10) for later
    SUB    a1, a1, a1, lsr #2
    ADD    a1, a1, a1, lsr #4
    ADD    a1, a1, a1, lsr #8
    ADD    a1, a1, a1, lsr #16
    MOV    a1, a1, lsr #3
    ADD    a3, a1, a1, asl #2
    SUBS   a2, a2, a3, asl #1      ; calc (x-10) - (x/10)*10
    ADDPL  a1, a1, #1              ; fix-up quotient
    ADDMI  a2, a2, #10             ; fix-up remainder
    MOV    pc, lr
\end{lstlisting}

\subsubsection{\OptimizingXcode + \ARMMode}

\begin{lstlisting}
__text:00002C58 39 1E 08 E3 E3 18 43 E3                 MOV             R1, 0x38E38E39
__text:00002C60 10 F1 50 E7                             SMMUL           R0, R0, R1
__text:00002C64 C0 10 A0 E1                             MOV             R1, R0,ASR#1
__text:00002C68 A0 0F 81 E0                             ADD             R0, R1, R0,LSR#31
__text:00002C6C 1E FF 2F E1                             BX              LR
\end{lstlisting}

\IFRU{Этот код почти тот же, что сгенерирован MSVC и GCC в режиме оптимизации.}
{This code is mostly the same to what was generated by optimizing MSVC and GCC.}
\IFRU{Должно быть, LLVM использует тот же алгоритм для поиска констант.}
{Apparently, LLVM use the same algorithm for constants generating.}

\index{ARM!\Instructions!MOV}
\index{ARM!\Instructions!MOVT}
\IFRU{Наблюдательный читатель может спросить, как \MOV записала в регистр сразу 32-битное число, 
ведь это невозможно в режиме ARM.}
{Observant reader may ask, how \MOV writes 32-bit value in register, while this is not possible in ARM mode.}
\IFRU{Действительно невозможно, но как мы видим, здесь на инструкцию 8 байт вместо стандартных 4-х,
на самом деле, здесь 2 инструкции.}
{It is not possible indeed, but, as we see,
there are 8 bytes per instruction instead of standard 4,
in fact, there are two instructions.}
\IFRU{Первая инструкция загружает в младшие 16 бит регистра значение \TT{0x8E39}, а вторая инструкция, 
на самом деле \TT{MOVT}, загружающая в старшие 16 бит регистра значение \TT{0x383E}.}
{First instruction loading \TT{0x8E39} value into low 16 bit of register and second instruction is in fact
\TT{MOVT}, it loading \TT{0x383E} into high 16-bit of register.}
\IDA \IFRU{распознала эту последовательность и для краткости, сократила всё это до одной ``псевдо-инструкции''.}
{is aware of such sequences, and for the sake of compactness, reduced it to one single ``pseudo-instruction''.}

\index{ARM!\Instructions!SMMUL}
\IFRU{Инструкция }{}\TT{SMMUL} (\IT{Signed Most Significant Word Multiply}) 
\IFRU{умножает числа считая их знаковыми (signed) и оставляет в \Rzero старшие 32 бита результата, 
не сохраняя младшие 32 бита.}
{instruction multiply numbers treating them as signed numbers,
and leaving high 32-bit part of result in the \Rzero register,
dropping low 32-bit part of result.}

\index{ARM!Optional operators!ASR}
\IFRU{Инструкция }{}\TT{``MOV R1, R0,ASR\#1''} \IFRU{это арифметический сдвиг право на один бит.}
{instruction is arithmetic shift right by one bit.}

\index{ARM!\Instructions!ADD}
\index{ARM!Data processing instructions}
\index{ARM!Optional operators!LSR}
\TT{``ADD R0, R1, R0,LSR\#31''} \IFRU{это}{is} $R0=R1 + R0>>31$

\label{shifts_in_ARM_mode}
\IFRU{Дело в том что в режиме ARM нет отдельных инструкций для битовых сдвигов.}
{As a matter of fact, there is no separate shifting instruction in ARM mode.}
\IFRU{Вместо этого, некоторые инструкции}{Instead, an instructions like} 
(\MOV, \ADD, \SUB, \TT{RSB})\footnote{\DataProcessingInstructionsFootNote}
\IFRU{могут быть дополнеты пометкой, сдвигать ли второй операнд и если да, то на сколько и как.}
{may be supplied by option, is the second operand must be shifted, if yes, by what value and how.}
\TT{ASR} \IFRU{означает}{meaning} \IT{Arithmetic Shift Right}, \TT{LSR}\EMDASH\IT{Logican Shift Right}.

\subsubsection{\OptimizingXcode + \ThumbTwoMode}

\begin{lstlisting}
MOV             R1, 0x38E38E39
SMMUL.W         R0, R0, R1
ASRS            R1, R0, #1
ADD.W           R0, R1, R0,LSR#31
BX              LR
\end{lstlisting}

\index{ARM!\Instructions!ASRS}
\IFRU{В режиме thumb отдельные инструкции для битовых сдвигов есть}
{There are separate instructions for shifting in thumb mode}, \IFRU{и здесь применяется одна из них}
{and one of them is used here}\EMDASH\TT{ASRS} (\IFRU{арифметический сдвиг вправо}{arithmetic shift right}).

\subsubsection{\NonOptimizing Xcode (LLVM) \AndENRU Keil}

\NonOptimizing LLVM 
\IFRU{не занимается генерацией подобного кода а вместо этого просто вставляет вызов
библиотечной функции \IT{\_\_\_divsi3}}
{does not generate code we saw before in this section, but inserts a call to library function 
\IT{\_\_\_divsi3} instead}.

\IFRU{А Keil во всех случаях вставляет вызов функции}
{What about Keil: it inserts call to library function} \IT{\_\_aeabi\_idivmod}\IFRU{}{ in all cases}.

\subsection{\IFRU{Определение делителя}{Getting divisor}}

\subsubsection{\IFRU{Вариант}{Variant} \#1}

\IFRU{Часто, код имеет вид}{Often, the code has a form of}:

\lstinputlisting{patterns/11_division_by_9/form_\IFRU{RU}{EN}.asm}

\IFRU{Определим 32-битную магическую константу через}{Let's denote 32-bit magical constant as} $M$, 
\IFRU{коэффициент сдвига через}{shifting coefficient by} $C$ \IFRU{и делитель через}{and divisor by} $D$.

\IFRU{Делитель который нам нужен это}{The divisor we need to get is}:

\[
D=\frac{2^{32} \cdot 2^C}{M}
\]

\IFRU{Например}{For example}:

\lstinputlisting[caption=\Optimizing MSVC 2012]{patterns/11_division_by_9/ex1.asm}

\IFRU{Это}{This is}:

\[
D=\frac{2^{32} \cdot 2^3}{2021161081}
\]

\index{Wolfram Mathematica}
\IFRU{Числа больше чем 32-битные, так что я использовал}
{Numbers are larger than 32-bit ones, so I use} Wolfram Mathematica \IFRU{для удобства}{for convenience}:

\begin{lstlisting}
In[1]:=N[2^32*2^3/2021161081]

Out[1]:=17.
\end{lstlisting}

\IFRU{Так что искомый делитель это}{So the divisor from the code I used for example is} 17.

\subsubsection{\IFRU{Вариант}{Variant} \#2}

\IFRU{Бывает также вариант с пропущенным арифметическим сдвигом, например}{A variant with omitted arithmetic
shift is also exist}:

\begin{lstlisting}
		mov     eax, 55555556h ; 1431655766
		imul    ecx
		mov     eax, edx
		shr     eax, 1Fh
\end{lstlisting}

\IFRU{Метод определения делителя упрощается}{The method of getting divisor is simplified}:

\[
D=\frac{2^{32}}{M}
\]

\IFRU{Для моего примера, это}{As of my example, this is}:

\[
D=\frac{2^{32}}{1431655766}
\]

\index{Wolfram Mathematica}
\IFRU{Снова использую}
{And again I use} Wolfram Mathematica:

\begin{lstlisting}
In[1]:=N[2^32/16^^55555556]

Out[1]:=3.
\end{lstlisting}

\IFRU{Искомый делитель это}{The divisor is} 3.

