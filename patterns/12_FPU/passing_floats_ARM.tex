\subsection{ARM + \NonOptimizingXcode + \ThumbTwoMode}

\lstinputlisting{patterns/12_FPU/passing_floats_Xcode_thumb_O0.asm}

\IFRU{Как я уже писал, 64-битные числа с плавающей точкой передаются в парах R-регистров.}
{As I wrote before, 64-bit floating pointer numbers passing in R-registers pairs.}
\IFRU{Этот код слегка избыточен (наверное, потому что не включена оптимизация), ведь, можно было бы 
загружать значения напрямую в R-регистры минуя загрузку в D-регистры.}
{This is code is redundant for a little (certainly because optimization is turned off), because,
it is actually possible to load values into R-registers straightforwardly without touching D-registers.}

\IFRU{Итак, видно, что функция}{So, as we see,} \TT{\_pow} \IFRU{получает первый аргумент в}
{function receiving first argument in} \Reg{0} \AndENRU \Reg{1}, \IFRU{а второй в}{and the second one in} 
\Reg{2} \AndENRU \Reg{3}. 
\IFRU{Функция оставляет результат в}{Function leaves result in} \Reg{0} \AndENRU \Reg{1}.
\IFRU{Результат работы}{Result of} \TT{\_pow} \IFRU{перекладывается в}{is moved into} \TT{D16}, 
\IFRU{затем в пару}{then in} \Reg{1} \AndENRU \Reg{2}\EN{ pair}, \IFRU{откуда}{from where} 
\printf \IFRU{будет читать это число}{will take this number}.

\subsection{ARM + \NonOptimizingKeil + \ARMMode}

\lstinputlisting{patterns/12_FPU/passing_floats_Keil_ARM_O0.asm}

\IFRU{Здесь не используются D-регистры, используются только пары R-регистров.}
{D-registers are not used here, only R-register pairs are used.}

