\section{\ShiftsSectionName}

\RU{Битовые сдвиги в \CCpp реализованы при помощи операторов $\ll$ и $\gg$.}
\EN{Bit shifts in \CCpp are implemented via $\ll$ and $\gg$ operators.}

\RU{В x86 есть инструкции}\EN{x86 \ac{ISA} has} SHL (SHift Left) \AndENRU SHR (SHift Right) 
\RU{для этого}\EN{instructions for this}.

\subsection{\RU{Деление и умножение при помощи сдвигов}\EN{Division and multiplication using shifts}}

\RU{Инструкции сдвига также активно применяются при делении или умножении 
на числа-степени двойки: $2^{n}$ (т.е., $1$, $2$, $4$, $8$, и т.д.).}
\EN{Shift instructions are often used in division and multiplications by power of two numbers:
$2^{n}$ (e.g., $1$, $2$, $4$, $8$, etc).}

\subsubsection{\RU{Умножение}\EN{Multiplication}}

\begin{lstlisting}
unsigned int f(unsigned int a)
{
	return a*4;
};
\end{lstlisting}

\begin{lstlisting}[caption=\NonOptimizing MSVC 2010]
_a$ = 8		; size = 4
_f	PROC
	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR _a$[ebp]
	shl	eax, 2
	pop	ebp
	ret	0
_f	ENDP
\end{lstlisting}

\RU{Умножить на $4$ это просто сдвинуть число на 2 бита влево, 
вставив 2 нулевых бита справа (как два самых младших бита). 
Это как умножить $3$ на $100$ ~--- нужно просто дописать два нуля справа.}
\EN{Multiplication by $4$ is just shifting the number to the left by 2 bits,
while inserting 2 zero bits at right (as the last two bits).
It is just like to multiply $3$ by $100$~---we need just to add two zeroes at the right.}

\RU{Вот как работает инструкция сдвига влево}\EN{That's how shift left instruction works}:

\index{x86!\Instructions!SHL}
\input{shift_left}

\RU{Добавленные биты справа --- всегда нули}\EN{Added bits at right---always zeroes}.

\RU{Умножение на 4 в}\EN{Multiplication by 4 in} ARM:

\begin{lstlisting}[caption=\NonOptimizingKeil + \ARMMode]
f PROC
        LSL      r0,r0,#2
        BX       lr
        ENDP
\end{lstlisting}

\subsubsection{\RU{Деление}\EN{Division}}

\RU{Например}\EN{For example}:

\begin{lstlisting}
unsigned int f(unsigned int a)
{
	return a/4;
};
\end{lstlisting}

\RU{Имеем в итоге}\EN{We got} (MSVC 2010):

\begin{lstlisting}[caption=MSVC 2010]
_a$ = 8							; size = 4
_f	PROC
	mov	eax, DWORD PTR _a$[esp-4]
	shr	eax, 2
	ret	0
_f	ENDP
\end{lstlisting}

\label{SHR}
\index{x86!\Instructions!SHR}
\RU{Инструкция \SHR (\IT{SHift Right}) в данном примере сдвигает число на 2 бита вправо. 
При этом, освободившиеся два бита слева (т.е., самые 
старшие разряды), выставляются в нули. А самые младшие 2 бита выкидываются. 
Фактически, эти два выкинутых бита ~--- остаток от деления.}
\EN{\SHR (\IT{SHift Right}) instruction in this example is shifting a number by 2 bits right.
Two freed bits at left (e.g., two most significant bits) are set to zero.
Two least significant bits are dropped.
In fact, these two dropped bits~---division operation remainder.}

\index{x86!\Instructions!SHR}
\RU{Инструкция \SHR работает так же, как и \SHL, только в другую сторону.}
\EN{\SHR instruction works just like as \SHL but in other direction.}

\input{shift_right}

\label{division_by_shifting}
\RU{Для того, чтобы это проще понять, представьте себе десятичную систему счисления и число $23$. 
$23$ можно разделить на $10$ просто откинув последний разряд ($3$ ~--- это остаток от деления). 
После этой операции останется $2$ как \glslink{quotient}{частное}.}
\EN{It can be easily understood if to imagine decimal numeral system and number $23$.
$23$ can be easily divided by $10$ just by dropping last digit ($3$~---is division remainder). 
$2$ is leaving after operation as a \gls{quotient}.}

\RU{Деление на 4 в}\EN{Division by 4 in} ARM:

\begin{lstlisting}[caption=\NonOptimizingKeil + \ARMMode]
f PROC
        LSR      r0,r0,#2
        BX       lr
        ENDP
\end{lstlisting}

\subsection{\RU{Подсчет выставленных бит}\EN{Counting bits set to 1}}

\RU{Вот этот несложный пример иллюстрирует функцию, считающую количество бит-единиц во входной переменной.}
\EN{Here is a simple example of function, calculating number of $1$ bits in input variable.}

\RU{Эта ф-ция также называется}\EN{This function is also called} ``population count''
\footnote{\RU{современные x86-процессоры (поддерживающие SSE4) даже имеют инструкцию POPCNT для этого}
\EN{modern x86 CPUs (supporting SSE4) even have POPCNT instruction for it}}.

\lstinputlisting{patterns/14_bitfields/3_shifts/shifts.c}

\RU{В этом цикле, счетчик итераций \IT{i} считает от $0$ до $31$, а $1 \ll i$ будет от $1$ до \TT{0x80000000}. 
Описывая это словами, можно сказать 
\IT{сдвинуть единицу на $n$ бит влево}.
Т.е., в некотором смысле, выражение $1 \ll i$ последовательно выдаст все возможные позиции бит в 32-битном числе. 
Кстати, освободившийся бит справа всегда обнуляется.}
\EN{In this loop, iteration count value \IT{i} counting from $0$ to $31$, $1 \ll i$ statement will be counting 
from $1$ to \TT{0x80000000}.
Describing this operation in natural language, we would say \IT{shift $1$ by n bits left}.
In other words, $1 \ll i$ statement will consequently produce all possible bit positions in 32-bit number.
By the way, freed bit at right is always cleared.}

\RU{Вот таблица всех возможных значений}\EN{Here is a table of all possible} $1 \ll i$ 
\RU{для}\EN{for} $i=0 \ldots 31$:

\begin{center}
\begin{tabular}{ | l | l | l | l | }
\hline
\cellcolor{blue!25} \RU{Выражение в }\CCpp\EN{ expression} & 
\cellcolor{blue!25} \RU{Степень двойки}\EN{Power of two} & 
\cellcolor{blue!25} \RU{Десятичная форма}\EN{Decimal form} & 
\cellcolor{blue!25} \RU{Шестнадцатеричная форма}\EN{Hexadecimal form} \\
\hline
$1 \ll 0$ & 1 & 1 & 1 \\
\hline
$1 \ll 1$ & $2^{1}$ & 2 & 2 \\
\hline
$1 \ll 2$ & $2^{2}$ & 4 & 4 \\
\hline
$1 \ll 3$ & $2^{3}$ & 8 & 8 \\
\hline
$1 \ll 4$ & $2^{4}$ & 16 & 0x10 \\
\hline
$1 \ll 5$ & $2^{5}$ & 32 & 0x20 \\
\hline
$1 \ll 6$ & $2^{6}$ & 64 & 0x40 \\
\hline
$1 \ll 7$ & $2^{7}$ & 128 & 0x80 \\
\hline
$1 \ll 8$ & $2^{8}$ & 256 & 0x100 \\
\hline
$1 \ll 9$ & $2^{9}$ & 512 & 0x200 \\
\hline
$1 \ll 10$ & $2^{10}$ & 1024 & 0x400 \\
\hline
$1 \ll 11$ & $2^{11}$ & 2048 & 0x800 \\
\hline
$1 \ll 12$ & $2^{12}$ & 4096 & 0x1000 \\
\hline
$1 \ll 13$ & $2^{13}$ & 8192 & 0x2000 \\
\hline
$1 \ll 14$ & $2^{14}$ & 16384 & 0x4000 \\
\hline
$1 \ll 15$ & $2^{15}$ & 32768 & 0x8000 \\
\hline
$1 \ll 16$ & $2^{16}$ & 65536 & 0x10000 \\
\hline
$1 \ll 17$ & $2^{17}$ & 131072 & 0x20000 \\
\hline
$1 \ll 18$ & $2^{18}$ & 262144 & 0x40000 \\
\hline
$1 \ll 19$ & $2^{19}$ & 524288 & 0x80000 \\
\hline
$1 \ll 20$ & $2^{20}$ & 1048576 & 0x100000 \\
\hline
$1 \ll 21$ & $2^{21}$ & 2097152 & 0x200000 \\
\hline
$1 \ll 22$ & $2^{22}$ & 4194304 & 0x400000 \\
\hline
$1 \ll 23$ & $2^{23}$ & 8388608 & 0x800000 \\
\hline
$1 \ll 24$ & $2^{24}$ & 16777216 & 0x1000000 \\
\hline
$1 \ll 25$ & $2^{25}$ & 33554432 & 0x2000000 \\
\hline
$1 \ll 26$ & $2^{26}$ & 67108864 & 0x4000000 \\
\hline
$1 \ll 27$ & $2^{27}$ & 134217728 & 0x8000000 \\
\hline
$1 \ll 28$ & $2^{28}$ & 268435456 & 0x10000000 \\
\hline
$1 \ll 29$ & $2^{29}$ & 536870912 & 0x20000000 \\
\hline
$1 \ll 30$ & $2^{30}$ & 1073741824 & 0x40000000 \\
\hline
$1 \ll 31$ & $2^{31}$ & 2147483648 & 0x80000000 \\
\hline
\end{tabular}
\end{center}

\RU{Это числа-константы (битовые маски), которые крайне часто попадаются в практике reverse engineer-а, и их нужно
уметь распозновать.}
\EN{These constant numbers (bit masks) are very often appears in code and practicing reverse engineer should quickly
to spot them.}
\RU{Числа в десятичном виде заучивать, пожалуй, незачем, а числа в шестнадцатиричном
виде итак легко запомнить.}
\EN{You probably shouldn't memorize decimal numbers, but hexadecimal ones are very easy to remember.}

\RU{Эти константы очень часто используются для определения отдельных бит как флагов.}
\EN{These constants are very often used for mapping flags to specific bits.}
\RU{Например, это из файла}\EN{For example, here is excerpt from} \TT{ssl\_private.h} \RU{из исходников}
\EN{file from} Apache 2.4.6\EN{ source code}:

\begin{lstlisting}
/**
 * Define the SSL options
 */
#define SSL_OPT_NONE           (0)
#define SSL_OPT_RELSET         (1<<0)
#define SSL_OPT_STDENVVARS     (1<<1)
#define SSL_OPT_EXPORTCERTDATA (1<<3)
#define SSL_OPT_FAKEBASICAUTH  (1<<4)
#define SSL_OPT_STRICTREQUIRE  (1<<5)
#define SSL_OPT_OPTRENEGOTIATE (1<<6)
#define SSL_OPT_LEGACYDNFORMAT (1<<7)
\end{lstlisting}

\RU{Вернемся назад к нашему примеру}\EN{Let's back to our example}.

\RU{Макрос \TT{IS\_SET} проверяет наличие этого бита в \TT{a}.}
\EN{\TT{IS\_SET} macro is checking bit presence in the \TT{a}.}

\index{x86!\Instructions!AND}
\RU{Макрос \TT{IS\_SET} на самом деле это операция логического И (\IT{AND}) 
и она возвращает $0$ если бита там нет, 
либо эту же битовую маску, если бит там есть. 
В \CCpp, конструкция \TT{if()} срабатывает, если выражение внутри её не ноль, пусть хоть $123456$, 
поэтому все будет работать.}
\EN{The \TT{IS\_SET} macro is in fact logical and operation (\IT{AND}) 
and it returns $0$ if specific bit is absent there,
or bit mask, if the bit is present.
\IT{if()} operator triggered in \CCpp if expression in it is not a zero, it might be even $123456$, that is why
it always working correctly.}

% subsubsections
\input{patterns/14_bitfields/3_shifts/x86}
\input{patterns/14_bitfields/3_shifts/ARM}
