\chapter{\RU{Inline-функции}\EN{Inline functions}}
\index{Inline code}
\label{inline_code}

\RU{Inline-код это когда компилятор, вместо того чтобы генерировать инструкцию вызова небольшой функции,
просто вставляет её тело прямо в это место.}
\EN{Inlined code is when compiler, instead of placing call instruction to small or tiny function,
just placing its body right in-place.}

\lstinputlisting[caption=\RU{Простой пример}\EN{Simple example}]{patterns/22_inline_function/1.c}

\RU{... это компилируется вполне предсказуемо, хотя, если включить оптимизации GCC (\Othree), мы увидим:}
\EN{... is compiled in very predictable way, however, if to turn on GCC optimization (\Othree), we'll see:}

\lstinputlisting[caption=GCC 4.8.1 \Othree]{patterns/22_inline_function/1.s}

(\RU{Здесь деление заменено умножением}\EN{Here division is done by multiplication}(\ref{sec:divisionbynine}).)

\RU{Да, наша маленькая ф-ция \TT{celsius\_to\_fahrenheit()} была помещена прямо перед вызовом \printf.}
\EN{Yes, our small function \TT{celsius\_to\_fahrenheit()} was just placed before \printf call.}
\RU{Почему? Это может быть быстрее чем исполнять код самой ф-ции плюс затраты на вызов и возврат.}
\EN{Why? It may be faster than executing this function's code plus calling/returning overhead.}

\RU{В прошлом, такие ф-ции нужно было маркировать ключевым словом ``inline'' в определении ф-ции, хотя,
в наше время, такие ф-ции выбираются компилятором автоматически.}
\EN{In past, such function must be marked with ``inline'' keyword in function's declaration, however,
in modern times, these functions are chosen automatically by compiler.}

% sections
\input{patterns/22_inline_function/str_mem/main}
