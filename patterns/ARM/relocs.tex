\section{\RU{Релоки}\EN{Relocs} \InENRU ARM64}
\label{ARM64_relocs}

\RU{Как известно, в ARM64 инструкции 4-байтные, так что записать длинное число в регистр одной инструкцией нельзя.}
\EN{As we know, there are 4-byte instructions in ARM64, so it is impossible to write large number into register
using single instruction.}
\RU{Тем не менее, файл может быть загружен по произвольному адресу в памяти, для этого релоки и нужны.}
\EN{Nevertheless, image may be loaded at random address in memory, so that's why relocs exists.}
\RU{Больше о них (в связи с Win32 PE)}\EN{Read more about them (in relation to Win32 PE)}: \ref{subsec:relocs}.

\index{ARM!\Instructions!ADRP/ADD pair}
\RU{В ARM64 принят следующий метод: адрес формируется при помощи пары инструкций: \TT{ADRP} и \ADD.}
\EN{Address is formed using \TT{ADRP} and \ADD instructions pair in ARM64.}
\RU{Первая загружает в регистр адрес 4Kb-страницы, а вторая прибавляет остаток.}
\EN{The first loads 4Kb-page address and the second adding remainder.}
\RU{Я скомпилировал пример из}\EN{I compiled example from} ``\HelloWorldSectionName'' 
(\lstref{hw_c}) \InENRU GCC (Linaro) 4.9 \RU{под}\EN{under} win32:

\begin{lstlisting}[caption=GCC (Linaro) 4.9 \AndENRU objdump \EN{of object file}\RU{объектного файла}]
...>aarch64-linux-gnu-gcc.exe hw.c -c

...>aarch64-linux-gnu-objdump.exe -d hw.o

...

0000000000000000 <main>:
   0:   a9bf7bfd        stp     x29, x30, [sp,#-16]!
   4:   910003fd        mov     x29, sp
   8:   90000000        adrp    x0, 0 <main>
   c:   91000000        add     x0, x0, #0x0
  10:   94000000        bl      0 <printf>
  14:   52800000        mov     w0, #0x0                        // #0
  18:   a8c17bfd        ldp     x29, x30, [sp],#16
  1c:   d65f03c0        ret

...>aarch64-linux-gnu-objdump.exe -r hw.o

...

RELOCATION RECORDS FOR [.text]:
OFFSET           TYPE              VALUE
0000000000000008 R_AARCH64_ADR_PREL_PG_HI21  .rodata
000000000000000c R_AARCH64_ADD_ABS_LO12_NC  .rodata
0000000000000010 R_AARCH64_CALL26  printf
\end{lstlisting}

\RU{Итак, в этом объектом файле три релока.}
\EN{So there are 3 relocs in this object file.}

\begin{itemize}
\item 
\RU{Самый первый берет адрес страницы, отсекает младшие 12 бит и записывает оставшиеся старшие 21
в битовые поля инструкции \TT{ADRP}. Это потому что младшие 12 бит кодировать не нужно,
и в ADRP выделено место только для 21 бит.}
\EN{The very first takes page address, cuts lowest 12 bits and writes remaining high 21 bits
into \TT{ADRP} instruction bit fields. This is because we don't need to encode low 12 bits,
and ADRP instruction has space only for 21 bits.}

\item \RU{Второй ---- 12 бит адреса, относительного от начала страницы, в поля инструкции \ADD.}
\EN{Second---12 bit of address relative to page start, into \ADD instruction bit fields.}

\item \RU{Последний, 26-битный, накладывается на инструкцию по адресу \TT{0x10}, где переход на ф-цию \printf.}
\EN{Last, 26-bit one, is applied to the instruction at \TT{0x10} address where the 
jump to the \printf function is.}
\RU{Все адреса инструкций в ARM64 (да и в ARM в режиме ARM) имеют нули в двух младших битах
(потому что все инструкции имеют размер в 4 байта),
так что нужно кодировать только старшие 26 бит из 28-битного адресного пространства ($\pm 128$MB).}
\EN{All ARM64 (and in ARM in ARM mode) instruction addresses has zeroes in two lowest bits
(because all instructions has size of 4 bytes),
so one need to encode only highest 26 bits of 28-bit address space ($\pm 128$MB).}

\end{itemize}

\RU{В слинкованном исполняемом файле релоков в этих местах нет: потому что там уже точно известно, 
где будет находится строка ``Hello!'', и в какой странице, а также известен адрес ф-ции \puts.}
\EN{There are no such relocs in the executable file: because, it's known, where the ``Hello!'' string
is located, in which page, and \puts function address is also known.}
\RU{И поэтому там, в инструкциях \TT{ADRP}, \ADD и \TT{BL}, уже проставлены нужные значения 
(их проставил линкер во время компоновки):}
\EN{So there are values already set in the \TT{ADRP}, \ADD and \TT{BL} instructions
(linker set it while linking):}

\begin{lstlisting}[caption=objdump \EN{of executable file}\RU{исполняемого файла}]
0000000000400590 <main>:
  400590:       a9bf7bfd        stp     x29, x30, [sp,#-16]!
  400594:       910003fd        mov     x29, sp
  400598:       90000000        adrp    x0, 400000 <_init-0x3b8>
  40059c:       91192000        add     x0, x0, #0x648
  4005a0:       97ffffa0        bl      400420 <puts@plt>
  4005a4:       52800000        mov     w0, #0x0                        // #0
  4005a8:       a8c17bfd        ldp     x29, x30, [sp],#16
  4005ac:       d65f03c0        ret

...

Contents of section .rodata:
 400640 01000200 00000000 48656c6c 6f210000  ........Hello!..
\end{lstlisting}

\index{ARM!\Instructions!BL}
\RU{В качестве примера, попробуем дизассемблировать инструкцию BL вручную.}
\EN{As an example, let's try to disassemble BL instruction manually.}\\
\TT{0x97ffffa0} \RU{это}\EN{is} $10010111111111111111111110100000b$.
\RU{В соответствии с}\EN{Accoring to} \cite[C5.6.26]{ARM64ref}, 
imm26 \RU{это последние 26 бит}\EN{is the last 26 bits}: 
$imm26 = 11111111111111111110100000$.
\RU{Это}\EN{It is} \TT{0x3FFFFA0}, \RU{но}\EN{but} \ac{MSB} \RU{это}\EN{is} 1, 
\RU{так что число отрицательное, и в терминах модульной арифметики, по модулю $2^{32}$, это}
\EN{so the number is negative, and in terms of modular arithmetic of modulo $2^{32}$, it is} 
\TT{0xFFFFFFA0}.
\RU{И снова, по модулю}\EN{Again, in modulo} $2^{32}$, \TT{0xFFFFFFA0} * 4 = \TT{0xFFFFFE80}, 
\AndENRU \TT{0x4005a0} + \TT{FFFFFE80} = \TT{0x400420} 
(\EN{please note: we consider address of the BL instruction, 
not current value of \ac{PC}, which may be different!}
\RU{пожалуйста заметьте: мы берем адрес инструкции BL, 
а не текущее значение \ac{PC}, которое может быть другим!}).
\RU{Так что адрес в итоге}\EN{So the destination address is} \TT{0x400420}.\\
\\
\RU{Больше о релоках связанных с ARM64}\EN{More about ARM64-related relocs}: \cite{ARM64_ELF}.
