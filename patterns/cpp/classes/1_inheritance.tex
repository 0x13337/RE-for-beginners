\subsection{\RU{Наследование классов}\EN{Class inheritance}}

\RU{О наследованных классах можно сказать, что это та же простая структура которую мы уже рассмотрели, 
только расширяемая в наследуемых классах.}
\EN{It can be said about inherited classes that it is simple structure we already considered, but extending 
in inherited classes.}

\RU{Возьмем очень простой пример}\EN{Let's take simple example}:

\lstinputlisting{patterns/cpp/classes/classes1_inheritance.cpp}

\RU{Исследуя сгенерированный код для функций/методов \TT{dump()}, а также \TT{object::print\_color()},
посмотрим, какая будет разметка памяти для структур-объектов (для 32-битного кода).}
\EN{Let's investigate generated code of the \TT{dump()} functions/methods and also \TT{object::print\_color()},
let's see memory layout for structures-objects (as of 32-bit code).}

\index{Inline code}
\RU{Итак, методы \TT{dump()} разных классов сгенерированные MSVC 2008 с опциями \Ox и \Obzero}
\EN{So, \TT{dump()} methods for several classes, generated by MSVC 2008 with \Ox and \Obzero options}
\footnote{\RU{опция \Obzero означает отмену inline expansion, 
ведь вставка компилятором тела функции/метода прямо в код где он вызывается только затруднит наши эксперименты}
\EN{\Obzero options means inline expansion disabling since function inlining right into the code where the function
is called will make our experiment harder}}

\lstinputlisting[caption=\Optimizing MSVC 2008 /Ob0]{patterns/cpp/classes/classes1_1.asm}

\lstinputlisting[caption=\Optimizing MSVC 2008 /Ob0]{patterns/cpp/classes/classes1_2.asm}

\lstinputlisting[caption=\Optimizing MSVC 2008 /Ob0]{patterns/cpp/classes/classes1_3.asm}

\RU{Итак, разметка полей получается следующая}\EN{So, here is memory layout}:

\RU{(базовый класс \IT{object})}\EN{(base class \IT{object})}

\begin{center}
\begin{tabular}{ | l | l | }
\hline
  \tableheader{} \\
\hline
  +0x0 & int color \\
\hline
\end{tabular}
\end{center}

\RU{(унаследованные классы)}\EN{(inherited classes)}

\IT{box}:

\begin{center}
\begin{tabular}{ | l | l | }
\hline
  \tableheader{} \\
\hline
  +0x0 & int color \\
\hline
  +0x4 & int width \\
\hline
  +0x8 & int height \\
\hline
  +0xC & int depth \\
\hline
\end{tabular}
\end{center}

\IT{sphere}:

\begin{center}
\begin{tabular}{ | l | l | }
\hline
  \tableheader{} \\
\hline
  +0x0 & int color \\
\hline
  +0x4 & int radius \\
\hline
\end{tabular}
\end{center}

\RU{Посмотрим тело \main}\EN{Let's see \main function body}:

\lstinputlisting[caption=\Optimizing MSVC 2008 /Ob0]{patterns/cpp/classes/classes1_4.asm}

\RU{Наследованные классы всегда должны добавлять свои поля после полей базового класса для того, чтобы методы
базового класса могли продолжать работать со своими собственными полями.}
\EN{Inherited classes must always add their fields after base classes' fields, so to make possible for base 
class methods to work with their own fields.}

\RU{Когда метод \TT{object::print\_color()} вызывается, ему в качестве \TT{this} передается указатель и на объект типа \IT{box} 
и на объект типа \IT{sphere}, так как он может легко работать с классами \IT{box} и \IT{sphere}, потому что поле \IT{color} в этих
классах всегда стоит по тому же адресу (по смещению \TT{0x0}).}
\EN{When \TT{object::print\_color()} method is called, a pointers to both \IT{box} object and \IT{sphere} object are passed as \TT{this},
it can work with these objects easily since \IT{color} field in these objects is always at the pinned address (at \IT{+0x0} offset).}

\RU{Можно также сказать что методу \TT{object::print\_color()} даже не нужно знать,
с каким классом он работает, до тех пор, пока будет соблюдаться условие \IT{закрепления} полей по тем же адресам,
а это условие соблюдается всегда.}
\EN{It can be said, \TT{object::print\_color()} method is agnostic in relation to input object type as long as fields will be \IT{pinned}
at the same addresses, and this condition is always true.}

\RU{А если вы создадите класс-наследник класса \IT{box}, например, 
то компилятор будет добавлять новые поля уже за полем \IT{depth}, оставляя уже имеющиеся поля класса \IT{box} по тем же адресам.}
\EN{And if you create inherited class of the e.g. \IT{box} class, 
compiler will add new fields after \IT{depth} field,
leaving \IT{box} class fields at the pinned addresses.}

\RU{Так, метод \TT{box::dump()} будет нормально работать обращаясь к полям \IT{color}/\IT{width}/\IT{height}/\IT{depth} всегда находящимся по известным адресам.}
\EN{Thus, \TT{box::dump()} method will work fine accessing \IT{color}/\IT{width}/\IT{height}/\IT{depths} fields always pinned on known addresses.}

\RU{Код на GCC практически точно такой же, за исключением способа передачи \TT{this} (он, как уже было указано, 
передается в первом аргументе, вместо регистра \ECX).}
\EN{GCC-generated code is almost likewise, with the sole exception of \TT{this} pointer passing (as it was described above,
it passing as first argument instead of the \ECX registers.}

