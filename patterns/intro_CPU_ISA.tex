\ifdefined\ENGLISH
\section{A short introduction to the CPU}

The \ac{CPU} is the device that executes the machine code a program consists of.

\textbf{A short glossary:}

\begin{description}
\item[Instruction]: A primitive \ac{CPU} command.
The simplest examples include: moving data between registers, working with memory, primitive arithmetic operations.
As a rule, each \ac{CPU} has its own instruction set architecture (\ac{ISA}).

\item[Machine code]: Code that the \ac{CPU} directly processes. 
Each instruction is usually encoded by several bytes.
\item[Assembly language]: Mnemonic code and some extensions like macros that are intended to make a programmer's life easier.
\item[CPU register]: Each \ac{CPU} has a fixed set of general purpose registers (\ac{GPR}).
$\approx 8$ in x86, $\approx 16$ in x86-64, $\approx 16$ in ARM.
The easiest way to understand a register is to think of it as an untyped temporary variable.
Imagine if you were working with a high-level \ac{PL} and could only use eight 32-bit (or 64-bit) variables.
Yet a lot can be done using just these!
\end{description}

% TODO1 add about linker: "компоновщик" и "редактор связей" в русскоязычной лит-ре

% A note on the experiments in this area (like the LISP machines http://en.wikipedia.org/wiki/Lisp_machine
% might be useful
One might wonder why there needs to be a difference between machine code and a \ac{PL}.  The answer lies in the fact that humans and \ac{CPU}s are not alike---%
it is much easier for humans to use a high-level \ac{PL} like \CCpp, Java, Python, etc., but it is easier for a \ac{CPU} to use a much lower level of abstraction.
Perhaps it would be possible to invent a \ac{CPU} that can execute high-level \ac{PL} code, but it would be many times more complex than the \ac{CPU}s we know of today.
In a similar fashion, it is very inconvenient for humans to write in assembly language, due to it being so low-level and difficult to write in without making a huge number of annoying mistakes.
The program that converts the high-level \ac{PL} code into assembly is called a \IT{compiler}.
\footnote{Old-school Russian literature also use term \q{translator}.}.

\ifx\LITE\undefined
\index{ARM!\ARMMode}%
\index{ARM!\ThumbMode}%
\index{ARM!\ThumbTwoMode}%

\subsection{A couple of words about different \ac{ISA}s}
The x86 \ac{ISA} has always been one with variable-length opcodes, so when the 64-bit era came, the x64 extensions did not impact the \ac{ISA} very significantly. In fact, the x86 \ac{ISA} still contains a lot of instructions that first appeared in 16-bit 8086 CPU, yet are still found in the CPUs of today.
ARM is a \ac{RISC} \ac{CPU} designed with constant-length opcode in mind, which had some advantages in the past.
In the very beginning, all ARM instructions were encoded in 4 bytes%
\footnote{
By the way, fixed-length instructions are handy because one can calculate the next (or previous) 
instruction address without effort. This feature will be discussed in the switch() operator~(\myref{sec:SwitchARMLot}) section.
}.
This is now referred to as \q{ARM mode}.
Then they thought it wasn't as frugal as they first imagined.
In fact, most used \ac{CPU} instructions\footnote{These are MOV/PUSH/CALL/Jcc} in real world applications can be encoded using less information.
They therefore added another \ac{ISA}, called Thumb, where each instruction was encoded in just 2 bytes.
This is now referred as \q{Thumb mode}.
However, not \IT{all} ARM instructions can be encoded in just 2 bytes, so the Thumb instruction set is somewhat limited.
It is worth noting that code compiled for ARM mode and Thumb mode may of course coexist within one single program.
The ARM creators thought Thumb could be extended, giving rise to Thumb-2, which appeared in ARMv7.
Thumb-2 still uses 2-byte instructions, but has some new instructions which have the size of 4 bytes.
There is a common misconception that Thumb-2 is a mix of ARM and Thumb. This is incorrect. 
Rather, Thumb-2 was extended to fully support all processor features so it could
compete with ARM mode---a goal that was clearly achieved, as the majority of applications for \idevices are compiled for the Thumb-2 instruction set (admittedly, largely due to the fact that Xcode does this by default).
Later the 64-bit ARM came out. This \ac{ISA} has 4-byte opcodes, and lacked the need of any additional Thumb mode.
However, the 64-bit requirements affected the \ac{ISA}, resulting in us now having three ARM instruction sets: ARM mode, Thumb mode (including Thumb-2) and ARM64.
These \ac{ISA}s intersect partially, but it can be said that they are different \ac{ISA}s, rather than variations of the same one.
Therefore, we would try to add fragments of code in all three ARM \ac{ISA}s in this book.
\index{PowerPC}%
\index{MIPS}%
\index{Alpha AXP}%
There are, by the way, many other \ac{RISC} \ac{ISA}s with fixed length 32-bit opcodes, such as MIPS, PowerPC and Alpha AXP.
\fi % LITE
\fi % ENGLISH

\ifdefined\RUSSIAN
\section{Краткое введение в CPU}

\ac{CPU} это устройство исполняющее все программы.

\textbf{Немного терминологии:}

\begin{description}
\item[Инструкция]: примитивная команда \ac{CPU}.
Простейшие примеры: перемещение между регистрами, работа с памятью, примитивные арифметические операции.
Как правило, каждый \ac{CPU} имеет свой набор инструкций (\ac{ISA}).

\item[Машинный код]: код понимаемый \ac{CPU}. 
Каждая инструкция обычно кодируется несколькими байтами.
\item[Язык ассемблера]: машинный код плюс некоторые расширения, призванные облегчить труд программиста: макросы, имена, \etc.
\item[Регистр CPU]: Каждый \ac{CPU} имеет некоторый фиксированный набор регистров общего назначения (\ac{GPR}).
$\approx 8$ в x86, $\approx 16$ в x86-64, $\approx 16$ в ARM.
Проще всего понимать регистр как временную переменную без типа.
Можно представить, что вы пишете на \ac{PL} высокого уровня и у вас только 8 переменных шириной 32 (или 64) бита.
Можно сделать очень много используя только их!
\end{description}

% TODO1 add about linker: "компоновщик" и "редактор связей" в русскоязычной лит-ре

Откуда взялась разница между машинным кодом и \ac{PL} высокого уровня?  Ответ в том, что люди и \ac{CPU}-ы отличаются друг от друга ---
человеку проще писать на \ac{PL} высокого уровня вроде \CCpp, Java, Python, а \ac{CPU} проще работать с абстракциями куда более низкого уровня.
Возможно, можно было бы придумать \ac{CPU} исполняющий код \ac{PL} высокого уровня, но он был бы значительно сложнее, чем те, что мы имеем сегодня.
И наоборот, человеку очень неудобно писать на ассемблере из-за его низкоуровневости, к тому же, крайне трудно обойтись без мелких ошибок.
Программа, переводящая код из \ac{PL} высокого уровня в ассемблер называется \IT{компилятором}
\footnote{В более старой русскоязычной литературе также часто встречается термин \q{транслятор}.}.

\ifx\LITE\undefined
\index{ARM!\ARMMode}%
\index{ARM!\ThumbMode}%
\index{ARM!\ThumbTwoMode}%

\subsection{Несколько слов о разнице между \ac{ISA}}
x86 всегда был архитектурой с опкодами переменной длины, так что когда пришла 64-битная эра, расширения x64 не очень сильно повлияли на \ac{ISA}.
ARM это \ac{RISC}-процессор разработанный с учетом опкодов одинаковой длины, что было некоторым преимуществом в прошлом.
Так что в самом начале все инструкции ARM кодировались 4-мя байтами%
\footnote{
Кстати, инструкции фиксированного размера удобны тем, что всегда можно легко узнать адрес 
следующей (или предыдущей) инструкции. Эта особенность будет рассмотрена в секции об операторе switch()~(\myref{sec:SwitchARMLot}).
}.
Это то, что сейчас называется \q{режим ARM}.
Потом они подумали, что это не очень экономично.
На самом деле, самые используемые инструкции\footnote{А это MOV/PUSH/CALL/Jcc} процессора на практике могут быть закодированы c использованием меньшего количества информации.
Так что они добавили другую \ac{ISA} с названием Thumb, где каждая инструкция кодируется всего лишь 2-мя байтами.
Теперь это называется \q{режим Thumb}.
Но не все инструкции ARM могут быть закодированы в двух байтах, так что набор инструкций Thumb ограниченный.
Код, скомпилированный для режима ARM и Thumb может сосуществовать в одной программе.
Затем создатели ARM решили, что Thumb можно расширить: так появился Thumb-2 (в ARMv7).
Thumb-2 это всё ещё двухбайтные инструкции, но некоторые новые инструкции имеют длину 4 байта.
Распространено заблуждение, что Thumb-2\EMDASH{}это смесь ARM и Thumb. Это не верно. Режим Thumb-2 был дополнен до
более полной поддержки возможностей процессора и теперь может легко конкурировать с режимом ARM.
Основное количество приложений для \idevices скомпилировано для набора инструкций Thumb-2, потому что Xcode
делает так по умолчанию.
Потом появился 64-битный ARM. Это \ac{ISA} снова с 4-байтными опкодами, без дополнительного режима Thumb.
Но 64-битные требования повлияли на \ac{ISA}, так что теперь у нас 3 набора инструкций ARM: режим ARM, режим Thumb (включая Thumb-2) и ARM64.
Эти наборы инструкций частично пересекаются, но можно сказать, это скорее разные наборы, нежели вариации одного.
Следовательно, в этой книге постараемся добавлять фрагменты кода на всех трех ARM \ac{ISA}.
\index{PowerPC}%
\index{MIPS}%
\index{Alpha AXP}%
Существует ещё много \ac{RISC} \ac{ISA} с опкодами фиксированной 32-битной длины~--- это как минимум MIPS, PowerPC и Alpha AXP.
\fi % LITE
\fi % RUSSIAN

\ifdefined\BRAZILIAN
\section{Uma breve introdução a CPU}

A \ac{CPU} é o dispositivo que executa o código de máquina do qual consiste um programa.

\textbf{Um glossário resumido:}

\begin{description}
\item[Instrução]: Um comando primário da \ac{CPU}. Os exemplos mais simples incluem: mover informação entre os registradores, trabalhar com memória, operações primárias de aritimética.
Como regra, cada \ac{CPU} tem sua própria arquitetura do conjunto de instruções (\ac{ISA}).

\item[Código de máquina]: Código que a \ac{CPU} processa diretamente, cada instrução geralmente é codificada por vários bytes.

\item[Linguagem assembly]: Códigos mnemônicos e algumas extensões como macros que tem por intenção facilitar a vida do programador.

\item[Registrador da CPU]: Cada \ac{CPU} tem um conjunto fixo de registradores de propósito geral (\ac{GPR}).
Aproximadamente 8 na arquitetura x86, 16 na x86-64, 16 na ARM.
A maneira mais fácil de entender um registrador é imaginá-lo como uma variável temporário sem tipo.
Imagine que você está trabalhando em uma linguagem de alto nível e pudesse usar somente oito variáveis de 32-bit (ou 64).
Ainda assim uma gama de coisas podem ser feitas usando somente estes!

\end{description}

Você pode pensar por quê há a necessidade dessa diferença entre código de máquina e linguagens de programação de alto nível.
A resposta está no fato de humanos e CPUs não se parecerem nada --- é muito mais fácil para um humano usar uma linguagem de alto nível como \CCpp, Java, Python, etc., 
mas para a CPU é mais fácil usar um nível muito mais baixo de abstração.
Talvez seja possível inventar uma CPU que pode executar códigos em linguagem de alto nível, mas ela seria muitas vezes mais complexa que as CPUs que conhecemos hoje.
De uma maneira similar, é muito mais inconveniente para humanos escreverem em linguagem assemly,
devido ao fato dela ser tão baixo nível e difícil de se escrever sem cometer um alto número de erros irritantes. O programa que converte linguagem de alto nível em código assembly é chamado de compilador.

\iffalse
% another translation
\section{Uma breve introdução à CPU}

A \ac{CPU} é o dispositivo que executa o código de máquina que consiste num programa.
\textbf{Um pequeno glossário:}
\begin{description}
\item[Instrução]: Um primitivo \ac{CPU} comando.
Os exemplos mais simples incluem: mover dados entre registradores, trabalhar com a memória, operações aritiméticas primitivas.
Como regra geral, cada \ac{CPU} tem seu próprio conjunto de instruções (\ac{ISA}).

\item[\PTBRph{}]: Código que a \ac{CPU} processa diretamente. 
Cada instrução é normalmente codificada em vários bytes.
\item[Linguagem assembly]: Código mnemônico e algumas extensões como macros que têm a finalidade de facilitar a vida do programamdor.
\item[Registradores da CPU]: Cada \ac{CPU} tem um conjunto fixo de registradores de propósito geral (\ac{GPR}).
$\approx 8$ \PTBRph{} x86, $\approx 16$ \PTBRph{} x86-64, $\approx 16$ \PTBRph{} ARM.
A forma mais fácil de entender um registrador é pensar nele como uma variável temporária não tipada.
Imagine que você estivesse trabalhando com uma \ac{PL} de alto nível e pudesse usar apenas oito variáveis de 32-bit (ou de 64-bit).
No entanto, muito ainda pode ser feito usando apenas eles.
\end{description}

Alguém poderia perguntar por que é preciso haver diferença entre código de máquina e uma \ac{PL} de alto nível.  A resposta reside no fato de que humanos e \ac{CPU}s não são iguais---%
É muito mais fácil para os humanos usar uma \ac{PL} de alto nível como \CCpp, Java, Python, etc., mas é muito mais fácil para a \ac{CPU} usar um nível de abstração muito menor.
talvez fosse possível inventar uma \ac{CPU} que pudesse executar código feito em \ac{PL} alto nível, mas seria inúmeras vezes mais complexa do que as \ac{CPU}s que conhecemos hoje.
De forma semelhante, é muito inconveninente para os seres humanos escrever em linguagem assembly, devido ao fato dela ser tão baixo nível e difícil de escrever sem comenter uma enorme quantidade de erros irritantes.
O programa que converte o código de \ac{PL} de alto nível em assembly é chamado \IT{compiler}.
\fi

\ifx\LITE\undefined
\index{ARM!\ARMMode}%
\index{ARM!\ThumbMode}%
\index{ARM!\ThumbTwoMode}%

\subsection{Algumas palavras a respeito de diferentes \ac{ISA}s}
O \ac{ISA} x86 sempre possuiu opcodes de tamanho variável, então com a chegada da era do 64-bit, as extensões x64 não impactaram a \ac{ISA} de forma muito significante. De fato, o \ac{ISA} x86 ainda contém uma série de instrucões que surgiram inicialmente na CPU 8086 16-bit, mas ainda são encontradas nas CPUs de hoje em dia.
ARM é uma \ac{CPU} \ac{RISC} desenvolvido com a idéia de opcodes com tamanho constante, o que trouxe algumas vantagens no passado.
Bem no início, todas as instruções ARM foram codificadas em 4 bytes%
\footnote{A propósito, instruções de tamanho fixo são úteis porque se pode calcular o endereço da próxima instrução (ou da anterior) sem esforço. Esta característica será discutida na seção do operador switch() ~(\myref{sec:SwitchARMLot}).}.
Este é atualmente referenciado como \q{ARM mode}.
Então concluiu-se que não era tão econômico quanto se imaginou a princípio.
Na verdade, as instruções de \ac{CPU} mais utilizadas \footnote{São estas MOV/PUSH/CALL/Jcc} em aplicações do mundo real podem ser codificadas usando menos informação.
Foi adicionado então outro \ac{ISA}, chamado Thumb, onde cada instrução era codificada em apenas 2 bytes.
Este é conhecido como \q{Thumb mode}.
No entanto, nem \IT{all} instruções ARM podem ser codificadas em apenas 2 bytes, então o conjunto de instruções Thumb é de certa forma limitado.
É interessante notar que códigos compilados para os modos ARM e Thumb podem, conforme esperado, coexistir num mesmo programa.
Os criadores do ARM concluíram que o Thumb poderia ser extendido, dando origem ao Thumb-2, que apareceu no ARMv7.
Thumb-2 ainda usa instruções de 2 bytes, mas possui algumas novas instruções com 4 bytes de tamanho.
Há um equívoco comum que Thumb-2 é uma mistura de ARM e Thumb. Isso é incorreto.
Em vez disso, Thumb-2 foi extendido para suportar completamente todos os recursos de processador de forma que ele pudesse competir com o modo ARM---um objetivo que foi claramente alcançado, uma vez que a maioria das aplicações para \idevices são compiladas para o conjunto de instruções do Thumb-2 (admitidamente, principalmente devido ao fato que o Xcode faz isso por padrão).
Posteriormente o ARM 64-bit foi lançado. Este \ac{ISA} tem opcodes de 4 bytes, e descarta a necessidade de qualquer modo Thumb adicional.
No entanto, os requisitos de 64-bit afetaram o \ac{ISA}, resultando em termos atualmente três conjuntos de instruções ARM: ARM mode, Thumb mode (incluindo Thumb-2) e ARM64.
Estes \ac{ISA}s se intersecionam parcialmente, porém podemos dizer que são \ac{ISA}s diferentes, ao invés de variações do mesmo.
Portanto, gostaríamos de tentar adicionar pedaços de código dos três \ac{ISA}s do ARM neste livro.
\index{PowerPC}%
\index{MIPS}%
\index{Alpha AXP}%
Existem, a propósito, muitos outros \ac{RISC} \ac{ISA}s com opcodes de tamanho fixo de 32-bit, como MIPS, PowerPC \PTBRph{} Alpha AXP.
\fi % LITE
\fi % BRAZILIAN

\ifdefined\SPANISH
\section{Una breve introducción a la CPU}

La \ac{CPU} es el dispositivo que ejecuta el código de máquina que constituye un programa.

\textbf{Un breve glosario:}

\begin{description}
\item[Instrucción]: Una primitiva \ac{CPU} comando.
Los ejemplos más simples incluyen: mover datos entre registros, trabajar con la memoria, operaciones aritméticas primitivas.
Como regla general, cada \ac{CPU} tiene su proprio conjunto de instrucciones (\ac{ISA}).

\item[\ESph{}]: Código que la \ac{CPU} procesa directamente. 
Cada instrucción generalmente se codifica por vários bytes.
\item[Lenguaje assembly]: Código mnemónico y algunas extensiones como macros que destinados a hacer la vida del programador más fácil.
\item[Registros de la CPU]: 
Cada \ac{CPU} tiene un conjunto fijo de registros de propósito general (\ac{GPR}).
$\approx 8$ \ESph{} x86, $\approx 16$ \ESph{} x86-64, $\approx 16$ \ESph{} ARM.
La forma más fácil de entender un registro es pensar en ello como una variable temporal sin tipo.
Imagine si estuviera trabajando con una \ac{PL} de alto nivel y sólo podría utilizar ocho variables de 32-bit (o de 64-bit).
Sin embargo mucho se puede hacer usando sólo estos!
\end{description}

Uno podría perguntarse por qué es necessário que haya diferencia entre el código de la máquina y una lenguaje de programación de alto nivel.  La respuesta está en el hecho de que los seres humanos y CPUs no son iguales---%
És mucho más fácil para los humanos utilizar un \ac{PL} de alto nivel como \CCpp, Java, Python, etc., pero és más fácil para una \ac{CPU} utilizar un nivel mucho más bajo de abstración.
Tal vez sería posible inventar una \ac{CPU} que podría ejecutar código de \ac{PL} de alto nivel, pero sería muchas veces más compleja que las \ac{CPU}s que conocemos hoy.
En uma manera similar, es muy incómodo para los seres humanos escribir en lenguaje assembly, debido a que es tan bajo nivel y difícil escribir sin hacer una gran cantidade de errores molestos.
El programa que convierte el código de \ac{PL} de alto nivel en assembly se llama \IT{compiler}.

\ifx\LITE\undefined
\index{ARM!\ARMMode}%
\index{ARM!\ThumbMode}%
\index{ARM!\ThumbTwoMode}%

\subsection{Algunas palabras sobre diferentes \ac{ISA}s}
El \ac{ISA} x86 siempre ha tenido opcodes de tamaño variable, de modo que cuanco llegó la era de 64-bit, las extensiones x64 no impactan el \ac{ISA} de manera muy significativa. De hecho, el \ac{ISA} x86 aún contiene una gran cantidade de instrucciones que primero aparecieron en CPU 8086 16-bit, pero aún se encuentran en las CPUs de hoy.
ARM és una \ac{CPU} \ac{RISC} diseñado con la idea de opcodes con tamaño constante, que tenía algunas ventajas en el pasado.
En el principio, todas las instrucciones ARM fueron codificados en 4 bytes%
\footnote{Dicho sea de paso, las instrucciones de longitud fija son muy útiles porque se puede calcular la dirección de instrucción siguiente (o anterior) sin esfuerzo. Esta característica se discutirá en la sección de el operador switch() ~(\myref{sec:SwitchARMLot}).}.
Esto actualmente se conoce como \q{ARM mode}.
Entonces se llegó a la conclusión que no era tan económico como se imaginó al princípio.
En realidad, la mayoría de las instrucciones de \ac{CPU} utilizados \footnote{Son estos MOV/PUSH/CALL/Jcc} en aplicaciones del mundo real pueden ser codificados utilizando menos información.
Por lo tanto añadieron otra \ac{ISA}, llamado Thumb, donde cada instrucción fue codificada en sólo 2 bytes.
Esto se conoce como \q{Thumb mode}.
No obstante, no todas las instrucciones ARM pueden ser codificadas en apenas 2 bytes, entonces el conjunto de instrucciones Thumb es algo limitada.
Es importante destacar que el código compilado para el modo ARM y para el modo Thumb pueden, por supuesto, coexistir dentro de un solo programa.
Los creadores de ARM concluyeron que se podría extender el Thumb, dando origem al Thumb-2, que apareció en el ARMv7.
Thumb-2 sigue utilizando instrucciones de 2 bytes, pero tiene algunas nuevas instrucciones que tienen el tamaño de 4 bytes.
Hay una idea errónea de que Thumb-2 es una mezcla de ARM y Thumb. Esto es incorrecto. 
Más bien, se extendió Thumb-2 para apoyar plenamente todas las características de processador por lo que podría 
competir con el modo ARM\EMDASH{}un objetivo que se logró con claridad, ya que la mayoria de aplicacciones para \idevices son compmilados para el conjunto de instrucciones del Thumb-2 (la verdade es, en gran parte debido al hecho de que Xcode hace esto por defecto).
Más tarde, el ARM 64-bit salió. Este \ac{ISA} tiene opcodes de 4 bytes, y descarta la necesidade de cualquier modo Thumb adicional.
Pero, los requisitos de 64-bit afectaron la \ac{ISA}, resultando en ahora tenermos tres conjuntos de instrucciones ARM: ARM mode, Thumb mode (incluyendo Thumb-2) y ARM64.
Estos \ac{ISA}s se intersectan parcialmente, pero puede ser más bien decir que son \ac{ISA}s diferentes, en lugar de variaciones de lo mismo.
Por lo tanto, nos gustaría intentar añadir fragmentos de código de los tres \ac{ISA}s del ARM en este libro.
\index{PowerPC}%
\index{MIPS}%
\index{Alpha AXP}%
Hay, por cierto, muchos otros \ac{RISC} \ac{ISA}s con opcodes de tamaño fijo de 32-bit, tales como MIPS, PowerPC \ESph{} Alpha AXP.
\fi % LITE
\fi % SPANISH

