\part{\RU{Образцы кода}\EN{Code patterns}}

\RU{\epigraph{Всё познается в сравнении}{Автор неизвестен}} % FIXME: english version?
\RU{Когда я учил Си, а затем Си++, я просто писал небольшие фрагменты кода, компилировал и смотрел что 
получилось на ассемблере. Так было намного проще понять. Я делал это такое количество раз, 
что связь между кодом на \CCpp и тем, что генерирует компилятор, вбилась мне в подсознание достаточно 
глубоко, поэтому я могу, глядя на код на ассемблере, сразу понимать, в общих чертах, что там было написано 
на Си. Возможно это поможет кому-то ещё, попробую описать некоторые примеры.}
\EN{When I first learned C and then C++, I wrote small pieces of code, compiled them, 
and saw what 
was produced in the assembly language. This was easy for me. I did it many times and the relation 
between the \CCpp code and what the compiler produced was imprinted in my mind so deep that 
I can quickly understand what was in the original C code when I look at produced x86 code. 
Perhaps this technique may be helpful for someone else so I will try to describe some examples here.}

\RU{Здесь много примеров и для x86/x64 и для ARM}\EN{There are a lot of examples for both x86/x64 
and ARM}. 
\RU{Те, кто уже хорошо знаком с одной из архитектур, могут легко пролистывать страницы}
\EN{Those who already familiar with one of architectures, may freely skim over pages}.

\chapter{\RU{Краткое введенение в CPU}\EN{Short introduction to the CPU}}

\EN{The} \ac{CPU} \RU{это собственно устройство исполняющее все программы}\EN{is the unit which executes all of the programs}.

\RU{Немного терминологии}\EN{Short glossary}:

\begin{description}
\item[\RU{Инструкция}\EN{Instruction}]: \RU{примитивная команда}\EN{a primitive command to the} \ac{CPU}.
\RU{Простейшие примеры: перемещение между регистрами, работа с памятью, примитивные арифметические операции}
\EN{Simplest examples: moving data between registers, working with memory, arithmetic primitives}.
\RU{Как правило, каждый}\EN{As a rule, each} \ac{CPU} \RU{имеет свой набор инструкций}\EN{has its own instruction set architecture} 
(\ac{ISA}).

\item[\RU{Машинный код}\EN{Machine code}]: \RU{код понимаемый}\EN{code for the} \ac{CPU}. 
\RU{Каждая инструкция обычно кодируется несколькими байтами}\EN{Each instruction is usually encoded by several bytes}.

\item[\RU{Язык ассемблера}\EN{Assembly language}]: 
\RU{машинный код плюс некоторые расширения призванные облегчить труд программиста: макросы, итд}
\EN{mnemonic code and some extensions like macros which are intended to make a programmer's life easier}.

\item[\RU{Регистр CPU}\EN{CPU register}]: 
\RU{Каждый}\EN{Each} \ac{CPU} \RU{имеет некоторый фиксированный набор регистров общего назначения}\EN{has a fixed set
of general purpose registers} (\ac{GPR}).
$\approx 8$ \InENRU x86, $\approx 16$ \InENRU x86-64, $\approx 16$ \InENRU ARM.
\RU{Проще всего понимать регистр как временную переменную без типа}
\EN{The easiest way to understand a register is to think of it as an untyped temporary variable}.
\RU{Можно представить что вы пишете на \ac{PL} высокого уровня и у вас только 8 переменных шириной 32 бита}
\EN{Imagine you are working with a high-level \ac{PL} and you have only 8 32-bit variables}.
\RU{Можно сделать очень много используя только их}\EN{A lot of things can be done using only these}!
\end{description}

\RU{Откуда взялась разница между машинным кодом и \ac{PL} высокого уровня}
\EN{What is the difference between machine code and a \ac{PL}}?
\RU{Человеку проще писать на \ac{PL} высокого уровня вроде \CCpp, Java, Python, 
а \ac{CPU} проще работать с абстракциями куда более низкого уровня}
\EN{It is much easier for humans to use a high-level \ac{PL} like \CCpp, Java, Python, etc., 
but it is easier for a \ac{CPU} to use a much lower level of abstraction}.
\RU{Возможно, можно было бы придумать \ac{CPU} исполняющий код \ac{PL} высокого уровня, но он был бы значительно сложнее}
\EN{Perhaps, it would be possible to invent a \ac{CPU} which can execute high-level \ac{PL} code, but it would be much more complex}.
\RU{И наоборот, человеку очень неудобно писать на ассемблере из-за его низкоуровневости, к тому же, крайне трудно обойтись
без мелких ошибок}
\EN{On the contrary, it is very inconvenient for humans to use assembly language due to its low-levelness. Besides, it is very hard
to do it without making a huge amount of annoying mistakes}.
\RU{Программа переводящая код из \ac{PL} высокого уровня в ассемблер называется \IT{компилятором}
\footnote{В более старой русскоязычной литературе также часто встречается термин ``транслятор''.}}
\EN{The program which converts high-level \ac{PL} code into assembly is called a \IT{compiler}}.

\input{patterns/01_helloworld/main}
\input{patterns/015_prolog_epilogue/main}
\input{patterns/02_stack/main}
\input{patterns/03_printf/main}
\input{patterns/04_scanf/main}
\input{patterns/05_passing_arguments/main}
\input{patterns/06_return_results/main}
\input{patterns/061_pointers/main}
\input{patterns/07_jcc/main}
\input{patterns/08_switch/main}
\input{patterns/09_loops/main}
\input{patterns/10_strlen/main}
\input{patterns/11_division_by_9/main}
\input{patterns/12_FPU/main}
\input{patterns/13_arrays/main}
\input{patterns/14_bitfields/main}
\input{patterns/15_structs/main}
\input{patterns/17_unions/main}
\input{patterns/18_pointers_to_functions/main}
\input{patterns/185_64bit_in_32_env/main}
\input{patterns/19_SIMD/main}
\input{patterns/20_x64/main}
\input{patterns/205_floating_SIMD/main}
\input{patterns/207_fahrenheit/main}
\input{patterns/21_C99_restrict/main}
\input{patterns/22_inline_function/main}
\input{patterns/23_incorrect_disassembly/main}
\input{patterns/cpp/main}
\input{patterns/obfuscation/main}
\input{patterns/win16/main}
