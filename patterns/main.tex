\chapter{\IFRU{Образцы кода}{Code patterns}}

\IFRU
{Когда я учил Си, а затем Си++, я просто писал небольшие фрагменты кода, компилировал и смотрел что 
получилось на ассемблере. Так было намного проще понять. Я делал это такое количество раз, 
что связь между кодом на \CCpp и тем, что генерирует компилятор, вбилась мне в подсознание достаточно 
глубоко, поэтому я могу, глядя на код на ассемблере, сразу понимать, в общих чертах, что там было написано 
на Си. Возможно это поможет кому-то ещё, попробую описать некоторые примеры.}
{When I first learned C and then C++, I wrote small pieces of code, compiled them, 
and saw what 
was produced in the assembly language. This was easy for me. I did it many times and the relation 
between the \CCpp code and what the compiler produced was imprinted in my mind so deep that 
I can quickly understand what was in the original C code when I look at produced x86 code. 
Perhaps this technique may be helpful for someone else so I will try to describe some examples here.}

\section{\IFRU{Краткое введенение в CPU}{Short introduction to the CPU}}

\IFRU{}{The} \ac{CPU} \IFRU{это собственно устройство исполняющее все программы}{is the unit which executes all of the programs}.

\IFRU{Немного терминологии}{Short glossary}:

\begin{description}
\item[\IFRU{Инструкция}{Instruction}]: \IFRU{примитивная команда}{a primitive command to the} \ac{CPU}.
\IFRU{Простейшие примеры: перемещение между регистрами, работа с памятью, примитивные арифметические операции}
{Simplest examples: moving data between registers, working with memory, arithmetic primitives}.
\IFRU{Как правило, каждый}{As a rule, each} \ac{CPU} \IFRU{имеет свой набор инструкций}{has its own instruction set architecture} 
(\ac{ISA}).

\item[\IFRU{Машинный код}{Machine code}]: \IFRU{код понимаемый}{code for the} \ac{CPU}. 
\IFRU{Каждая инструкция обычно кодируется несколькими байтами}{Each instruction is usually encoded by several bytes}.

\item[\IFRU{Язык ассемблера}{Assembly language}]: 
\IFRU{машинный код плюс некоторые расширения призванные облегчить труд программиста: макросы, итд}
{mnemonic code and some extensions like macros which are intended to make a programmer's life easier}.

\item[\IFRU{Регистр CPU}{CPU register}]: 
\IFRU{Каждый}{Each} \ac{CPU} \IFRU{имеет некоторый фиксированный набор регистров общего назначения}{has a fixed set
of general purpose registers} (\ac{GPR}).
$\approx 8$ \InENRU x86, $\approx 16$ \InENRU x86-64, $\approx 16$ \InENRU ARM.
\IFRU{Проще всего понимать регистр как временную переменную без типа}
{The easiest way to understand a register is to think of it as an untyped temporary variable}.
\IFRU{Можно представить что вы пишете на \ac{PL} высокого уровня и у вас только 8 переменных шириной 32 бита}
{Imagine you are working with a high-level \ac{PL} and you have only 8 32-bit variables}.
\IFRU{Можно сделать очень много используя только их}{A lot of things can be done using only these}!
\end{description}

\IFRU{Откуда взялась разница между машинным кодом и \ac{PL} высокого уровня}
{What is the difference between machine code and a \ac{PL}}?
\IFRU{Человеку проще писать на \ac{PL} высокого уровня вроде \CCpp, Java, Python, 
а \ac{CPU} проще работать с абстракциями куда более низкого уровня}
{It is much easier for humans to use a high-level \ac{PL} like \CCpp, Java, Python, etc., 
but it is easier for a \ac{CPU} to use a much lower level of abstraction}.
\IFRU{Возможно, можно было бы придумать \ac{CPU} исполняющий код \ac{PL} высокого уровня, но он был бы значительно сложнее}
{Perhaps, it would be possible to invent a \ac{CPU} which can execute high-level \ac{PL} code, but it would be much more complex}.
\IFRU{И наоборот, человеку очень неудобно писать на ассемблере из-за его низкоуровневости, к тому же, крайне трудно обойтись
без мелких ошибок}
{On the contrary, it is very inconvenient for humans to use assembly language due to its low-levelness. Besides, it is very hard
to do it without making a huge amount of annoying mistakes}.
\IFRU{Программа переводящая код из \ac{PL} высокого уровня в ассемблер называется \IT{компилятором}
\footnote{В более старой русскоязычной литературе также часто встречается термин ``транслятор''.}}
{The program which converts high-level \ac{PL} code into assembly is called a \IT{compiler}}.

% sections here:

\input{patterns/01_helloworld/main}
\input{patterns/02_stack/main}
\input{patterns/03_printf/main}
\input{patterns/04_scanf/main}
\input{patterns/05_passing_arguments/main}
\input{patterns/06_return_results/main}
\input{patterns/061_pointers/main}
\input{patterns/07_jcc/main}
\input{patterns/08_switch/main}
\input{patterns/09_loops/main}
\input{patterns/10_strlen/main}
\input{patterns/11_division_by_9/main}
\input{patterns/12_FPU/main}
\input{patterns/13_arrays/main}
\input{patterns/14_bitfields/main}
\input{patterns/15_structs/main}
\input{patterns/17_unions/main}
\input{patterns/18_pointers_to_functions/main}
\input{patterns/185_64bit_in_32_env/main}
\input{patterns/19_SIMD/main}
\input{patterns/20_x64/main}
\input{patterns/205_floating_SIMD/main}
\input{patterns/21_C99_restrict/main}
\input{patterns/22_inline_function/main}
\input{patterns/23_incorrect_disassembly/main}
\input{patterns/obfuscation/main}
\input{patterns/win16/main}
