%NOTTRANSLATED
\subsection{ARM: 3 аргумента в \printf}

В ARM традиционно принята такая схема передачи аргументов в функцию: 4 первых аргумента через регистры R0-R3,
а остальные ~--- через стек. Это немного похоже на то как аргументы передаются в fastcall~\ref{fastcall} или 
win64~\ref{sec:callingconventions_win64}.

\subsubsection{\NonOptimizingKeil: режим ARM}

\begin{lstlisting}
.text:00000014             printf_main1
.text:00000014 10 40 2D E9                 STMFD   SP!, {R4,LR}
.text:00000018 03 30 A0 E3                 MOV     R3, #3
.text:0000001C 02 20 A0 E3                 MOV     R2, #2
.text:00000020 01 10 A0 E3                 MOV     R1, #1
.text:00000024 1D 0E 8F E2                 ADR     R0, aADBDCD     ; "a=%d; b=%d; c=%d\n"
.text:00000028 0D 19 00 EB                 BL      __2printf
.text:0000002C 10 80 BD E8                 LDMFD   SP!, {R4,PC}
\end{lstlisting}

Итак, первые 4 аргумента передаются через регистры R0-R3, по порядку: указатель на формат-строку для \printf
в R0, затем 1 в R1, 2 в R2 и 3 в R3. 

Пока что, здесь нет ничего необычного

\subsubsection{\OptimizingKeil: режим ARM}
\label{ARM_B_to_printf}

\begin{lstlisting}
.text:00000014                             EXPORT printf_main1
.text:00000014             printf_main1
.text:00000014 03 30 A0 E3                 MOV     R3, #3
.text:00000018 02 20 A0 E3                 MOV     R2, #2
.text:0000001C 01 10 A0 E3                 MOV     R1, #1
.text:00000020 1E 0E 8F E2                 ADR     R0, aADBDCD     ; "a=%d; b=%d; c=%d\n"
.text:00000024 CB 18 00 EA                 B       __2printf
\end{lstlisting}

Это соптимизированная версия (\Othree) для режима ARM, и здесь мы видим последнюю инструкцию: \TT{B} вместо привычной
нам \TT{BL}. 
Отличия между соптимзированной версией и предыдущей, скомпилированной без оптимизации, еще и в том, 
что нет пролога и эпилога функции (инструкций, сохранающих состояние регистров \TT{R4} и \LR).
Инструкция \TT{B} просто переходит на другой адрес, без манипуляций с регистром \LR, то есть,
это аналог \JMP в x86.
Почему это работает нормально? Потому что этот код эквивалентен предыдущему.
Основных причин две: 1) стек не модифицируется, как и указатель стека \SP; 2) вызов функции \printf последний, 
после него ничего не происходит.
Функция \printf, отработав, просто вернет управление по адресу, записанному в \LR. Но в \LR находится адрес места,
откуда была вызвана наша функция! А следовательно, управление из \printf вернется сразу туда.
Следовательно, нет нужды сохранять \LR, потому что нет нужны модифицировать \LR. 
А нет нужды модифицировать \LR,
потому что нет иных вызовов функций, кроме \printf, к тому же, после этого вызова не нужно ничего здесь 
больше делать! Поэтому такая оптимизация возможна.

Еще один похожий пример описан в секции ``\SwitchCaseDefaultSectionName'', здесь~\ref{jump_to_last_printf}.

\subsubsection{\OptimizingKeil: режим thumb}

\begin{lstlisting}
.text:0000000C             printf_main1
.text:0000000C 10 B5                       PUSH    {R4,LR}
.text:0000000E 03 23                       MOVS    R3, #3
.text:00000010 02 22                       MOVS    R2, #2
.text:00000012 01 21                       MOVS    R1, #1
.text:00000014 A4 A0                       ADR     R0, aADBDCD     ; "a=%d; b=%d; c=%d\n"
.text:00000016 06 F0 EB F8                 BL      __2printf
.text:0000001A 10 BD                       POP     {R4,PC}
\end{lstlisting}

Здесь нет особых отличий от неоптимизированного варианта для режима ARM.


