%NOTTRANSLATED
\subsection{ARM: 3 аргумента в \printf}

В ARM традиционно принята такая схема передачи аргументов в функцию: 4 первых аргумента через регистры R0-R3,
а остальные ~--- через стек. Это немного похоже на то как аргументы передаются в fastcall~\ref{fastcall} или 
win64~\ref{sec:callingconventions_win64}.

\subsubsection{Неоптимизирующий Keil: режим ARM}

\begin{lstlisting}
.text:00000014             printf_main1
.text:00000014 10 40 2D E9                 STMFD   SP!, {R4,LR}
.text:00000018 03 30 A0 E3                 MOV     R3, #3
.text:0000001C 02 20 A0 E3                 MOV     R2, #2
.text:00000020 01 10 A0 E3                 MOV     R1, #1
.text:00000024 1D 0E 8F E2                 ADR     R0, aADBDCD     ; "a=%d; b=%d; c=%d\n"
.text:00000028 0D 19 00 EB                 BL      __2printf
.text:0000002C 10 80 BD E8                 LDMFD   SP!, {R4,PC}
\end{lstlisting}

Итак, первые 4 аргумента передаются через регистры R0-R3, по порядку: указатель на формат-строку для \printf
в R0, затем 1 в R1, 2 в R2 и 3 в R3. 

Пока что, здесь нет ничего необычного

\subsubsection{Оптимизирующий Keil: режим ARM}
\label{ARM_B_to_printf}

\begin{lstlisting}
.text:00000014                             EXPORT printf_main1
.text:00000014             printf_main1
.text:00000014 03 30 A0 E3                 MOV     R3, #3
.text:00000018 02 20 A0 E3                 MOV     R2, #2
.text:0000001C 01 10 A0 E3                 MOV     R1, #1
.text:00000020 1E 0E 8F E2                 ADR     R0, aADBDCD     ; "a=%d; b=%d; c=%d\n"
.text:00000024 CB 18 00 EA                 B       __2printf
\end{lstlisting}

Это соптимизированная версия (-O3) для режима ARM, и здесь мы видим последнюю инструкцию: \TT{B} вместо привычной
нам \TT{BL}. 
Отличия между соптимзированной версией и предыдущей, скомпилированной без оптимизации, еще и в том, 
что нет пролога и эпилога функции (инструкций, сохранающих состояние регистров \TT{R4} и \LR).
Инструкция \TT{B} просто переходит на другой адрес, без манипуляций с регистром \LR, то есть,
это аналог \JMP в x86.
Почему это работает нормально? Потому что этот код эквивалентен предыдущему.
Основных причин две: 1) стек не модифицируется, как и указатель стека \SP; 2) вызов функции \printf последний, 
после него ничего не происходит.
Функция \printf, отработав, просто вернет управление по адресу, записанному в \LR. Но в \LR находится адрес места,
откуда была вызвана наша функция! А следовательно, управление из \printf вернется сразу туда.
Следовательно, нет нужды сохранять \LR, потому что нет нужны модифицировать \LR. 
А нет нужды модифицировать \LR,
потому что нет иных вызовов функций, кроме \printf, к тому же, после этого вызова не нужно ничего здесь 
больше делать! Поэтому такая оптимизация возможна.

Еще один похожий пример описан в секции ``\SwitchCaseDefaultSectionName'', здесь~\ref{jump_to_last_printf}.

\subsubsection{Оптимизирующий Keil: режим thumb}

\begin{lstlisting}
.text:0000000C             printf_main1
.text:0000000C 10 B5                       PUSH    {R4,LR}
.text:0000000E 03 23                       MOVS    R3, #3
.text:00000010 02 22                       MOVS    R2, #2
.text:00000012 01 21                       MOVS    R1, #1
.text:00000014 A4 A0                       ADR     R0, aADBDCD     ; "a=%d; b=%d; c=%d\n"
.text:00000016 06 F0 EB F8                 BL      __2printf
.text:0000001A 10 BD                       POP     {R4,PC}
\end{lstlisting}

Здесь нет особых отличий от неоптимизированного варианта для режима ARM.

\subsection{ARM: 8 аргументов в \printf}

Для того, чтобы посмотреть, как остальные аргументы будут передаваться через стек, изменим пример еще раз, 
увеличив количество передаваемых аргументов до 9 (строка формата \printf и еще 8 переменных типа \Tint):

\begin{lstlisting}
void printf_main2()
{
	printf("a=%d; b=%d; c=%d; d=%d; e=%d; f=%d; g=%d; h=%d\n", 1, 2, 3, 4, 5, 6, 7, 8);
};
\end{lstlisting}

\subsubsection{Оптимизирующий Keil: режим ARM}

\begin{lstlisting}
.text:00000028             printf_main2
.text:00000028
.text:00000028             var_18          = -0x18
.text:00000028             var_14          = -0x14
.text:00000028             var_4           = -4
.text:00000028
.text:00000028 04 E0 2D E5                 STR     LR, [SP,#var_4]!
.text:0000002C 14 D0 4D E2                 SUB     SP, SP, #0x14
.text:00000030 08 30 A0 E3                 MOV     R3, #8
.text:00000034 07 20 A0 E3                 MOV     R2, #7
.text:00000038 06 10 A0 E3                 MOV     R1, #6
.text:0000003C 05 00 A0 E3                 MOV     R0, #5
.text:00000040 04 C0 8D E2                 ADD     R12, SP, #0x18+var_14
.text:00000044 0F 00 8C E8                 STMIA   R12, {R0-R3}
.text:00000048 04 00 A0 E3                 MOV     R0, #4
.text:0000004C 00 00 8D E5                 STR     R0, [SP,#0x18+var_18]
.text:00000050 03 30 A0 E3                 MOV     R3, #3
.text:00000054 02 20 A0 E3                 MOV     R2, #2
.text:00000058 01 10 A0 E3                 MOV     R1, #1
.text:0000005C 6E 0F 8F E2                 ADR     R0, aADBDCDDDEDFDGD ; "a=%d; b=%d; c=%d; d=%d; e=%d; f=%d; g=%"...
.text:00000060 BC 18 00 EB                 BL      __2printf
.text:00000064 14 D0 8D E2                 ADD     SP, SP, #0x14
.text:00000068 04 F0 9D E4                 LDR     PC, [SP+4+var_4],#4
\end{lstlisting}

\subsubsection{Оптимизирующий Keil: режим thumb}

\begin{lstlisting}
.text:0000001C             printf_main2
.text:0000001C
.text:0000001C             var_18          = -0x18
.text:0000001C             var_14          = -0x14
.text:0000001C             var_8           = -8
.text:0000001C
.text:0000001C 00 B5                       PUSH    {LR}
.text:0000001E 08 23                       MOVS    R3, #8
.text:00000020 85 B0                       SUB     SP, SP, #0x14
.text:00000022 04 93                       STR     R3, [SP,#0x18+var_8]
.text:00000024 07 22                       MOVS    R2, #7
.text:00000026 06 21                       MOVS    R1, #6
.text:00000028 05 20                       MOVS    R0, #5
.text:0000002A 01 AB                       ADD     R3, SP, #0x18+var_14
.text:0000002C 07 C3                       STMIA   R3!, {R0-R2}
.text:0000002E 04 20                       MOVS    R0, #4
.text:00000030 00 90                       STR     R0, [SP,#0x18+var_18]
.text:00000032 03 23                       MOVS    R3, #3
.text:00000034 02 22                       MOVS    R2, #2
.text:00000036 01 21                       MOVS    R1, #1
.text:00000038 A0 A0                       ADR     R0, aADBDCDDDEDFDGD ; "a=%d; b=%d; c=%d; d=%d; e=%d; f=%d; g=%"...
.text:0000003A 06 F0 D9 F8                 BL      __2printf
.text:0000003E
.text:0000003E             loc_3E                                  ; CODE XREF: example13_f+16
.text:0000003E 05 B0                       ADD     SP, SP, #0x14
.text:00000040 00 BD                       POP     {PC}
\end{lstlisting}


\subsubsection{Оптимизирующий Xcode: режим ARM}

\begin{lstlisting}
__text:0000290C             _printf_main2
__text:0000290C
__text:0000290C             var_1C          = -0x1C
__text:0000290C             var_C           = -0xC
__text:0000290C
__text:0000290C 80 40 2D E9                 STMFD           SP!, {R7,LR}
__text:00002910 0D 70 A0 E1                 MOV             R7, SP
__text:00002914 14 D0 4D E2                 SUB             SP, SP, #0x14
__text:00002918 70 05 01 E3                 MOV             R0, #0x1570
__text:0000291C 07 C0 A0 E3                 MOV             R12, #7
__text:00002920 00 00 40 E3                 MOVT            R0, #0
__text:00002924 04 20 A0 E3                 MOV             R2, #4
__text:00002928 00 00 8F E0                 ADD             R0, PC, R0
__text:0000292C 06 30 A0 E3                 MOV             R3, #6
__text:00002930 05 10 A0 E3                 MOV             R1, #5
__text:00002934 00 20 8D E5                 STR             R2, [SP,#0x1C+var_1C]
__text:00002938 0A 10 8D E9                 STMFA           SP, {R1,R3,R12}
__text:0000293C 08 90 A0 E3                 MOV             R9, #8
__text:00002940 01 10 A0 E3                 MOV             R1, #1
__text:00002944 02 20 A0 E3                 MOV             R2, #2
__text:00002948 03 30 A0 E3                 MOV             R3, #3
__text:0000294C 10 90 8D E5                 STR             R9, [SP,#0x1C+var_C]
__text:00002950 A4 05 00 EB                 BL              _printf
__text:00002954 07 D0 A0 E1                 MOV             SP, R7
__text:00002958 80 80 BD E8                 LDMFD           SP!, {R7,PC}
\end{lstlisting}

\subsubsection{Оптимизирующий Xcode: режим thumb}

\begin{lstlisting}
__text:00002BA0                   _printf_main2
__text:00002BA0
__text:00002BA0                   var_1C          = -0x1C
__text:00002BA0                   var_18          = -0x18
__text:00002BA0                   var_C           = -0xC
__text:00002BA0
__text:00002BA0 80 B5                             PUSH            {R7,LR}
__text:00002BA2 6F 46                             MOV             R7, SP
__text:00002BA4 85 B0                             SUB             SP, SP, #0x14
__text:00002BA6 41 F2 D8 20                       MOVW            R0, #0x12D8
__text:00002BAA 4F F0 07 0C                       MOV.W           R12, #7
__text:00002BAE C0 F2 00 00                       MOVT.W          R0, #0
__text:00002BB2 04 22                             MOVS            R2, #4
__text:00002BB4 78 44                             ADD             R0, PC  ; char *
__text:00002BB6 06 23                             MOVS            R3, #6
__text:00002BB8 05 21                             MOVS            R1, #5
__text:00002BBA 0D F1 04 0E                       ADD.W           LR, SP, #0x1C+var_18
__text:00002BBE 00 92                             STR             R2, [SP,#0x1C+var_1C]
__text:00002BC0 4F F0 08 09                       MOV.W           R9, #8
__text:00002BC4 8E E8 0A 10                       STMIA.W         LR, {R1,R3,R12}
__text:00002BC8 01 21                             MOVS            R1, #1
__text:00002BCA 02 22                             MOVS            R2, #2
__text:00002BCC 03 23                             MOVS            R3, #3
__text:00002BCE CD F8 10 90                       STR.W           R9, [SP,#0x1C+var_C]
__text:00002BD2 01 F0 0A EA                       BLX             _printf
__text:00002BD6 05 B0                             ADD             SP, SP, #0x14
__text:00002BD8 80 BD                             POP             {R7,PC}
\end{lstlisting}


