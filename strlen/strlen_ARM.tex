\subsection{ARM}

\subsubsection{\NonOptimizingXcode + режим ARM}

\lstinputlisting{strlen/xcode_ARM_O0_en.asm}

Неоптимизирующий LLVM генерирует слишком много кода, зато на этом примере можно посмотреть, как функции работают
с локальными переменными в стеке. В нашей программе локальных переменных две, это два указателя, \IT{eos} и \IT{str}.

В этом листинге, сгенерированном при помощи \IDA, я переименовал \IT{var\_8} и \IT{var\_4} в \IT{eos} и \IT{str} вручную.

Итак, первые несколько инструкций просто сохраняют входное значение в переменных \IT{str} и \IT{eos}.

Начиная с метки \IT{loc\_2CB8}, начинается тело цикла.

Первые три инструкции в теле цикла (\TT{LDR}, \ADD, \TT{STR}) загружают значение \IT{eos} в \TT{R0}, 
затем происходит инкремент значения и оно
сохраняется назад в локальной переменной расположенной в стеке eos.

Следующая инструкция \TT{``LDRSB R0, [R0]''} (\IT{Load Register Signed Byte}) загружает байт из памяти по адресу \TT{R0},
расширяет его до 32-бит считая его знаковым (signed) и сохраняет в \TT{R0}. Это немного похоже на \MOVSX в x86.
Байт считается знаковым (signed), потому что тип \Tchar по стандарту Си --- знаковый.
Об это я уже немного писал~\ref{MOVSX} в этой же секции, посвященной x86.

Следует также заметить, что, в ARM нет возможности использовать 8-битную или 16-битную часть регистра, как это возможно
в x86. 
Вероятно, это связано с тем что за x86 тянется длинный шлейф совместимости с 16-битным 8086 и даже с 8-битным 8080, а ARM
разрабатывался с чистого листа как 32-битный RISC-процессор. 
Следовательно, чтобы работать с отдельными байтами на ARM, так или иначе, придется использовать 32-битные регистры.

Итак, \TT{LDRSB} загружает символ из строки в \TT{R0}, по одному. 
Следующие инструкции \CMP и \TT{BEQ} проверяют, является ли этот символ нулем.
Если нет, то происходит переход на начало тела цикла. А если нет, выходим из цикла.

В конце функции вычисляется разница между eos и str, вычитается еще единица и вычисленное значение возвращается в \TT{R0}.

Кстати, обратите внимание, в этой функции не сохранялись регистры. Это потому что, по стандарту, регистры \TT{R0}-\TT{R3} 
не нужно сохранять, они предназначены для передачи аргументов, и их можно использовать как захочется, потому что они больше 
не нужны вызывающей функции. 
А так как никакие больше регистры не используются, то и сохранять нечего. Поэтому, из этой функции можно выйти
простым переходом (\TT{BX}) по адресу в регистре \LR.

%\subsubsection{\NonOptimizingXcode + режим thumb}
%Практически, точно такой же код.

\subsubsection{\OptimizingXcode + режим thumb}

\lstinputlisting{strlen/xcode_thumb_O3.asm}

Оптимизирующий LLVM решил что под переменные eos и str выделять место в стеке не обязательно, и эти переменные можно хранить
прямо в регистрах. Перед началом тела цикла, str будет находиться в R0, а eos --- в R1.

Инструкция \TT{``LDRB.W R2, [R1],\#1''} загружает в R2 байт из памяти по адресу R1, расширяя как знаковый (signed) до 32-битного
значения, но не только. \#1 в конце инструкции называется ``Post-indexed addressing'', это значит что после загрузки байта,
к \TT{R1} добавится единица. Это очень удобно для работы с массивами.

Такого режима адресации в x86 нет, но он есть в некоторых других процессорах, даже на PDP-11. Существует байка, что режимы
пре-инкремента, пост-инкремента, пре-декремента и пост-декремента адреса в PDP-11, выразились в таких фичах языка Си (который
разрабатывался на PDP-11) как *ptr++, *++ptr, *ptr-{}-, *-{}-ptr. Кстати, это часто является предметом путанницы в Си.
Дела обстоят так: 

\begin{center}
\begin{tabular}{ | l | l | l | l | }
\hline                        
\cellcolor{blue!25} термин в Си & \cellcolor{blue!25} термин в ARM & \cellcolor{blue!25} выражение Си & \cellcolor{blue!25}как это работает \\
\hline                        
Пост-инкремент & post-indexed addressing & \TT{*ptr++} & использовать значение *ptr, \\
& & & затем икремент указателя ptr \\
\hline                        
Пост-декремент & post-indexed addressing & \TT{*ptr-{}-} & использовать значение *ptr, \\
& & & затем декремент указателя ptr \\
\hline                        
Пре-инкремент & pre-indexed addressing & \TT{*++ptr} & инкремент указателя ptr, \\
& & & затем использовать значение *ptr \\
\hline                        
Пре-декремент & post-indexed addressing & \TT{*-{}-ptr} & декремент указателя ptr, \\
& & & затем использовать значение *ptr \\
\hline  
\end{tabular}
\end{center}

Впрочем, Деннис Ритчи (один из создателей ЯП Си) указывал, что, это, вероятно, придумал Кен Томпсон (еще один создатель Си),
потому что подобная возможность процессора была еще в PDP-7
\footnote{
        \href{http://yurichev.com/mirrors/c_dmr_postincrement.txt}
        {
            \IFRU{Пост Денниса Ритчи в net.lang.c (usenet) об этом}{Dennis Ritchie usenet post about it in net.lang.c}
        }
    }
\footnote{
    \href{http://yurichev.com/mirrors/cm.bell-labs.com/cm/cs/who/dmr/chist.html}
    {Dennis Ritchie: The Development of the C Language}
    }.
Таким образом, компиляторы с ЯП Си на тот процессор, где это есть, могут использовать это.

Итак, далее в теле цикла \CMP и \TT{BNE} продолжают работу цикла, до тех пор, пока не будет встречен 0.

После конца цикла \TT{MVNS}\footnote{MoVe Not} (инвертирование всех бит в значении, аналог \NOT на x86) и \ADD вычисляют $eos - str - 1$. 
На самом деле, эти две инструкции вычисляют $R0 = ~str + eos$, что эквивалентно тому, что было в исходном коде, 
а почему это так, я уже описывал чуть раньше, здесь~\ref{strlen_NOT_ADD}. Вероятно, LLVM, как и GCC, посчитал что так
будет короче, или быстрее.

%\subsubsection{\OptimizingXcode + режим ARM}
%Практически, точно такой же код.

\subsubsection{\OptimizingKeil{} + режим ARM}

\lstinputlisting{strlen/Keil_ARM_O3.asm}

Практически то же самое что мы уже видели, за тем исключением что выражение $str - eos - 1$ может быть вычислено
не в самом конце функции, а прямо в теле цикла. Суффикс \TT{-EQ}, как мы помним, означает что инструкция будет выполнена только
если операнды в исполненной перед этим инструкции \CMP были равны. 
Таким образом, если в \TT{R0} будет 0, обе инструкции \TT{SUBEQ} исполнятся и результат останется в \TT{R0}.

