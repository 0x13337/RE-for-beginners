\subsection{ARM}

\subsubsection{\NonOptimizingXcode + режим ARM}

\lstinputlisting{strlen/xcode_ARM_O0_en.asm}

Неоптимизирующий LLVM генерирует слишком много кода, зато на этом примере можно посмотреть, как функции работают
с локальными переменными в стеке. В нашей программе локальных переменных две, это два указателя, \IT{eos} и \IT{str}.

В этом листинге, сгенерированном при помощи \IDA, я переименовал \IT{var\_8} и \IT{var\_4} в \IT{eos} и \IT{str} вручную.

Итак, первые несколько инструкций просто сохраняют входное значение в переменных \IT{str} и \IT{eos}.

Начиная с метки \IT{loc\_2CB8}, начинается тело цикла.

Первые три инструкции в теле цикла (\TT{LDR}, \ADD, \TT{STR}) загружают значение \IT{eos} в \TT{R0}, 
затем происходит инкремент значения и оно
сохраняется назад в локальной переменной расположенной в стеке eos.

Следующая инструкция \TT{``LDRSB R0, [R0]''} (\IT{Load Register Signed Byte}) загружает байт из памяти по адресу \TT{R0},
расширяет его до 32-бит считая его знаковым (signed) и сохраняет в \TT{R0}. Это немного похоже на \MOVSX в x86.
Байт считается знаковым (signed), потому что тип \Tchar по стандарту Си --- знаковый.
Об это я уже немного писал~\ref{MOVSX} в этой же секции, посвященной x86.

Следует также заметить, что, в ARM нет возможности использовать 8-битную или 16-битную часть регистра, как это возможно
в x86. 
Вероятно, это связано с тем что за x86 тянется длинный шлейф совместимости с 16-битным 8086 и даже с 8-битным 8080, а ARM
разрабатывался с чистого листа как 32-битный RISC-процессор. 
Следовательно, чтобы работать с отдельными байтами на ARM, так или иначе, придется использовать 32-битные регистры.

Итак, \TT{LDRSB} загружает символ из строки в \TT{R0}, по одному. 
Следующие инструкции \CMP и \TT{BEQ} проверяют, является ли этот символ нулем.
Если нет, то происходит переход на начало тела цикла. А если нет, выходим из цикла.

В конце функции вычисляется разница между eos и str, вычитается еще единица и вычисленное значение возвращается в \TT{R0}.

Кстати, обратите внимание, в этой функции не сохранялись регистры. Это потому что, по стандарту, регистры \TT{R0}-\TT{R3} 
не нужно сохранять, они предназначены для передачи аргументов, и их можно использовать как захочется, потому что они больше 
не нужны вызывающей функции. 
А так как никакие больше регистры не используются, то и сохранять нечего. Поэтому, из этой функции можно выйти
простым переходом (\TT{BX}) по адресу в регистре \LR.

