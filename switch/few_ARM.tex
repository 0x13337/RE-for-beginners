%NOTTRANSLATED
\subsubsection{ARM: Оптимизирующий Keil + режим ARM}

\begin{lstlisting}
.text:0000014C             f1
.text:0000014C 00 00 50 E3                 CMP     R0, #0
.text:00000150 13 0E 8F 02                 ADREQ   R0, aZero       ; "zero\n"
.text:00000154 05 00 00 0A                 BEQ     loc_170
.text:00000158 01 00 50 E3                 CMP     R0, #1
.text:0000015C 4B 0F 8F 02                 ADREQ   R0, aOne        ; "one\n"
.text:00000160 02 00 00 0A                 BEQ     loc_170
.text:00000164 02 00 50 E3                 CMP     R0, #2
.text:00000168 4A 0F 8F 12                 ADRNE   R0, aSomethingUnkno ; "something unknown\n"
.text:0000016C 4E 0F 8F 02                 ADREQ   R0, aTwo        ; "two\n"
.text:00000170
.text:00000170             loc_170                                 ; CODE XREF: f1+8
.text:00000170                                                     ; f1+14
.text:00000170 78 18 00 EA                 B       __2printf
\end{lstlisting}

Мы снова не сможем сказать, глядя на этот код, был ли в оригинальном исходном коде switch() либо же несколько
if()-в.

Так или иначе, мы снова видим здесь инструкции с предикатами, например \TT{ADREQ} (\IT{(Equal)}), 
которая будет исполняться только
если $R0=0$, в таком случае, в R0 будет загружен адрес строки \IT{<<zero\textbackslash{}n>>}. 
Следующая инструкция \TT{BEQ} (\IT{(Branch Equal)}) перенаправит
исполнение на \TT{loc\_170}, если $R0=0$. 
Кстати, наблюдательный читатель может спросить, сработает ли \TT{BEQ} нормально,
ведь \TT{ADREQ} перед ним уже заполнила регистр \TT{R0} чем-то другим. 
Сработает, потому что \TT{BEQ} проверяет флаги установленные
инструкцией \CMP, а \TT{ADREQ} флаги никак не модифицирует.

%TODO -S instructions

Далее всё просто и знакомо. Вызов \printf один и в конце, мы уже рассматривали подобный трюк 
здесь~\ref{ARM_B_to_printf}. К \printf{}-у в конце ведут три пути. 

Обратите внимание на то что происходит
если $a=2$ и если $a$ не попадает под сравниваемые константы. Инструкция \TT{``CMP R0, \#2''} нужна чтобы узнать
$a=2$ или нет. Если это не так, то при помощи \TT{ADRNE} (\IT{Not Equal}) в \TT{R0} будет загружен указатель на 
строку \IT{<<something unknown \textbackslash{}n>>},
ведь $a$ уже было проверено на $0$ и $1$ до этого, и здесь $a$ точно не попадает под эти константы. 
Ну а если $R0=2$,
в R0 будет загружен указатель на строку \IT{<<two\textbackslash{}n>>} при помощи инструкции \TT{ADREQ}.

